{"version":3,"sources":["webpack:///webpack/bootstrap 5f13100ecffa9e7a7c62","webpack:///./src/typescript/datatypes.ts","webpack:///external \"React\"","webpack:///./src/typescript/commands.ts","webpack:///./src/typescript/items.ts","webpack:///./src/typescript/text_tools.ts","webpack:///./src/components/Terminal.tsx","webpack:///external \"ReactDOM\"","webpack:///./src/components/Prompt.tsx","webpack:///./src/components/Text.tsx","webpack:///./src/typescript/box_geometry.ts","webpack:///./src/typescript/main.tsx","webpack:///./src/typescript/world.ts","webpack:///./src/typescript/world_update_effects.ts"],"names":[],"mappings":"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SAAO,OAAC,oBAAC,WAAQ,UAAG,OAAU,SAAe,eAAU;AAExB;AACa;AAChB;AACW;AACoE;AACpE;AAGpB;AAEoC;AAC9B;AACE;AACZ;AACyB;AACS;AACL;AACS;AACZ;AACO;AACjC;AACO;AACkB;AAC7B;AACG;AACS;AAChB;AACJ;AAEyD;AAClB;AACF;AACA;AACC;AACH;AAEnB;AACK;AACmD;AACH;AAC3B;AACM;AACpC;AAC8B;AACK;AACF;AACtB;AAClB;AAC8C;AACD;AAClC;AACe;AACR;AAC0B;AACzB;AACnB;AAEkB;AACY;AACD;AACqD;AACnD;AAC3B;AACY;AACO;AACY;AACD;AACR;AACN;AACL;AACE;AACT;AACJ;AACJ;AACgB;AACpB;AACqD;AAEF;AACX;AACO;AAC/C;AAEyC;AACW;AACZ;AAC1B;AACmC;AACnB;AAEoB;AAChB;AACjB;AACkB;AAEgE;AACjF;AACV;AAC0B;AACc;AACxC;AACS;AACb;AACJ;AAEsD;AACN;AAClB;AAES;AAC4B;AAClC;AACO;AAEH;AACA;AACX;AACtB;AACmD;AACvD;AAE+C;AACpB;AACiB;AAEvC;AACL;AAEkC;AAC6B;AACzC;AACP;AACG;AACc;AACwC;AACpC;AACS;AACL;AACJ;AACe;AACK;AAClC;AAC0C;AACtD;AACkD;AACvD;AACwC;AACyB;AACA;AAC3B;AACb;AACQ;AACzB;AACR;AACkB;AACH;AACf;AACW;AACM;AACG;AACvB;AACJ;AACD,S;;;;;;;;;;ACzKT,2CAAmE;AAEnE,wCA2BqB;AAErB,uCA0BmB;AAEnB,mDAA2F;AAE3F,oCAAiD;AAEjD,yCAAwG;AAYxG;AAOI,gBAAY,EAAS,UAAY,YAAc,cAAY,YAAsB;AAC1E,YAAS,aAAe,WAAE;AACjB,uBAAG,IAAI,eAAO,QAAC,EAAW,YAAE,CAAE,GAAG,GAC7C;AAAC;AACG,aAAS,WAAY;AAEtB,YAAW,eAAe,WAAE;AACjB,yBAAO,KAAmB,mBAAK,KAC7C;AAAC;AACG,aAAW,aAAc;AAE1B,YAAa,iBAAe,WAAE;AACjB,2BAAO,KAAqB,qBAAK,KACjD;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","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 10);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 5f13100ecffa9e7a7c62","// import {\n//     Collection,\n//     hash,\n//     isImmutable,\n//     List,\n//     Map,\n//     Set\n// } from 'immutable';\n\nexport class FuckDict<K, V> {\n    readonly keys_map: Map<string, K>;\n    readonly values_map: Map<string, V>;\n\n    size: number = 0\n\n    constructor(a?: [K, V][]) {\n        this.keys_map = new Map<string, K>();\n        this.values_map = new Map<string, V>();\n\n        if (a !== undefined) {\n            for (let [k, v] of a) {\n                this.set(k, v);\n            }\n        }\n    }\n\n    set(k: K, v: V) {\n        let s = k.toString();\n        this.keys_map.set(s, k);\n        this.values_map.set(s, v);\n        this.size = this.keys_map.size;\n        return this;\n    }\n\n    get(k: K) {\n        let s = k.toString();\n        return this.values_map.get(s);\n    }\n\n    has_key(k: K) {\n        return this.keys_map.has(k.toString());\n    }\n\n    keys_array() {\n        return Array.from(this.keys_map.values());\n    }\n\n    values_array() {\n        return Array.from(this.values_map.values());\n    }\n\n    entries_array(): [K, V][] {\n        let result: [K, V][] = [];\n        for (let [s, k] of this.keys_map.entries()) {\n            result.push([k, this.values_map.get(s)]);\n        }\n        return result;\n    }\n\n    keys_equal(other: FuckDict<K, V>) {\n        for (let elem of this.keys_array()) {\n            if (!other.has_key(elem)){\n                return false;\n            }\n        }\n\n        for (let elem of other.keys_array()) {\n            if (!this.has_key(elem)){\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    keys_intersect(other: FuckDict<K, V>) {\n        let result: K[] = [];\n        for (let k of this.keys_array()) {\n            if (other.has_key(k)) {\n                result.push(k)\n            }\n        }\n        return result;\n    }\n\n    keys_subset(other: FuckDict<K, V>) {\n        for (let elem of this.keys_array()) {\n            if (!other.has_key(elem)){\n                return false;\n            }\n        }\n        return true;\n    }\n\n    toString() {\n        let entry_strings: string[] = this.entries_array().map((x) => x.toString()).sort();\n\n        return `FuckDict<${entry_strings.join(',')}>`;\n    }\n\n    copy() {\n        return new FuckDict(this.entries_array());\n    }\n}\n\nexport type FuckSet<T> = FuckDict<T, undefined>;\n\nexport function arrays_fuck_equal<T>(ar1: T[], ar2: T[]) {\n    if (ar1.length !== ar2.length) {\n        return false;\n    }\n\n    for (let i = 0; i < ar1.length; i++) {\n        if (ar1[i].toString() !== ar2[i].toString()) {\n            return false;\n        }\n    }\n    return true;\n}\n\nexport function array_fuck_contains<T>(ar: T[], elt: T){\n    return ar.some((x) => x.toString() === elt.toString())\n}\n\nexport type Partition = FuckSet<number>;\n\n\nexport class Edge {\n    readonly start: number;\n    readonly end: number;\n\n    constructor(start: number, end: number){\n        if (end < start){\n            this.start = end;\n            this.end = start;\n        } else {\n            this.start = start;\n            this.end = end;\n        }\n    }\n\n    equals(other:Edge){\n        return (this.start === other.start && this.end === other.end);\n    }\n\n    toString(): string {\n        return `Edge<${this.start},${this.end}>`;\n    }\n}\n\nexport enum Face {\n    n = 0,\n    s = 1,\n    e = 2,\n    w = 3,\n    t = 4,\n    b = 5\n}\n\nexport let faces = [Face.n, Face.s, Face.e, Face.w, Face.t, Face.b];\n\nexport enum Direction {\n    n = 0,\n    s = 1,\n    e = 2,\n    w = 3\n}\n\nexport let directions = [Direction.n, Direction.s, Direction.e, Direction.w];\n\nexport let direction_2_face = new Map<Direction, Face>([\n    [Direction.n, Face.n],\n    [Direction.s, Face.s],\n    [Direction.e, Face.e],\n    [Direction.w, Face.w]\n]);\n\nexport class Dangle {\n    readonly partition: Partition;\n    readonly edges: Edge[];\n    readonly fixed_face: Face;\n    readonly free_face: Face;\n\n    constructor(partition: Partition, edges: Edge[], fixed_face: Face, free_face: Face) {\n        this.partition = partition;\n        this.edges = edges;\n        this.fixed_face = fixed_face;\n        this.free_face = free_face;\n    }\n\n    equals(other: Dangle){\n        return (\n            this.partition.keys_equal(other.partition)\n            && arrays_fuck_equal(this.edges, other.edges)\n            && this.fixed_face === other.fixed_face\n            && this.free_face === other.free_face);\n    }\n\n    toString() {\n        return `Dangle<${this.partition},${this.edges},${this.fixed_face},${this.free_face}>`;\n        \n        //let faces_hash = (this.fixed_face << 16) ^ this.free_face; //fuck!\n        //return this.partition.hashCode() + this.edges.hashCode() + faces_hash;\n    }\n}\n\nexport type Point2 = [number, number];\n\nexport function make_matrix2(data_obj: number[][]) {\n    let dim_y = data_obj.length;\n    let dim_x = data_obj[0].length;\n\n    let data = new Int16Array(data_obj.reduce((x, y) => x.concat(y)));\n    // TODO complain if the total length is wrong\n    return new Matrix2(data, dim_x, dim_y);\n}\n\nexport class Matrix2 {\n    readonly dim_x: number;\n    readonly dim_y: number;\n    readonly data: Int16Array;\n    \n    constructor (data: Int16Array, dim_x: number, dim_y: number) {\n        this.data = data;\n        this.dim_x = dim_x;\n        this.dim_y = dim_y;\n    }\n\n    get(x: number, y: number): number {\n        return this.data[y * this.dim_x + x];\n    }\n\n    set(x: number, y: number, value: number) {\n        this.data[y * this.dim_x + x] = value;\n    }\n\n    rotate(degrees: number): Matrix2 {\n        //validate input better\n\n        if (degrees == 360 || degrees == 0) {\n            return this;\n        }\n\n        const n_rotations = degrees / 90;\n        let m: Matrix2 = this;\n        const dim_x = this.dim_x;\n        const dim_y = this.dim_y;\n        for (let i = 0; i < n_rotations; i++){\n            let new_data = new Int16Array(dim_x * dim_y);\n            let new_mat2 = new Matrix2(new_data, dim_y, dim_x);\n            for (let y = 0; y < dim_y; y++){\n                for (let x = 0; x < dim_x; x++){\n                    new_mat2.set(dim_y - 1 - y, x, m.get(x, y));\n                }\n            }\n            m = new_mat2;\n        }\n        return m\n    }\n\n    contains(value: number): boolean{\n        return this.data.indexOf(value) !== -1;\n    }\n}\n\n\nexport enum CardboardEdge {\n    intact = 0,\n    cut = 1,\n}\n\nexport enum TapeEdge {\n    untaped = 0,\n    taped = 1,\n    cut = 2\n}\n\nexport class EdgeState {\n    readonly cardboard: CardboardEdge;\n    readonly tape: TapeEdge;\n\n    constructor (cardboard?: CardboardEdge, tape?: TapeEdge){\n        if (cardboard === undefined) {\n            cardboard = CardboardEdge.intact;\n        }\n        this.cardboard = cardboard;\n\n        if (tape === undefined) {\n            tape = TapeEdge.untaped;\n        }\n        this.tape = tape;\n    }\n\n    cut() {\n        let new_tape: TapeEdge;\n        if (this.tape == TapeEdge.taped) {\n            new_tape = TapeEdge.cut;\n        } else {\n            new_tape = this.tape\n        }\n\n        return new EdgeState(CardboardEdge.cut, new_tape);\n    }\n\n\n    apply_tape() {\n        return new EdgeState(this.cardboard, TapeEdge.taped);\n    }\n}\n\nexport enum EdgeOperation {\n    cut = 0,\n    tape = 1\n}\n\nexport enum EdgeDirection {\n    horizontal = 0,\n    vertical = 1\n}\n\nexport enum RendState {\n    closed = 0,\n    open = 1\n}\n\nexport enum RendOperation {\n    close = 0,\n    open = 1\n}\n\nexport enum SpillageLevel {\n    none = 0,\n    light = 1,\n    heavy = 2\n}\n\nexport enum Weight {\n    empty = 0,\n    very_light = 1,\n    light = 2,\n    medium = 3,\n    heavy = 4,\n    very_heavy = 5\n}\n\nexport abstract class Item {\n    abstract weight(): Weight;\n    abstract name(): string;\n    abstract pre_gestalt(): string;\n    abstract post_gestalt(): string;\n    article(): string {\n        return 'a';\n    }\n}\n\n\nexport type Counter<T> = Map<T, number>;\n\nexport function counter_add<T>(counter: Counter<T>, key: T, inc: number){\n    let cur_val = 0;\n    if (counter.has(key)){\n        cur_val = counter.get(key);\n    }\n    return counter.set(key, cur_val + inc);\n}\n\nexport function counter_get<T>(counter: Counter<T>, key: T){\n    let cur_val = 0;\n    if (counter.has(key)){\n        cur_val = counter.get(key);\n    }\n    return cur_val;\n}\n\nexport function counter_update<T>(counter1: Counter<T>, counter2: Counter<T>){\n    counter2.forEach(function (v, k){\n        counter_add(counter1, k, v);\n    });\n\n    return counter1;\n}\n\nexport function counter_order<T>(counter: Counter<T>, include_zero=false){\n    let result = Array.from(counter.entries()).sort((a, b) => a[1] - b[1]);\n    if (!include_zero) {\n        result = result.filter(([t, i]) => i > 0);\n    }\n    return result.map(([t, i]) => t);\n}\n\nexport enum RelativePosition {\n    left = 0, center = 1, right = 2,\n    top = 3, middle = 4, bottom = 5\n}\n\nexport class WreckError extends Error {}\n\n// used to signal errors caused by trying to update world state in a way that breaks the reality of the world\n// so assumes that commands are already valid, the attempted update *could work* if the state were different\nexport class WorldUpdateError extends WreckError {}\n\n// used to signal that a command/pseudo command is not specified legally\n// the command cannot be executed because it *cannot be interpreted*\nexport class CommandError extends WreckError {}\n\n\n// WEBPACK FOOTER //\n// ./src/typescript/datatypes.ts","module.exports = React;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"React\"\n// module id = 1\n// module chunks = 0","// import {Map} from 'immutable';\nimport {Direction, EdgeOperation, EdgeDirection, Face, RelativePosition, RendOperation} from './datatypes';\n\nimport {starts_with, tokenize, untokenize, normalize_whitespace} from './text_tools';\n\nexport type Token = string;\n\nexport type HorizPositionWord = 'left' | 'center' | 'right';\nexport let horiz_position_word_tokens: [HorizPositionWord][] = [['left'], ['center'], ['right']];\n\nexport type VertPositionWord = 'top' | 'middle' | 'bottom';\nexport let vert_position_word_tokens: [VertPositionWord][] = [['top'], ['middle'], ['bottom']];\n\nexport type PositionWord = HorizPositionWord | VertPositionWord;\nexport let word_2_relative_position = new Map<PositionWord, RelativePosition>([\n    ['left', RelativePosition.left],\n    ['center', RelativePosition.center],\n    ['right', RelativePosition.right],\n    ['top', RelativePosition.top],\n    ['middle', RelativePosition.middle],\n    ['bottom', RelativePosition.bottom]\n]);\nexport let position_word_tokens: [PositionWord][] = (<[PositionWord][]>horiz_position_word_tokens).concat(vert_position_word_tokens);\n\nexport type FaceWord = 'back' | 'front' | 'right' | 'left' | 'top' | 'bottom';\nexport let word_2_face = new Map<FaceWord, Face>([\n    ['back', Face.n],\n    ['front', Face.s],\n    ['right', Face.e],\n    ['left', Face.w],\n    ['top', Face.t],\n    ['bottom', Face.b]\n]);\nexport let face_word_tokens: [FaceWord][] = [['back'], ['front'], ['right'], ['left'], ['top'], ['bottom']];\n\nexport type RendOpWord = 'remove' | 'replace';\nexport let word_2_rend_op = new Map<RendOpWord, RendOperation>([\n    ['remove', RendOperation.open],\n    ['replace', RendOperation.close]\n]);\nexport let rend_op_word_tokens: [RendOpWord][] = [['remove'], ['replace']];\n\nexport type DangleOpWord = 'open' | 'close';\nexport let word_2_dangle_op = new Map<DangleOpWord, RendOperation>([\n    ['open', RendOperation.open],\n    ['close', RendOperation.close]\n]);\nexport let dangle_op_word_tokens: [DangleOpWord][] = [['open'], ['close']];\n\n\nexport type EdgeOpWord = 'cut' | 'tape';\nexport let word_2_edge_op = new Map<EdgeOpWord, EdgeOperation>([\n    ['cut', EdgeOperation.cut],\n    ['tape', EdgeOperation.tape]\n]);\nexport let edge_op_word_tokens: [EdgeOpWord][] = [['cut'], ['tape']];\n\nexport type EdgeDirWord = 'horizontally' | 'vertically';\nexport let word_2_edge_dir = new Map<EdgeDirWord, EdgeDirection>([\n    ['horizontally', EdgeDirection.horizontal],\n    ['vertically', EdgeDirection.vertical]\n]);\nexport let edge_dir_word_tokens: [EdgeDirWord][] = [['horizontally'], ['vertically']];\n\nexport type RotateYDirWord = \"left\" | \"right\";\nexport let word_2_degrees = new Map<RotateYDirWord, number>([\n    ['left', 270],\n    ['right', 90]\n]);\nexport let rotate_y_word_tokens: [RotateYDirWord][] = [['left'], ['right']];\n\nexport type RollDirWord = \"forward\" | \"backward\" | \"left\" | \"right\";\nexport let word_2_dir = new Map<RollDirWord, Direction>([\n    ['forward', Direction.n],\n    ['backward', Direction.s],\n    ['left', Direction.w],\n    ['right', Direction.e]\n]);\nexport let roll_dir_word_tokens: [RollDirWord][] = [['forward'], ['backward'], ['left'], ['right']];\n\nexport enum DisplayEltType {\n    keyword = 0,\n    option = 1,\n    filler = 2,\n    partial = 3,\n    error = 4\n}\n\nexport interface DisplayElt {\n    display: DisplayEltType, // the intended display style for this element\n    match: string, // the string that the parser matched for this element\n    offset: number, // the number of characters offset into the full string where this match starts\n    typeahead?: string[], // array of typeahead options\n    name?: string // internal name of this match (probably not useful for rendering purposes)\n}\n\nexport enum MatchValidity {\n    valid = 0,\n    partial = 1,\n    invalid = 2\n}\n\nexport class CommandParser {\n    command: string;\n    tokens: Token[];\n    token_positions: number[];\n    position: number = 0;\n    validity: MatchValidity = MatchValidity.valid;\n    match: DisplayElt[] = [];\n\n    constructor(command: string) {\n        this.command = command;\n        [this.tokens, this.token_positions] = tokenize(command);\n    }\n\n    consume_exact(spec_tokens: Token[], display: DisplayEltType=DisplayEltType.keyword, name?: string): boolean {\n        if (spec_tokens.length === 0) {\n            throw new Error(\"Can't consume an empty spec.\");\n        }\n        let offset = this.token_positions[this.position]\n        \n        let match_tokens: Token[] = [];\n        let match_token_positions: number[] = [];\n        let pos_offset = 0;\n        for (let spec_tok of spec_tokens) {\n            if (this.position + pos_offset === this.tokens.length) {\n                this.validity = MatchValidity.partial;\n                break; //partial validity\n            }\n            let next_tok = this.tokens[this.position + pos_offset];\n            let next_tok_pos = this.token_positions[this.position + pos_offset];\n\n            if (spec_tok === next_tok) {\n                match_tokens.push(next_tok);\n                match_token_positions.push(next_tok_pos);\n                pos_offset++;\n                continue;\n            }\n\n            if (starts_with(spec_tok, next_tok)) {\n                match_tokens.push(next_tok);\n                match_token_positions.push(next_tok_pos);\n                this.validity = MatchValidity.partial;\n                pos_offset++;\n                break;\n            }\n\n            this.validity = MatchValidity.invalid;\n            break;   \n        }\n\n        this.position += pos_offset;\n\n\n        if (this.validity === MatchValidity.valid) {\n            this.match.push({\n                display: display,\n                match: untokenize(match_tokens, match_token_positions),\n                offset: offset,\n                name: name});\n            return true;\n        }\n\n        if (this.validity === MatchValidity.partial) {\n            if (this.position === this.tokens.length) {\n                this.match.push({\n                    display: DisplayEltType.partial,\n                    match: untokenize(match_tokens, match_token_positions),\n                    offset: offset,\n                    typeahead: [untokenize(spec_tokens)],\n                    name: name});\n\n                return false;\n            } else {\n                this.validity = MatchValidity.invalid;\n            }\n        }\n\n        match_tokens.push(...this.tokens.slice(this.position));\n        match_token_positions.push(...this.token_positions.slice(this.position));\n        this.position = this.tokens.length;\n        this.match.push({\n            display: DisplayEltType.error,\n            match: untokenize(match_tokens, match_token_positions),\n            offset: offset,\n            name: name});\n        return false;\n    }\n\n    subparser() {\n        return new CommandParser(untokenize(this.tokens.slice(this.position)));\n    }\n\n    integrate(subparser: CommandParser) {\n        this.position += subparser.position;\n        this.match.push(...subparser.match);\n        this.validity = subparser.validity;\n    }\n\n    consume_option<S extends string>(option_spec_tokens: Token[][], name?: string, display: DisplayEltType=DisplayEltType.option): S | false{\n        let offset = this.token_positions[this.position];\n\n        let partial_matches: DisplayElt[] = []; \n        for (let spec_toks of option_spec_tokens) {\n            let subparser = this.subparser();\n            let exact_match = subparser.consume_exact(spec_toks, display, name);\n\n            if (exact_match) {\n                this.integrate(subparser);\n                // this.match.push(subparser.match[0]);\n                // this.position += subparser.position;\n                return <S>normalize_whitespace(subparser.match[0].match);\n            }\n\n            if (subparser.validity === MatchValidity.partial){\n                partial_matches.push(subparser.match[0]);\n            }\n        }\n\n        if (partial_matches.length > 0) {\n            this.validity = MatchValidity.partial;\n            this.position = this.tokens.length - 1;\n            let typeahead = partial_matches.map((de) => de.typeahead[0]);\n            this.match.push({\n                display: DisplayEltType.partial,\n                match: partial_matches[0].match,\n                offset: offset,\n                typeahead: typeahead,\n                name: name})\n            return false;\n        }\n\n        this.validity = MatchValidity.invalid;\n        let match_tokens = this.tokens.slice(this.position);\n        let match_token_positions = this.token_positions.slice(this.position);\n        this.match.push({\n            display: DisplayEltType.error,\n            match: untokenize(match_tokens, match_token_positions),\n            offset: offset,\n            name: name});\n        return false;\n    }\n\n    consume_filler(spec_tokens: Token[]){\n        return this.consume_exact(spec_tokens, DisplayEltType.filler);\n    }\n\n    is_done() {\n        if (this.position !== this.tokens.length) {\n            return false;\n        }\n\n        return this.validity === MatchValidity.valid;\n    }\n\n    done() {\n        if (this.position !== this.tokens.length) {\n            this.validity = MatchValidity.invalid;\n            this.match.push({\n                display: DisplayEltType.error,\n                match: untokenize(this.tokens.slice(this.position)),\n                offset: this.token_positions[this.position]\n            });\n            this.position = this.tokens.length;\n        }\n\n        return this.validity === MatchValidity.valid;\n    }\n\n    get_match(name: string){\n        for (let m of this.match) {\n            if (m.name === name) {\n                return m;\n            }\n        }\n        return null;\n    }\n}\n\nexport interface WorldType {\n    get_command_map(): Map<String, Command<this>>\n}\n\nexport type CommandResult<T extends WorldType> = {\n    world?: T;\n    message?: string;\n    parser?: CommandParser;\n} | undefined\n\nexport interface Command<T extends WorldType> {\n    command_name: Token[];\n    execute: (world: T, parser: CommandParser) => CommandResult<T>;\n}\n\nexport function apply_command<T extends WorldType> (world: T, cmd: string) {\n    let parser = new CommandParser(cmd);\n\n    let command_map = world.get_command_map();\n    let options: Token[][] = Array.from(command_map.values()).map((v) => v.command_name);\n\n    let cmd_name = parser.consume_option(options, 'command', DisplayEltType.keyword);\n    let result: CommandResult<T> = {parser: parser, world: world};\n\n    if (!cmd_name) {\n        return result;\n    }\n\n    let command = command_map.get(cmd_name)\n    let cmd_result = command.execute(world, parser);\n    \n    if (cmd_result !== undefined) {\n        if (cmd_result.world !== undefined) {\n            result.world = cmd_result.world;\n        }\n        if (cmd_result.message !== undefined) {\n            result.message = cmd_result.message;\n        }\n    }\n    return result;\n}\n\nexport class WorldDriver<T extends WorldType> {\n    history: CommandResult<T>[];\n    \n    current_state: CommandResult<T>;\n\n    constructor (initial_world: T) {\n        this.history = [{world: initial_world}];\n        this.apply_command('', false); //populate this.current_state\n    }\n\n    apply_command(cmd: string, commit: boolean = true) {\n        let prev_state = this.history[this.history.length - 1];\n        let result = apply_command(prev_state.world, cmd);\n        console.log(cmd);\n        console.log(result.message);\n        console.log(result);\n\n        this.current_state = result;\n        if (commit) {\n            this.commit();\n        }\n        return result;\n    }\n\n    commit() {\n        let result = this.current_state;\n        this.history.push(this.current_state);\n        this.apply_command('', false);\n        return result;\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./src/typescript/commands.ts","import {Item, Weight} from './datatypes'\n\nexport class Codex extends Item {\n    weight() {\n        return Weight.medium;\n    }\n\n    name() {\n        return 'codex';\n    }\n\n    pre_gestalt() {\n        return 'something thick and aged';\n    }\n\n    post_gestalt() {\n        return 'a thick, rotten codex with strange markings on the front';\n    }\n}\n\nexport class CityKey extends Item {\n    weight() {\n        return Weight.light;\n    }\n\n    name() {\n        return 'Key to the City';\n    }\n\n    pre_gestalt() {\n        return 'something glistening and golden';\n    }\n\n    post_gestalt() {\n        return 'a large, heavy golden key';\n    }\n\n    article() {\n        return 'the';\n    }\n}\n\nexport class Pinecone extends Item {\n    weight() {\n        return Weight.very_light;\n    }\n\n    name() {\n        return 'pinecone';\n    }\n\n    pre_gestalt() {\n        return 'something small, brown and flaky';\n    }\n\n    post_gestalt() {\n        return 'a small, brown pinecone that smells of the outdoors';\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./src/typescript/items.ts","import {Face} from './datatypes';\n\nexport function uncapitalize(msg: string) {\n    return msg[0].toLowerCase() + msg.slice(1);\n}\n\nexport function capitalize(msg: string) {\n    return msg[0].toUpperCase() + msg.slice(1);\n}\n\nexport function face_message(face_order: Face[], f_code_2_name?: Map<Face, string>){\n    if (f_code_2_name === undefined) {\n        f_code_2_name = new Map<Face, string>([\n            [Face.n, 'back'],\n            [Face.s, 'front'],\n            [Face.e, 'right'],\n            [Face.w, 'left'],\n            [Face.t, 'top'],\n            [Face.b, 'bottom']\n        ]);\n    }\n\n    if (face_order.length == 1) {\n        return f_code_2_name.get(face_order[0]) + ' face';\n    } else {\n        return face_order.slice(0, -1).map((x) => f_code_2_name.get(x)).join(', ') + ' and ' + f_code_2_name.get(face_order[face_order.length - 1]) + ' faces';\n    }\n}\n\nexport function starts_with(str: string, searchString: string, position?: number){\n    position = position || 0;\n    return str.substr(position, searchString.length) === searchString;\n}\n\nexport function tokens_equal(tks1: string[], tks2: string[]) {\n    if (tks1.length !== tks2.length) {\n        return false;\n    }\n\n    for (let i = 0; i < tks1.length; i++) {\n        if (tks1[i] !== tks2[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nexport function tokenize(s: string): [string[], number[]] {\n    let pat = /[\\S\\0]+/g;\n    \n    let tokens: string[] = [];\n    let token_indexes: number[] = [];\n    \n    let match: RegExpExecArray;\n    while ((match = pat.exec(s)) !== null) {\n        tokens.push(match[0]);\n        token_indexes.push(match.index);\n    }\n\n    return [tokens, token_indexes];\n\n}\n\nexport function untokenize(tokens: string[], token_positions?: number[]){\n    if (token_positions === undefined) {\n        return tokens.join(' ');\n    }\n    \n    let result: string = '';\n\n    for (let i = 0; i < tokens.length; i++){\n        let cur_pos = result.length;\n        let target_pos = token_positions[i];\n        let padding = target_pos - cur_pos;\n        result += ' '.repeat(padding);\n        result += tokens[i];\n    }\n\n    return result;\n}\n\nexport function normalize_whitespace(s: string) {\n    return s.replace(/\\s+/g, ' ');\n}\n\nexport function last(x: any[] | string){\n    return x[x.length - 1];\n}\n\n\n// WEBPACK FOOTER //\n// ./src/typescript/text_tools.ts","import * as React from 'react';\n\n// Internal\nimport {Prompt} from './Prompt';\nimport {ParsedText, OutputText} from './Text';\n\nimport {Item} from \"../typescript/datatypes\";\nimport * as Items from \"../typescript/items\";\n\nimport * as World from \"../typescript/world\";\n\nimport {WorldDriver, MatchValidity} from \"../typescript/commands\";\n\n\n\nconst ContentContainer = function (props) {\n  const {style, children, ...rest} = props;\n  const base_style = {\n    height: '100%',\n    width: '100%',\n    overflowY: 'scroll',\n\n    fontFamily: \"'Fira Mono', 'monospace'\",\n    fontSize: '1em',\n    fontColor: 'ivory',\n    background: 'white',\n    radius: 3,\n    position: 'relative',\n    display: 'flex'\n  };\n  return (\n    <div style={{...base_style, ...style}} {...rest}>\n      {children}\n    </div>\n  );\n}\n\nexport class Terminal extends React.Component<any, {world_driver: WorldDriver<World.SingleBoxWorld>}> {\n  contentContainer: any;\n  prompt: any;\n\n  constructor(props) {\n    super(props);\n    let contents: Item[] = [new Items.Codex(), new Items.Pinecone(), new Items.CityKey()];\n    let world = new World.SingleBoxWorld({box: new World.Box({contents: contents})});\n      \n    this.state = {world_driver: new WorldDriver(world)};\n  }\n\n  componentDidMount() {\n    this.focusPrompt();\n  }\n\n  handleSubmit = () => {\n    //console.log(input);\n    if (this.isCurrentlyValid()) {\n      const output = this.state.world_driver.commit();\n      this.setState({world_driver: this.state.world_driver});\n      this.scrollToPrompt();\n      return true;\n    }\n    return false;\n  }\n\n  isCurrentlyValid = () => {\n    return this.state.world_driver.current_state.parser.validity === MatchValidity.valid;\n  }\n\n  handlePromptChange = (input) => {\n    console.log(input);\n    let result = this.state.world_driver.apply_command(input, false);\n    this.setState({world_driver: this.state.world_driver});\n  }\n\n  currentAutocomplete = () => {\n    let current_state = this.state.world_driver.current_state\n    return current_state.parser.match[current_state.parser.match.length - 1].typeahead;\n  }\n\n  focusPrompt = () => {\n    this.prompt.focus();\n  }\n\n  scrollToPrompt = () => {\n    this.contentContainer.scrollTop = this.contentContainer.scrollHeight;\n  }\n\n  render() {\n    const container_style: any = {\n      height: '100%',\n      width: '100%',\n      overflowY: 'scroll',\n\n      fontFamily: \"'Fira Mono', 'monospace'\",\n      fontSize: '1em',\n      fontColor: 'ivory',\n      background: 'white',\n      radius: 3,\n      position: 'relative',\n      display: 'flex'\n    };\n    return (\n      <div style={container_style} onClick={this.focusPrompt} ref={cc => this.contentContainer = cc}>\n        {this.state.world_driver.history.map(({parser, message}, i) => (\n          <div key={i}>\n            <ParsedText parser={parser} />\n            <OutputText message={message} />\n          </div>\n        ))}\n\n        <Prompt onSubmit={this.handleSubmit} onChange={this.handlePromptChange} ref={p => this.prompt = p}>\n          <ParsedText parser={this.state.world_driver.current_state.parser} />\n        </Prompt>\n      </div>\n    );\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/Terminal.tsx","module.exports = ReactDOM;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"ReactDOM\"\n// module id = 6\n// module chunks = 0","import * as React from 'react';\n\n\nconst Carat = (props) => {\n  const {style, ...rest} = props;\n  const base_style = {\n    fontFamily: \"'Fira Mono', 'monospace'\",\n    fontSize: '1em',\n    fontColor: 'ivory'\n  }\n\n  return (\n    <div style={{...base_style, ...style}} {...rest}>\n      >\n    </div>\n  );\n}\n\nconst InputWrapper = (props) => {\n  const {style, children, ...rest} = props;\n  const base_style = {\n    position: 'relative'\n  };\n  return (\n    <div style={{...base_style, ...style}} {...rest} >\n      {children}\n    </div>\n  );\n}\n\n// //need a class to get ref\n// class Input extends React.Component<any, any> {\n//   render () {\n//     const {style, ...rest} = this.props;\n//     const input_style = {\n//       position: 'absolute',\n//       left: '-16px',\n//       top: 0,\n//       width: 0,\n//       height: 0,\n//       background: 'transparent',\n//       border: 'none',\n//       color: 'transparent',\n//       outline: 'none',\n//       padding: 0,\n//       resize: 'none',\n//       zIndex: -1,\n//       overflow: 'hidden'\n//     };\n\n//     return (\n//       <input style={{...base_style, ...style}} {...rest} />\n//     );\n//   }\n// }\n\nconst InputDisplay = (props) => {\n  const {children, style, ...rest} = props;\n  const base_style = {\n    fontSize: 14,\n    worWrap: 'break-word',\n    lineHeight: '1em',\n    outline: 0,\n    whiteSpace: 'normal',\n    minHeight: '2em',\n    minWidth: '10em',\n    background: '#fff',\n    display: 'inline-block',\n    padding: '.5em 2em .5em 1em',\n    color: 'rgba(0,0,0,.87)',\n    boxShadow: 'none',\n    border: '1px solid rgba(34,36,38,.15)',\n    transition: 'box-shadow .1s ease,width .1s ease',\n    margin: 0,\n    marginBottom: '-2px'\n  };\n\n  return (\n    <span style={{...base_style, ...style}} {...rest}>\n      {children}\n    </span>\n  );\n}\n\nlet keys = {\n  enter: 13,\n};\n\nexport class Prompt extends React.Component<any, any> {\n  input: any;\n\n\n\n  state = { value: '' }; //meta is an object with isValid bool, and autocomplete array\n\n  handleSubmit = () => {\n    let success = this.props.onSubmit();\n    if (success) {\n      this.setState({value: ''});\n    } \n  }\n\n  // when key down is called by auto complete see if we should just submit\n  handleKeys = ({keyCode}) => {\n    if (keyCode === keys.enter) {\n      this.handleSubmit();\n    }\n    this.setCursor(this.input, this.input.value.length);\n  }\n\n  handleChange = () => {\n    const value = this.input.value;\n    this.props.onChange(value)\n    this.setState({value: value});\n  }\n\n  focus = () => {\n    this.input.focus();\n  }\n\n  setCursor = (node,pos) => {\n      node = (typeof node === \"string\") ? document.getElementById(node) : node;\n\n      if(!node){\n          return false;\n      }else if(node.createTextRange){\n          var textRange = node.createTextRange();\n          textRange.collapse(true);\n          textRange.moveEnd(pos);\n          textRange.moveStart(pos);\n          textRange.select();\n          return true;\n      }else if(node.setSelectionRange){\n          node.setSelectionRange(pos,pos);\n          return true;\n      }\n\n      return false;\n  }\n\n  render() {\n    console.log(this.state.value);\n    const input_style: any = {\n      position: 'absolute',\n      left: '-16px',\n      top: 0,\n      width: 0,\n      height: 0,\n      background: 'transparent',\n      border: 'none',\n      color: 'transparent',\n      outline: 'none',\n      padding: 0,\n      resize: 'none',\n      zIndex: -1,\n      overflow: 'hidden'\n    };\n    return (\n        <InputWrapper onClick={() => this.focus()}>\n          <Carat />\n          <input onChange={this.handleChange} onKeyDown={this.handleKeys} value={this.state.value} style={input_style} ref={i => this.input = i} />\n          <InputDisplay>\n            {this.props.children}[]\n          </InputDisplay>\n        </InputWrapper>\n    );\n  }\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/Prompt.tsx","import * as React from 'react';\n\nexport const ParsedText = (props) => {\n  const {parser, style, ...rest} = props;\n  const base_style = {\n    fontFamily: \"'Fira Mono', 'monospace'\",\n    fontSize: '1em',\n    fontColor: 'ivory'\n  }\n\n  return (\n    <div style={{...base_style, ...style}} {...rest}>\n      {parser !== undefined ? parser.command : ''}\n    </div>\n  );\n}\n\nexport const OutputText = (props) => {\n  const {message, style, ...rest} = props;\n  const base_style = {\n    fontFamily: \"'Fira Mono', 'monospace'\",\n    fontSize: '1em',\n    fontColor: 'ivory'\n  }\n\n  return (\n    <div style={{...base_style, ...style}} {...rest}>\n      {message !== undefined ? message : ''}\n    </div>\n  );\n}\n\n\n// WEBPACK FOOTER //\n// ./src/components/Text.tsx","import {\n    array_fuck_contains,\n    Dangle,\n    Direction,\n    Edge,\n    EdgeOperation,\n    Face,\n    faces,\n    FuckDict,\n    Matrix2,\n    make_matrix2,\n    Partition,\n    Point2,\n } from './datatypes';\n\n// import {is, List, Map, Set} from 'immutable';\n\nlet face_vertices = new Map<Face, Matrix2>([\n    [Face.t, make_matrix2([\n        [0,  1,  2 ],\n        [9,  25, 15],\n        [16, 24, 22]])],\n    [Face.b, make_matrix2([\n        [20, 19, 18],\n        [13, 12, 11],\n        [8,  7,  6 ]])],\n    [Face.n, make_matrix2([\n        [2,  1,  0 ],\n        [5,  4,  3 ],\n        [8,  7,  6 ]])],\n    [Face.e, make_matrix2([\n        [22, 15, 2 ],\n        [21, 14, 5 ],\n        [20, 13, 8 ]])],\n    [Face.s, make_matrix2([\n        [16, 24, 22],\n        [17, 23, 21],\n        [18, 19, 20]])],\n    [Face.w, make_matrix2([\n        [0,  9,  16],\n        [3,  10, 17],\n        [6,  11, 18]])]\n]);\n\nlet face_quadrants = new Map<Face, Matrix2>([\n    [Face.t, make_matrix2([\n        [0,  1 ],\n        [2,  3 ]])],\n    [Face.b, make_matrix2([\n        [4,  5 ],\n        [6,  7 ]])],\n    [Face.n, make_matrix2([\n        [8,  9 ],\n        [10, 11]])],\n    [Face.e, make_matrix2([\n        [12, 13],\n        [14, 15]])],\n    [Face.s, make_matrix2([\n        [16, 17],\n        [18, 19]])],\n    [Face.w, make_matrix2([\n        [20, 21],\n        [22, 23]])],\n]);\n\nfunction build_edge_quadrant_mappings(): [Map<number, Edge[]>, FuckDict<Edge, number[]>] {\n    let quadrant_2_edges = new Map<number, Edge[]>();\n    let edge_2_quadrants = new FuckDict<Edge, number[]>();\n\n    for (let f of faces){\n        let vs = face_vertices.get(f);\n        let qs = face_quadrants.get(f);\n        for (let [x, y] of [[0,0], [1,0], [0,1], [1,1]]){\n            let q_edges = get_quadrant_edges(vs, x, y);\n            quadrant_2_edges = quadrant_2_edges.set(qs.get(x, y), q_edges);\n            q_edges.forEach(function (qe) {\n                let q = qs.get(x, y);\n                if (edge_2_quadrants.has_key(qe)) {\n                    edge_2_quadrants.get(qe).push(q);\n                } else {\n                    edge_2_quadrants.set(qe, [q]);\n                }\n            });\n        }\n    }\n\n    return [quadrant_2_edges, edge_2_quadrants];\n}\n\nfunction get_quadrant_edges(m: Matrix2, x: number, y: number): Edge[] {\n    let offsets = [\n        [0,0,0,1],\n        [0,0,1,0],\n        [1,1,0,1],\n        [1,1,1,0]\n    ];\n    let edges: Edge[] = [];\n    for (let [x1, y1, x2, y2] of offsets){\n        let e1 = m.get(x+x1, y+y1);\n        let e2 = m.get(x+x2, y+y2);\n        if (e2 < e1){\n            edges.push(new Edge(e2, e1));\n        } else {\n            edges.push(new Edge(e1, e2));\n        }\n    }\n    return edges;\n}\n\nexport let [quadrant_2_edges, edge_2_quadrants] = build_edge_quadrant_mappings();\n\nfunction get_quadrant_partition(quadrant: number, cut_edges: Edge[]): Partition {\n    let current_partition = new FuckDict<number, undefined>([[quadrant, undefined]]);\n\n    let horizon: Edge[] = quadrant_2_edges.get(quadrant).slice();\n\n    while (horizon.length > 0){\n        let e = horizon.shift();\n        if (array_fuck_contains(cut_edges, e)){\n            continue;\n        }\n        let next_qs = edge_2_quadrants.get(e);\n        let new_qs = next_qs.filter((q) => !current_partition.has_key(q));\n        if (new_qs.length > 0) {\n            new_qs.forEach(function (q){\n                horizon.push(...quadrant_2_edges.get(q));\n                current_partition.set(q, undefined);\n            });\n        }\n    }\n    return current_partition;\n}\n\nfunction range(x: number){\n    let arr: number[] = [];\n    for (let i = 0; i < x; i++){\n         arr.push(i);\n    } \n    return arr;\n}\n\nfunction get_partitions(cut_edges: Edge[]){\n    let partitions: Partition[] = [];\n    let quadrants = range(24);\n    while (quadrants.length > 0){\n        let q = quadrants.shift();\n        let partition = get_quadrant_partition(q, cut_edges);\n        partitions.push(partition);\n        quadrants = quadrants.filter((q) => !partition.has_key(q));\n\n    }\n    return partitions;\n}\n\nexport class FaceMesh {\n    readonly vertices: Matrix2;\n    readonly quadrants: Matrix2;\n\n    constructor(vertices: Matrix2, quadrants: Matrix2){\n        this.vertices = vertices;\n        this.quadrants = quadrants;\n    }\n\n    rotate(degrees: number) {\n        return new FaceMesh(this.vertices.rotate(degrees), this.quadrants.rotate(degrees));\n    }\n}\n\ninterface BoxMeshParams {\n    dimensions?: [number, number, number],\n    face_meshes?: Map<Face, FaceMesh>,\n    cut_edges?: Edge[]\n}\n\nexport class BoxMesh{\n    readonly dimensions: [number, number, number];\n    readonly face_meshes: Map<Face, FaceMesh>;\n    readonly cut_edges: Edge[];\n\n    constructor({dimensions, face_meshes, cut_edges}: BoxMeshParams){\n        this.dimensions = dimensions;\n        \n        if (face_meshes === undefined) {\n            face_meshes = new Map<Face, FaceMesh>();\n            for (let f of faces){\n                face_meshes = face_meshes.set(f,\n                    new FaceMesh(face_vertices.get(f), face_quadrants.get(f)));\n            }\n        }\n        this.face_meshes = face_meshes;\n\n        if (cut_edges === undefined){\n            cut_edges = [];\n        }\n        this.cut_edges = cut_edges;\n    }\n\n    update({dimensions, face_meshes, cut_edges}: BoxMeshParams){\n        if (dimensions === undefined){\n            dimensions = this.dimensions;\n        }\n\n        if (face_meshes === undefined){\n            face_meshes = this.face_meshes;\n        }\n\n        if (cut_edges === undefined){\n            cut_edges = this.cut_edges;\n        }\n        return new BoxMesh({dimensions, face_meshes, cut_edges});\n    }\n\n    cut(face: Face, start: Point2, end: Point2){\n        return this.cut_or_tape(EdgeOperation.cut, face, start, end);\n    }\n\n    tape(face: Face, start: Point2, end: Point2){\n        return this.cut_or_tape(EdgeOperation.tape, face, start, end);\n    }\n\n    cut_or_tape(operation: EdgeOperation, face: Face, start: Point2, end: Point2): BoxMesh {\n        let [x1, y1] = start;\n        let [x2, y2] = end;\n\n        if (Math.abs(x2 - x1) + Math.abs(y2 - y1) != 1){\n            throw `start and end points of cut/tape are not adjacent: ${start} and ${end}`;\n        }\n\n        let f = this.face_meshes.get(face).vertices;\n        let fs = f.get(x1, y1);\n        let fe = f.get(x2, y2);\n\n        let new_edge = new Edge(fs, fe);\n\n        let new_cut_edges = this.cut_edges.slice();\n        if (operation == EdgeOperation.cut && !array_fuck_contains(new_cut_edges, new_edge)) {\n            new_cut_edges.push(new_edge);\n        }\n\n        if (operation == EdgeOperation.tape && array_fuck_contains(new_cut_edges, new_edge)) {\n            new_cut_edges.splice(new_cut_edges.indexOf(new_edge), 1);\n        }\n\n        return this.update({cut_edges: new_cut_edges});\n    }\n\n    get_rends() {\n        return get_partitions(this.cut_edges);\n    }\n\n    get_free_rends() {\n        return this.get_rends().filter(x => !this.is_partition_fixed(x));\n    }\n\n    is_partition_fixed(partition: Partition) {\n        let face_membership = this.get_partition_face_membership(partition);\n        return face_membership.get(Face.b) > 0;\n    }\n\n    get_partition_face_membership(partition: Partition): Map<Face, number> {\n        let face_membership = new Map<Face, number>();\n        for (let f of faces) {\n            let total = 0;\n            let quadrants = this.face_meshes.get(f).quadrants;\n            for (let q of partition.keys_array()){\n                if (quadrants.contains(q)){\n                    total += 1;\n                }\n            }\n            face_membership.set(f, total);\n        }\n        return face_membership;\n    }\n\n    get_quadrant_face(quadrant: number){\n        for (let f of faces){\n            if (this.face_meshes.get(f).quadrants.contains(quadrant)) {\n                return f;\n            }\n        }\n    }\n\n    get_dangles() {\n        let rends = this.get_rends();\n        let fixed_rends = rends.filter(x => this.is_partition_fixed(x));\n\n        let dangles: Dangle[] = [];\n        let inner_this = this;\n\n        this.get_box_edges().forEach(function ([e1, e2]) {\n            let e_2_q_2_f = new FuckDict<Edge, FuckDict<number, Face>>();\n            for (let e of [e1, e2]){ //initialize e_2_q_2_f\n                let inner_map = new FuckDict<number, Face>();\n                edge_2_quadrants.get(e).forEach(function (q) {\n                    inner_map.set(q, inner_this.get_quadrant_face(q));\n                });\n                e_2_q_2_f.set(e, inner_map);\n            }\n\n            let edge_dangles: Dangle[] = [];\n\n            for (let es of [[e1, e2], [e1], [e2]]) {\n\n                let new_cut_edges = inner_this.cut_edges.slice();\n                new_cut_edges.push(...es);\n\n                let new_partitions = get_partitions(new_cut_edges);\n\n                if (new_partitions.length != rends.length) {\n\n                    new_partitions.forEach(function (np) {\n                        if (array_fuck_contains(rends, np)){\n                            return;\n                        }\n\n                        if (inner_this.is_partition_fixed(np)) {\n                            return;\n                        }\n\n                        let any_intersections = false;\n                        fixed_rends.forEach(function (fixed_rend) {\n                            if (np.keys_intersect(fixed_rend).length > 0){\n                                any_intersections = true;\n                            }\n                        });\n                        if (!any_intersections) {\n                            return;\n                        }\n\n                        let any_dangle_matches = false;\n                        edge_dangles.forEach(function (ed) {\n                            if (np.keys_equal(ed.partition)){\n                                any_dangle_matches = true;\n                                return;\n                            }\n                        });\n                        if (any_dangle_matches){\n                            return;\n                        }\n\n                        let q_2_fs: FuckDict<number, Face>[] = [];\n                        for (let e of es) {\n                            q_2_fs.push(e_2_q_2_f.get(e));\n                        }\n\n                        let fixed_fs: Face[] = [];\n                        let dangle_fs: Face[] = [];\n\n                        q_2_fs.forEach(function (q_2_f) {\n                            q_2_f.entries_array().forEach(function ([q, f]) {\n                                if (np.has_key(q)) {\n                                    dangle_fs.push(f);\n                                } else {\n                                    fixed_fs.push(f);\n                                }\n                            });\n                        });\n\n                        if (new Set(fixed_fs).size != 1 || new Set(dangle_fs).size != 1) {\n                            return;\n                        }\n\n                        edge_dangles.push(new Dangle(\n                            np, es, fixed_fs[0], dangle_fs[0]));\n                    });\n                }\n            }\n            dangles.push(...edge_dangles);\n        });\n        dangles = dangles.sort((x, y) => x.partition.size - y.partition.size);\n\n        let final_dangles: Dangle[] = [];\n\n        for (let i = 0; i < dangles.length; i++) {\n            let p = dangles[i].partition;\n\n            let any_supersets = false;\n            dangles.slice(i+1).forEach(function (d) {\n                if (p.keys_subset(d.partition)) {\n                    any_supersets = true;\n                }\n            })\n            if (!any_supersets) {\n                final_dangles.push(dangles[i]);\n            }\n        }\n\n        return final_dangles;\n    }\n\n    get_box_edges(): [Edge, Edge][] {\n        let edges: [Edge, Edge][] = [];\n\n        let t_b_edge_coords: [number, number][][] = [\n            [[0,0], [0,1], [0,2]],\n            [[0,0], [1,0], [2,0]],\n            [[2,0], [2,1], [2,2]],\n            [[0,2], [1,2], [2,2]]\n        ];\n\n        for (let f of [Face.t, Face.b]) {\n            let m = this.face_meshes.get(f).vertices;\n\n            for (let [[p1x, p1y], [p2x, p2y], [p3x, p3y]] of t_b_edge_coords) {\n                let v1 = m.get(p1x, p1y);\n                let v2 = m.get(p2x, p2y);\n                let v3 = m.get(p3x, p3y);\n\n                let e1 = new Edge(v1, v2);\n\n                let e2 = new Edge(v2, v3);\n\n                edges.push([e1, e2]);\n            }\n        }\n\n        for (let f of [Face.n, Face.e, Face.s, Face.w]) {\n            let m = this.face_meshes.get(f).vertices;\n\n            let v1 = m.get(0,0);\n            let v2 = m.get(0,1);\n            let v3 = m.get(0,2);\n\n            let e1 = new Edge(v1, v2);\n\n            let e2 = new Edge(v2, v3);\n\n            edges.push([e1, e2]);\n\n        }\n        return edges;\n    }    \n\n    rotate_y(degrees: number) {\n        //validate degrees somehow\n\n        if (degrees == 0 || degrees == 360) {\n            return this;\n        }\n\n        let new_faces = rotate_y_faces(this.face_meshes, degrees);\n    \n        if (degrees = 180) {\n            return this.update({face_meshes: new_faces});\n        } else {\n            let [x, y, z] = this.dimensions;\n            return this.update({dimensions: [z, y, x], face_meshes: new_faces});\n        }\n    }\n\n    roll(direction: Direction){\n        let [x, y, z] = this.dimensions;\n        let new_x, new_y, new_z;\n        if (direction == Direction.n || direction == Direction.s) {\n            [new_x, new_y, new_z] = [x, y, z];\n        } else {\n            [new_x, new_y, new_z] = [y, x, z];\n        }\n\n        let new_faces = roll_faces(this.face_meshes, direction);\n\n        return this.update({dimensions: [new_x, new_y, new_z], face_meshes: new_faces});\n    }\n\n    description(){\n        let face_descr = new Map<Face, string>([\n            [Face.t, 'top'],\n            [Face.b, 'bottom'],\n            [Face.n, 'back'],\n            [Face.e, 'right'],\n            [Face.s, 'front'],\n            [Face.w, 'left']\n        ]);\n\n        let [x, y, z] = this.dimensions;\n\n        let result = `The box's dimensions measure ${x} by ${y} by ${z}`;\n\n        let rends = this.get_free_rends();\n        let inner_this = this;\n\n        rends.forEach(function (fr) {\n            let face_membership = inner_this.get_partition_face_membership(fr);\n            let faces_present: Face[] =[];\n            for (let f of faces){\n                if (face_membership.get(f) > 0) {\n                    faces_present.push(f);\n                }\n            }\n\n            let faces_text: string;\n            if (faces_present.length == 1) {\n                faces_text = face_descr.get(faces_present[0]) + ' face';\n            } else {\n                faces_text = faces_present.slice(0, -1).map(f => face_descr.get(f)).join(', ');\n                faces_text += ` and ${face_descr.get(faces_present[faces_present.length-1])} faces`;\n            }\n\n            result += `\\nA portion of the box's ${faces_text} has been rended free; it lies on the floor off to the side.`;\n        });\n\n        let dangles = this.get_dangles();\n\n        dangles.forEach(function (d) {\n            let face_membership = inner_this.get_partition_face_membership(d.partition);\n            let faces_present: Face[] = [];\n            for (let f of faces){\n                if (face_membership.get(f) > 0) {\n                    faces_present.push(f);\n                }\n            }\n\n            let faces_text: string;\n            if (faces_present.length == 1) {\n                faces_text = face_descr.get(faces_present[0]) + ' face';\n            } else {\n                faces_text = faces_present.slice(0, -1).map(f => face_descr.get(f)).join(', ');\n                faces_text += ` and ${face_descr.get(faces_present[faces_present.length-1])} faces`;\n            }\n\n            result += `\\nA portion of the box's ${faces_text} sits on a free hinge; from the ${face_descr.get(d.free_face)} face it can be swung to the ${face_descr.get(d.fixed_face)}.`;\n        });\n\n        return result;\n    }\n}\n\nfunction rotate_y_faces(fs: Map<Face, FaceMesh>, degrees: number) {\n    if (degrees == 0 || degrees == 360) {\n        return fs;\n    }\n\n    let shift = degrees / 90;\n    let face_cycle = [Face.n, Face.w, Face.s, Face.e, Face.n, Face.w, Face.s, Face.e];\n\n    let new_faces = new Map<Face, FaceMesh>();\n\n    for (let f of [Face.n, Face.e, Face.s, Face.w]){\n        let ind = face_cycle.indexOf(f);\n        new_faces.set(f, fs.get(face_cycle[ind + shift]));\n    }\n\n    for (let f of [Face.t, Face.b]){\n        new_faces.set(f, fs.get(f).rotate(degrees));\n    }\n\n    return new_faces;\n}\n\nfunction roll_faces(fs: Map<Face, FaceMesh>, direction: Direction){\n    let new_faces = new Map<Face, FaceMesh>()\n\n    if (direction == Direction.n) {\n        new_faces.set(\n            Face.n, fs.get(Face.t).rotate(180)).set(\n            Face.t, fs.get(Face.s)).set(\n            Face.s, fs.get(Face.b)).set(\n            Face.b, fs.get(Face.n).rotate(180)).set(\n            Face.e, fs.get(Face.e).rotate(90)).set(\n            Face.w, fs.get(Face.w).rotate(270));\n    } else if (direction == Direction.s) {\n        new_faces.set(\n            Face.s, fs.get(Face.t)).set(\n            Face.t, fs.get(Face.n).rotate(180)).set(\n            Face.n, fs.get(Face.b)).set(\n            Face.b, fs.get(Face.s).rotate(180)).set(\n            Face.e, fs.get(Face.e).rotate(270)).set(\n            Face.w, fs.get(Face.w).rotate(90));\n    } else if (direction == Direction.e) {\n        new_faces.set(\n            Face.e, fs.get(Face.t).rotate(90)).set(\n            Face.t, fs.get(Face.w).rotate(90)).set(\n            Face.w, fs.get(Face.b).rotate(270)).set(\n            Face.b, fs.get(Face.e).rotate(270)).set(\n            Face.n, fs.get(Face.n).rotate(270)).set(\n            Face.s, fs.get(Face.s).rotate(90));\n    } else if (direction == Direction.w) {\n        new_faces.set(\n            Face.w, fs.get(Face.t).rotate(270)).set(\n            Face.t, fs.get(Face.e).rotate(270)).set(\n            Face.e, fs.get(Face.b).rotate(90)).set(\n            Face.b, fs.get(Face.w).rotate(90)).set(\n            Face.n, fs.get(Face.n).rotate(90)).set(\n            Face.s, fs.get(Face.s).rotate(270));\n    }\n\n    return new_faces;\n}\n\n\nexport function test(){\n    let bm = new BoxMesh({dimensions: [2,3,4]});\n\n    let bm2 = bm.cut(Face.t, [0,0], [1,0]).cut(Face.t, [1,0], [1,1]).cut(Face.t, [1,1], [0,1]).cut(Face.t, [0,1], [0,0]);\n    let bm3 = bm2.cut(Face.t, [0,1], [0,2]).cut(Face.s, [0, 0], [0, 1]).cut(Face.s, [0,1], [1,1]).cut(Face.s, [1,1], [1,0]).cut(Face.t, [1, 2], [1,1])\n\n    let bm4 = bm.cut(Face.t, [0,0], [1,0]).roll(Direction.s).cut(Face.t, [0,2], [0,1]).cut(Face.t, [0,1], [1,1]).cut(Face.t, [1,1], [1,2]);\n\n    let bm5 = bm.cut(Face.n, [0,0], [1,0]).cut(Face.n, [1,0], [2,0]).cut(Face.n, [2,0], [2,1]).cut(Face.n, [2,1], [1,1]).cut(Face.n, [1,1], [0,1]).cut(Face.n, [1,1], [1, 0]).cut(Face.n, [0,1], [0,0]);\n\n    let bm6 = bm.cut(Face.t, [0,0], [0,1]).cut(Face.t, [0,1], [1,1]).cut(Face.t, [1,1], [1,0]);\n    let bm7 = bm2.cut(Face.t, [0,1], [0,2]).cut(Face.t, [1,1], [1,2]);\n\n    let bm8 = (bm.cut(Face.t, [0,0], [1,0]).cut(Face.t, [1,0], [2,0]).cut(Face.t, [2,0], [2,1]).cut(Face.t, [2,1], [2,2])\n             .cut(Face.t, [0,2], [0,1]).cut(Face.t, [0,1], [1,1]).cut(Face.t, [1,1], [1,2])\n             .cut(Face.s, [1,0], [1,1]).cut(Face.s, [1,1], [0,1])\n             .cut(Face.w, [0,0], [0,1]).cut(Face.w, [0,1], [1,1]).cut(Face.w, [1,1], [2,1]));\n\n    let bms: BoxMesh[] = [bm, bm2, bm3, bm4, bm5, bm6, bm7, bm8];\n    for (let i = 0; i < bms.length; i++) {\n        let b = bms[i];\n\n        console.log('Box #', i+1);\n        console.log();\n        console.log(b.description());\n        console.log();\n        console.log();\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/typescript/box_geometry.ts","import * as React from \"react\";\nimport * as ReactDom from \"react-dom\";\n\nimport {Terminal} from \"../components/Terminal\";\n\nReactDom.render(<Terminal />, document.getElementById('game'));\n\n// import {List, Map} from 'immutable';\n// import {CityKey, Codex, Pinecone} from './items';\n// import {Item} from './datatypes';\n// import {Box, SingleBoxWorld} from './world';\n// import {MatchValidity, DisplayElt, DisplayEltType, WorldDriver, CommandParser, CommandResult} from './commands';\n// import {last, tokenize} from './text_tools';\n\n\n// declare var jQuery: any;\n\n// // previous command handler func (first arg to .terminal() )\n// // function(command: string) {\n// //         if (command !== '') {\n// //             try {\n// //                 //hold on to parser object\n// //                 //highlight matched bits of command\n// //                 //offer autocomplete solutions\n// //                 let result = world_driver.run(command);\n// //                 if (result !== undefined) {\n// //                     this.echo(new String(result));\n// //                 }\n// //             } catch(e) {\n// //                 this.error(new String(e));\n// //             }\n// //         } else {\n// //            this.echo('');\n// //         }\n// //     }\n\n// export let elt_color = Map<DisplayEltType, string>().asMutable();\n// elt_color.set(DisplayEltType.keyword, 'white');\n// elt_color.set(DisplayEltType.option, 'blue');\n// elt_color.set(DisplayEltType.filler, 'gray');\n// elt_color.set(DisplayEltType.partial, 'gray');\n// elt_color.set(DisplayEltType.error, 'red');\n\n// setTimeout(function () {\n//     jQuery(function($: any) {\n//         let contents = List<Item>([new Codex(), new Pinecone(), new CityKey()]);\n//         let world = new SingleBoxWorld({box: new Box({contents: contents})});\n//         let world_driver = new WorldDriver(world);\n//         let current_result = world_driver.current_state;\n//         var ul: any;\n//         function format_command(command: string) {\n//             // TODO: don't apply to non-command strings\n//             if ($.terminal.have_formatting(command)){\n//                 return command;\n//             }\n//             command = command.replace(/(\\s|&nbsp;)/g, ' ');\n//             let result = world_driver.run(command, false);\n//             let pos = 0;\n//             let parser = result.parser;\n//             let valid_fmt = '';\n//             if (parser.validity === MatchValidity.valid){\n//                 valid_fmt = 'b';\n//             }\n\n//             let formatted = '';\n//             for (let elt of parser.match) {\n//                 if (elt.match.length > 0){\n//                     formatted += `[[${valid_fmt};${elt_color.get(elt.display)};]${elt.match}]`;\n//                     pos += elt.match.length;\n//                 }\n//                 while (true){\n//                     //eat the spaces\n//                     let c = command.charAt(pos);\n//                     if (c.match(' ') !== null){\n//                         formatted += c;\n//                         pos += 1;\n//                     } else {\n//                         break;\n//                     }\n//                 }\n//             }\n//             return formatted;\n//         }\n//         // $.terminal.defaults.formatters.push(format_command)\n\n//         function format_command_with_prompt(command:string){\n//             let naked_command = command.slice(2);\n//             return '> ' + format_command(naked_command);\n//         }\n\n//         function update_typeahead(terminal: any) {\n//             // TODO: distinguish enabled & disabled typeahead\n//             let command = terminal.get_command();\n//             ul.empty();\n//             let result = world_driver.run(command, false);\n//             let parser = result.parser;\n\n//             if (parser.validity === MatchValidity.partial){\n//                 let m = last(parser.match);\n//                 ul.hide();\n//                 let com_end = last(command);\n\n//                 if (m.match.length === 0 && com_end !== undefined && com_end.match(/(\\s|&nbsp;)/) === null){\n//                     return;\n//                 }\n//                 for (let t of m.typeahead){\n//                     $('<li>' + t + '</li>').appendTo(ul);\n//                 }\n//                 ul.show();\n//             }\n//         }\n\n//         function exec_command(command: string, terminal: any) {\n//             let result = world_driver.run(command, true);\n//             let parser = result.parser;\n            \n//             $.terminal.defaults.formatters.pop()\n//             $.terminal.defaults.formatters.push(format_command_with_prompt);\n//             terminal.echo('> ' + command);\n//             $.terminal.defaults.formatters.pop();\n\n//             if (result.message !== undefined){\n//                 terminal.echo(result.message);\n//                 terminal.echo(' ');\n//             }\n//             $.terminal.defaults.formatters.push(format_command);\n//         }\n\n//         function handle_keydown(e: any, terminal: any) {\n//             setTimeout(function () {\n//                 let command = terminal.get_command();\n                \n//             })\n//         }\n\n//         $('#term').terminal(exec_command, {\n//             greetings: '[[;white;]Demo Parser Interface for The Wreck]',\n//             name: 'wreck_demo',\n//             height: 500,\n//             //prompt: '> ',\n//             onInit: function(term: any) {\n//                 var wrapper = term.cmd().find('.cursor').wrap('<span/>').parent()\n//                     .addClass('cmd-wrapper');\n//                 ul = $('<ul></ul>').appendTo(wrapper);\n//                 ul.on('click', 'li', function() {\n//                     let txt = $(this).text();\n//                     let cur_word = term.before_cursor(true);\n//                     term.insert(txt.replace(cur_word, '') + ' ');\n//                     ul.empty();\n//                     setTimeout(function () {update_typeahead(term);}, 0);\n//                 });\n//                 setTimeout(function () {update_typeahead(term);}, 0);\n//             },\n//             keydown: function(e: any, terminal: any) {\n//                 // setTimeout because terminal is adding characters in keypress\n//                 // we use keydown because we need to prevent default action for\n//                 // tab and still execute custom code\n//                 setTimeout(function() {\n//                     update_typeahead(terminal);\n//                 }, 0);\n//             },\n//             onBlur: function() {\n//                 return false;\n//             },\n//             memory: true,\n//             echoCommand: false,\n//             wordAutocomplete: true\n//         });\n//     });\n// }, 0);\n\n\n// WEBPACK FOOTER //\n// ./src/typescript/main.tsx","import {BoxMesh, edge_2_quadrants, FaceMesh} from './box_geometry';\n\nimport {\n    array_fuck_contains,\n    CardboardEdge,\n    CommandError,\n    Counter,\n    counter_order,\n    counter_update,\n    Dangle,\n    Direction,\n    directions,\n    direction_2_face,\n    Edge,\n    EdgeDirection,\n    EdgeOperation,\n    EdgeState,\n    Face,\n    FuckDict,\n    Item,\n    Partition,\n    Point2,\n    RelativePosition,\n    RendOperation,\n    RendState,\n    SpillageLevel,\n    TapeEdge,\n    Weight,\n    WorldUpdateError\n} from './datatypes';\n\nimport {\n    DangleOpWord, dangle_op_word_tokens,\n    EdgeDirWord, edge_dir_word_tokens,\n    EdgeOpWord, edge_op_word_tokens,\n    FaceWord, face_word_tokens,\n    PositionWord, position_word_tokens,\n    RendOpWord, rend_op_word_tokens,\n    RollDirWord, roll_dir_word_tokens,\n    RotateYDirWord, rotate_y_word_tokens,\n    Token,\n    word_2_degrees,\n    word_2_dir,\n    word_2_edge_dir,\n    word_2_edge_op,\n    word_2_face,\n    word_2_relative_position,\n    word_2_rend_op,\n    word_2_dangle_op,\n    CommandResult,\n    CommandParser,\n    Command,\n    DisplayElt,\n    DisplayEltType,\n    MatchValidity,\n    WorldType,\n    WorldDriver\n} from './commands'\n\nimport {WorldUpdateEffects, with_world_update, world_update} from './world_update_effects';\n\nimport {CityKey, Codex, Pinecone} from './items';\n\nimport {capitalize, face_message, uncapitalize, tokens_equal, tokenize, untokenize} from './text_tools';\n\n//import {List, Map, Set} from 'immutable';\n\nexport interface BoxParams {\n    box_mesh?: BoxMesh,\n    rend_state?: FuckDict<Partition, RendState>,\n    dangle_state?: FuckDict<Dangle, RendState>,\n    edge_state?: FuckDict<Edge, EdgeState>,\n    contents?: Item[]\n}\n\nexport class Box {\n    readonly box_mesh: BoxMesh;\n    readonly rend_state: FuckDict<Partition, RendState>;\n    readonly dangle_state: FuckDict<Dangle, RendState>;\n    readonly edge_state: FuckDict<Edge, EdgeState>;\n    readonly contents: Item[];\n\n    constructor({box_mesh, rend_state, dangle_state, edge_state, contents}: BoxParams){\n        if (box_mesh === undefined) {\n            box_mesh = new BoxMesh({dimensions: [2, 2, 2]});\n        }\n        this.box_mesh = box_mesh;\n\n        if (rend_state === undefined) {\n            rend_state = this.default_rend_state(this.box_mesh);\n        }\n        this.rend_state = rend_state;\n\n        if (dangle_state === undefined) {\n            dangle_state = this.default_dangle_state(this.box_mesh);\n        }\n        this.dangle_state = dangle_state;\n\n        if (edge_state === undefined) {\n            edge_state = new FuckDict<Edge, EdgeState>();\n        }\n        this.edge_state = edge_state;\n\n        if (contents === undefined) {\n            contents = [];\n        }\n        this.contents = contents;\n    }\n\n    update({box_mesh, rend_state, dangle_state, edge_state, contents}: BoxParams){\n        if (box_mesh === undefined) {\n            box_mesh = this.box_mesh;\n        }\n\n        if (rend_state === undefined) {\n            rend_state = this.rend_state;\n        }\n\n        if (dangle_state === undefined) {\n            dangle_state = this.dangle_state;\n        }\n\n        if (edge_state === undefined) {\n            edge_state = this.edge_state;\n        }\n        \n        if (contents === undefined) {\n            contents = this.contents;\n        }\n\n        return new Box({box_mesh, rend_state, dangle_state, edge_state, contents});\n    }\n\n    default_rend_state(box_mesh: BoxMesh) {\n        let rends = box_mesh.get_free_rends();\n        let result = new FuckDict<Partition, RendState>();\n        rends.forEach(function (r) {\n            result.set(r, RendState.closed);\n        });\n        return result;\n    }\n\n    default_dangle_state(box_mesh: BoxMesh) {\n        let dangles = box_mesh.get_dangles();\n        let result = new FuckDict<Dangle, RendState>();\n        dangles.forEach(function (d) {\n            result.set(d, RendState.closed);\n        });\n        return result;\n    }\n\n    open_or_close_rend(operation: RendOperation, rend: Partition) {\n        let box_rends = this.box_mesh.get_rends();\n\n        if (!array_fuck_contains(box_rends, rend)){\n            throw new CommandError('rend does not exist on the box');\n        }\n\n        if (this.box_mesh.is_partition_fixed(rend)) {\n            throw new WorldUpdateError('cannot open or close a fixed rend');\n        }\n\n        let new_rend_state = this.rend_state.copy();\n        let intended_new_state = operation == RendOperation.close ? RendState.closed : RendState.open;\n        if (intended_new_state == new_rend_state.get(rend)) {\n            throw new WorldUpdateError(`cannot ${RendOperation[operation]} a rend that is already ${RendState[intended_new_state]}`);\n        }\n\n        new_rend_state.set(rend, intended_new_state);\n\n        let new_box = this.update({rend_state: new_rend_state});\n\n        if (new_box.is_collapsed()) {\n            let effects = world_update.effects;\n            effects.box_collapsed = true;\n            effects.collapse_spilled_items.push(...new_box.contents);\n            let new_contents: Item[] = [];\n            new_box = new_box.update({contents: new_contents});\n        }\n\n        return new_box;\n    }\n\n    open_or_close_dangle(operation: RendOperation, dangle: Dangle) {\n        if (this.box_mesh.is_partition_fixed(dangle.partition)) {\n            throw new WorldUpdateError('cannot open or close a fixed dangle');\n        }\n\n        let box_dangles = this.box_mesh.get_dangles();\n\n        if (box_dangles.some((d) => dangle == d)){\n            throw new CommandError('dangle does not exist on the box');\n        }\n\n        let intended_new_state = operation == RendOperation.close ? RendState.closed : RendState.open;\n        if (this.dangle_state.get(dangle) == intended_new_state) {\n            throw new WorldUpdateError(`cannot ${RendOperation[operation]} a dangle that is already ${RendState[intended_new_state]}`);\n        }\n\n        let new_dangle_state = this.dangle_state.copy();\n        new_dangle_state.set(dangle, intended_new_state);\n\n        let new_box = this.update({dangle_state: new_dangle_state});\n        if (new_box.is_collapsed()) {\n            let effects = world_update.effects;\n            effects.box_collapsed = true;\n            effects.collapse_spilled_items.push(...new_box.contents);\n            let new_contents: Item[] = [];\n            new_box = new_box.update({contents: new_contents});\n        }\n        return new_box;\n    }\n\n    rotate_y(degrees: number) {\n        let new_box_mesh = this.box_mesh.rotate_y(degrees);\n        return this.update({box_mesh: new_box_mesh});\n    }\n\n    roll(direction: Direction) {\n        if (this.dangle_state.values_array().some((state) => state == RendState.open)) {\n            throw new WorldUpdateError('cannot roll a box with open dangles');\n        }\n\n        let new_box_mesh = this.box_mesh.roll(direction);\n        let dir_face: Face = direction_2_face.get(direction);\n\n        let new_contents = this.contents.slice();\n        let rend_state_updates = this.rend_state.copy();\n        let dangle_state_updates = this.dangle_state.copy();\n\n        let inner_this = this;\n        let effects = world_update.effects;\n\n        if (new_contents.length > 0){\n            let dir_2_opposite = new Map<Face, Face>([\n                [Face.n, Face.s],\n                [Face.s, Face.n],\n                [Face.e, Face.w],\n                [Face.w, Face.e]]);\n \n            let heavy_spill_faces: [Face, Face][] = [\n                [dir_face, Face.b],\n                [Face.t, dir_face],\n                [Face.b, dir_2_opposite.get(dir_face)]];\n            let light_spill_faces = ([Face.n, Face.s, Face.e, Face.w]\n                .filter((d) => d !== dir_face && d !== dir_2_opposite.get(dir_face))\n            );\n                \n            this.rend_state.entries_array().forEach(function ([r, state]) {\n                let face_membership = inner_this.box_mesh.get_partition_face_membership(r);\n                        \n                for (let [test_face, spill_face] of heavy_spill_faces) {\n                    if (face_membership.get(test_face) > 0) {\n                        effects.spill_faces.push(spill_face);\n                        effects.spillage_level = SpillageLevel.heavy;\n                        effects.spilled_items.push(...new_contents);\n                        new_contents = [];\n\n                        if (state == RendState.closed) {\n                            effects.spilled_rends == effects.spilled_rends.set(r, undefined);\n                            rend_state_updates.set(r, RendState.open);\n                        }\n\n                    }\n                }\n\n                for (let spill_face of light_spill_faces) {\n                    if (face_membership.get(spill_face) > 0) {\n                        effects.spill_faces.push(spill_face);\n                        if (effects.spillage_level < SpillageLevel.light) {\n                            effects.spillage_level = SpillageLevel.light;\n                        }\n                        if (new_contents.length > 0) {\n                            effects.spilled_items.push(new_contents.shift());\n                        }\n                    }\n                }\n            });\n\n            this.box_mesh.get_dangles().forEach(function (d) {\n                let spillage_level = SpillageLevel.none;\n                let spill_face: Face;\n                if (d.free_face == Face.t) {\n                    spillage_level = SpillageLevel.heavy;\n                    spill_face = dir_face;\n                } else if (d.free_face == dir_face) {\n                    spillage_level = SpillageLevel.heavy;\n                    spill_face = Face.b;\n                } else if (light_spill_faces.indexOf(d.free_face) !== -1) {\n                    spillage_level = SpillageLevel.light;\n                    spill_face = d.free_face;\n                }\n\n                if (spillage_level !== SpillageLevel.none) {\n                    if (spillage_level > effects.spillage_level) {\n                        effects.spillage_level = spillage_level;\n                    }\n                    effects.spill_faces.push(spill_face);\n\n                    if (spillage_level == SpillageLevel.light) {\n                        if (new_contents.length > 0) {\n                            effects.spilled_items.push(new_contents.shift());\n                        }\n                    } else if (spillage_level == SpillageLevel.heavy) {\n                        effects.spilled_items.push(...new_contents);\n                        new_contents = [];\n                    }\n\n                    effects.spilled_dangles.set(d, undefined);\n                    dangle_state_updates.set(d, RendState.open);\n                }\n            });\n            \n            new_box_mesh.get_dangles().forEach(function (d) {\n                if (d.free_face == dir_2_opposite.get(dir_face)) {\n                    effects.spillage_level = SpillageLevel.heavy;\n                    effects.spill_faces.push(dir_2_opposite.get(dir_face));\n\n                    effects.spilled_items.push(...new_contents);\n                    new_contents = [];\n\n                    effects.spilled_dangles.set(d, undefined);\n                    dangle_state_updates.set(d, RendState.open);\n                }\n            });\n        }\n        let new_box = this.update({\n            box_mesh: new_box_mesh,\n            rend_state: rend_state_updates,\n            dangle_state: dangle_state_updates,\n            contents: new_contents\n        });\n\n        if (new_box.is_collapsed()) {\n            effects.box_collapsed = true;\n            effects.collapse_spilled_items.push(...new_contents);\n            new_contents = [];\n            new_box = new_box.update({contents: new_contents});\n        }\n\n        return new_box;\n    }\n\n    lift() {\n        let effects = world_update.effects;\n        let inner_this = this;\n\n        let new_contents = this.contents.slice();\n        let new_rend_state = this.rend_state.copy();\n        let new_dangle_state = this.dangle_state.copy();\n\n        if (new_contents.length > 0) {\n            let test_box_mesh = this.box_mesh.roll(Direction.s).roll(Direction.s);\n\n            test_box_mesh.get_free_rends().forEach(function (r) {\n                let face_membership = test_box_mesh.get_partition_face_membership(r);\n                let test_faces = [Face.b, Face.n, Face.s, Face.e, Face.w];\n                let count = test_faces.map((x) => face_membership.get(x)).reduce((x, y) => x + y);\n                if (face_membership.get(Face.t) > count) {\n                    effects.spillage_level = SpillageLevel.heavy;\n                    effects.spill_faces.push(Face.b);\n\n                    effects.spilled_items.push(...new_contents);\n                    new_contents = [];\n\n                    if (!new_rend_state.has_key(r) || new_rend_state.get(r) === RendState.closed) {\n                        effects.spilled_rends.set(r, undefined);\n                        new_rend_state.set(r, RendState.open);\n                    }\n                }\n            });\n\n            test_box_mesh.get_dangles().forEach(function (d) {\n                if (d.free_face == Face.t) {\n                    effects.spillage_level = SpillageLevel.heavy;\n                    effects.spill_faces.push(Face.b);\n\n                    effects.spilled_items.push(...new_contents);\n                    new_contents = [];\n\n                    effects.spilled_dangles.set(d, undefined);\n                    new_dangle_state.set(d, RendState.open);\n                }\n            });\n\n            this.rend_state.entries_array().forEach(function ([r, state]) {\n                let face_membership = inner_this.box_mesh.get_partition_face_membership(r);\n                let light_spill_faces = [Face.n, Face.s, Face.e, Face.w].filter((f) => face_membership.get(f) > 0);\n                if (light_spill_faces.length > 0) {\n                    if (effects.spillage_level < SpillageLevel.light) {\n                        effects.spillage_level = SpillageLevel.light;\n                    }\n                    effects.spill_faces.push(...light_spill_faces);\n\n                    if (new_contents.length > 0) {\n                        effects.spilled_items.push(new_contents.shift());\n                    }\n                    if (state == RendState.closed) {\n                        effects.spilled_rends.set(r, undefined);\n                        new_rend_state.set(r, RendState.open);\n                    }\n                }\n            });\n\n            this.dangle_state.entries_array().forEach(function ([d, state]) {\n                if ([Face.n, Face.s, Face.e, Face.w].indexOf(d.free_face) !== -1) {\n                    if (effects.spillage_level < SpillageLevel.light) {\n                        effects.spillage_level = SpillageLevel.light;\n                    }\n                    effects.spill_faces.push(d.free_face);\n\n                    if (new_contents.length > 0) {\n                        effects.spilled_items.push(new_contents.shift());\n                    }\n                }\n            });\n        }\n\n        let new_box = this.update({rend_state: new_rend_state, dangle_state: new_dangle_state, contents: new_contents});\n\n        if (new_box.is_collapsed()) {\n            effects.box_collapsed = true;\n            effects.collapse_spilled_items.push(...new_contents);\n            new_contents = [];\n            new_box = new_box.update({contents: new_contents});\n        }\n\n        return new_box;\n    }\n\n    cut(face: Face, start: Point2, end: Point2) {\n        return this.cut_or_tape(EdgeOperation.cut, face, start, end);\n    }\n\n    tape(face: Face, start: Point2, end: Point2) {\n        return this.cut_or_tape(EdgeOperation.tape, face, start, end);\n    }\n\n    cut_or_tape(operation: EdgeOperation, face: Face, start: Point2, end: Point2) {\n        let effects = world_update.effects;\n        let inner_this = this;\n\n        if (face !== Face.s && face !== Face.t) {\n            throw new WorldUpdateError('cannot cut or tape sides other than top or front');\n        }\n\n        let [x1, y1] = start;\n        let [x2, y2] = end;\n        let v1 = this.box_mesh.face_meshes.get(face).vertices.get(x1, y1);\n        let v2 = this.box_mesh.face_meshes.get(face).vertices.get(x2, y2);\n\n        let edge = new Edge(v1, v2);\n\n        let quadrants = edge_2_quadrants.get(edge);\n\n        this.rend_state.entries_array().forEach(function ([r, state]) {\n            if (state == RendState.open && quadrants.every(r.has_key)) {\n                throw new WorldUpdateError('cannot cut or tape on an open rend');\n            }\n        });\n\n        this.dangle_state.entries_array().forEach(function ([d, state]) {\n            if (state == RendState.open && quadrants.every(d.partition.has_key)) {\n                throw new WorldUpdateError('cannot cut or tape on an open dangle');\n            }\n        });\n\n        let new_box_mesh: BoxMesh;\n        if (operation == EdgeOperation.cut) {\n            new_box_mesh = this.box_mesh.cut(face, start, end);\n        } else {\n            new_box_mesh = this.box_mesh.tape(face, start, end);\n        }\n\n        let new_rend_state = this.default_rend_state(new_box_mesh);\n        this.rend_state.entries_array().forEach(function ([r, state]) {\n            if (new_rend_state.has_key(r)) {\n                new_rend_state.set(r, state);\n            } else {\n                effects.repaired_rends.push(r);\n            }\n        });\n\n        new_rend_state.entries_array().forEach(function ([new_r, state]) {\n            if (!inner_this.rend_state.has_key(new_r)) {\n                effects.new_rends.push(new_r);\n            }\n        });\n\n        let new_dangle_state = this.default_dangle_state(new_box_mesh);\n        this.dangle_state.entries_array().forEach(function ([d, state]) {\n            if (new_dangle_state.has_key(d)) {\n                new_dangle_state.set(d, state);\n            } else {\n                effects.repaired_dangles.push(d);\n            }\n        });\n\n        new_dangle_state.entries_array().forEach(function ([new_d, state]) {\n            if (!inner_this.dangle_state.has_key(new_d)) {\n                effects.new_dangles.push(new_d);\n            }\n        });\n\n        let new_edge_state = this.edge_state.copy();\n        \n        let new_state: EdgeState;\n        if (new_edge_state.has_key(edge)) {\n            new_state = new_edge_state.get(edge);\n        } else {\n            new_state = new EdgeState()\n        }\n\n        if (operation == EdgeOperation.cut) {   \n            new_edge_state.set(edge, new_state.cut());\n        } else {\n\n            new_edge_state.set(edge, new_state.apply_tape());\n        }\n\n        return this.update({box_mesh: new_box_mesh, rend_state: new_rend_state, dangle_state: new_dangle_state, edge_state: new_edge_state});\n    }\n\n    take_next_item() {\n        let effects = world_update.effects;\n\n        if (this.contents.length == 0) {\n            throw new WorldUpdateError('cannot take an item from an empty box');\n        }\n\n        if (!this.appears_open()) {\n            throw new WorldUpdateError('cannot take an item from a box with no visible openings');\n        }\n\n        let new_contents = this.contents.slice();\n        effects.taken_items.push(new_contents.shift());\n\n        return this.update({contents: new_contents});\n    }\n\n    next_item() {\n        if (this.contents.length == 0) {\n            return null;\n        }\n        return this.contents[0];\n    }\n\n    appears_open() {\n        if (this.rend_state.values_array().some((state) => state == RendState.open)) {\n            return true;\n        }\n        if (this.dangle_state.values_array().some((state) => state == RendState.open)) {\n            return true;\n        }\n        return false;\n    }\n\n    appears_empty() {\n        return this.appears_open() && this.contents.length == 0;\n    }\n\n    is_collapsed(){\n        let open_faces = new Map<Face, number>();\n        let inner_this = this;\n        \n        this.rend_state.entries_array().forEach(function ([r, state]) {\n            if (state == RendState.open){\n                let face_membership = inner_this.box_mesh.get_partition_face_membership(r);\n                counter_update(open_faces, face_membership);\n            }\n        });\n\n        this.dangle_state.entries_array().forEach(function ([d, state]) {\n            if (state == RendState.open){\n                let face_membership = inner_this.box_mesh.get_partition_face_membership(d.partition);\n                counter_update(open_faces, face_membership);\n            }\n        });\n\n        let total_open_sides = 0;\n        open_faces.forEach(function (count, face) {\n            if (count > 0) {\n                total_open_sides += 1;\n            }\n        });\n\n        return total_open_sides >= 3;\n    }\n}\n\nexport interface SingleBoxWorldParams {\n    box?: Box,\n    taken_items?: Item[],\n    spilled_items?: Item[]\n}\n\nexport class SingleBoxWorld implements WorldType{\n    readonly box: Box;\n    readonly taken_items: Item[];\n    readonly spilled_items: Item[];\n\n    constructor({box, taken_items, spilled_items}: SingleBoxWorldParams) {\n        if (box === undefined) {\n            box = new Box({});\n        }\n        this.box = box;\n\n        if (taken_items === undefined) {\n            taken_items = [];\n        }\n        this.taken_items = taken_items;\n\n        if (spilled_items === undefined) {\n            spilled_items = [];\n        }\n        this.spilled_items = spilled_items;\n    }\n\n    update({box, taken_items, spilled_items}: SingleBoxWorldParams) {\n        if (box === undefined) {\n            box = this.box;\n        }\n\n        if (taken_items === undefined) {\n            taken_items = this.taken_items;\n        }\n\n        if (spilled_items === undefined) {\n            spilled_items = this.spilled_items;\n        }\n\n        return new SingleBoxWorld({box, taken_items, spilled_items});\n    }\n\n    get_command_map(): Map<string, Command<this>> {\n        let commands: Command<SingleBoxWorld>[] = [];\n        commands.push(rotate_y_box);\n        commands.push(roll_box);\n        commands.push(lift_box);\n        commands.push(cut_box);\n        commands.push(tape_box);\n        commands.push(open_dangle);\n        commands.push(close_dangle);\n        commands.push(remove_rend);\n        commands.push(replace_rend);\n        commands.push(take_item);\n\n        let command_map = new Map<string, Command<this>>();\n        let options: Token[][] = [];\n\n        for (let command of commands) {\n            options.push(command.command_name);\n            command_map.set(untokenize(command.command_name), <Command<this>>command);\n        }\n        \n        return command_map;\n    }\n\n    cut_message(new_box: Box, cut_edge_states: EdgeState[], effects: WorldUpdateEffects) {\n        let cut_message: string;\n        if (cut_edge_states[0].cardboard == CardboardEdge.intact) {\n            cut_message = 'You slide your blade along the cardboard';\n            if (cut_edge_states[0].tape == TapeEdge.taped) {\n                cut_message += ' and tape';\n            }\n            cut_message += '.';\n        } else {\n            if (cut_edge_states[0].tape == TapeEdge.taped) {\n                cut_message = 'You draw your blade easily along the line. It slits open the thin layer of tape covering the gap in the cardboard.';\n            } else {\n                cut_message = 'You slide your blade along the line, but nothing is there to resist it.';\n            }\n        }\n\n        if (cut_edge_states.length > 1) {\n            if (cut_edge_states[1].cardboard != cut_edge_states[0].cardboard) {\n                if (cut_edge_states[1].cardboard == CardboardEdge.intact) {\n                    cut_message += ' Halfway across, it catches on solid cardboard, and you pull it along the rest of the way.';\n                } else {\n                    if (cut_edge_states[1].tape == TapeEdge.taped) {\n                        cut_message += ' Halfway across, you reach a gap in the cardboard, and your blade slides easily along the thin layer of tape.';\n                    } else {\n                        cut_message += ' Halfway across, you reach a gap in the cardboard, and your blade is met with no further resistance.';\n                    }\n                }\n            }\n        }\n\n        let message = cut_message;\n        if (effects.new_rends.length > 0) {\n            let total_face_membership = new Map<Face, number>();\n            effects.new_rends.forEach(function (r) {\n                let face_membership = new_box.box_mesh.get_partition_face_membership(r);\n                total_face_membership = counter_update(total_face_membership, face_membership);\n            })\n            let face_order = counter_order(total_face_membership);\n            let face_msg = face_message(face_order);\n\n            let new_rends_message: string;\n            if (effects.new_rends.length == 1) {\n                new_rends_message = `A new section of cardboard comes free on the ${face_msg}.`;\n            } else {\n                new_rends_message = `${effects.new_rends.length} new sections of cardboard come free on the ${face_msg}.`;\n            }\n            message += '\\n' + new_rends_message;\n        }\n\n        if (effects.new_dangles.length > 0) {\n            let total_face_membership = new Map<Face, number>();\n            effects.new_dangles.forEach(function (d) {\n                let face_membership = new_box.box_mesh.get_partition_face_membership(d.partition);\n                total_face_membership = counter_update(total_face_membership, face_membership);\n            })\n            let face_order = counter_order(total_face_membership);\n            let face_msg = face_message(face_order);\n\n            let new_rends_message: string;\n            if (effects.new_dangles.length == 1) {\n                new_rends_message = `A new section of cardboard on the ${face_msg} can be swung freely on a hinge.`;\n            } else {\n                new_rends_message = `${effects.new_dangles.length} new sections of cardboard on the ${face_msg} can be swung freely on a hinge.`;\n            }\n            message += '\\n' + new_rends_message;\n        }\n        return message;\n    }\n\n    tape_message(new_box: Box, cut_edge_states: EdgeState[], effects: WorldUpdateEffects) {\n        let tape_message: string;\n        if (cut_edge_states.some((ces) => ces.cardboard == CardboardEdge.intact)) {\n            tape_message = 'You draw out a length of tape and fasten it to the cardboard.';\n        } else {\n            if (cut_edge_states.some((ces) => ces.tape == TapeEdge.taped)) {\n                tape_message = 'You lay another length of tape over the cut edge.';\n            } else {\n                tape_message = 'You seal the gap in the cardboard with a length of tape.';\n            }\n        }\n\n        let message = tape_message;\n        if (effects.repaired_dangles.length > 0) {\n            let total_face_membership = new Map<Face, number>();\n            effects.repaired_dangles.forEach(function (d) {\n                let face_membership = new_box.box_mesh.get_partition_face_membership(d.partition);\n                total_face_membership = counter_update(total_face_membership, face_membership);\n            })\n            let face_order = counter_order(total_face_membership);\n            let face_msg = face_message(face_order);\n\n            let repaired_dangles_message: string;\n            if (effects.new_rends.length == 1) {\n                repaired_dangles_message = `A formerly freely-swinging section of cardboard on the ${face_msg} can no longer swing on its hinge.`;\n            } else {\n                repaired_dangles_message = `${face_order.length} formerly freely-swinging sections of cardboard on the ${face_msg} can no longer swing on their hinges.`;\n            }\n            message += '\\n' + repaired_dangles_message;\n        }\n        return message;\n    }\n\n    item_spill_message(spilled_items: Item[]){\n        let si = spilled_items;\n        let during_spill_msg: string;\n        let after_spill_msg: string;\n\n        if (si.length == 1) {\n            let item_msg = si[0].pre_gestalt();\n            during_spill_msg = `${capitalize(item_msg)} spills out before you.`;\n            after_spill_msg = `It's ${si[0].article()} ${si[0].name()} - ${si[0].post_gestalt()}.`;\n        } else {\n            let item_msg = si.slice(0, si.length - 1).map((i) => i.pre_gestalt()).join(', ') + ' and ' + si[si.length - 1].pre_gestalt();\n            during_spill_msg = capitalize(`${item_msg} spill out before you.`);\n\n            let after_msgs = si.map((i) => `${i.article()} ${i.name()} - ${i.post_gestalt()}`);\n            after_spill_msg = \"It's \" + after_msgs.slice(0, after_msgs.length - 1).join(', ') + ' and ' + after_msgs[after_msgs.length - 1] + '.';\n        }\n\n        let spill_msg = during_spill_msg + ' ' + after_spill_msg;\n        return spill_msg;\n    }\n\n    spill_message(new_box: Box) {\n        let effects = world_update.effects;\n\n        let structural_dmg_msgs: string[] = [];\n\n        if (effects.spilled_rends.size > 0) {\n            let total_face_membership = new Map<Face, number>();\n            effects.spilled_rends.keys_array().forEach(function (sr) {\n                let sr_mem = new_box.box_mesh.get_partition_face_membership(sr);\n                total_face_membership = counter_update(total_face_membership, sr_mem);\n            });\n            let sr_faces = counter_order(total_face_membership);\n            let f_msg = face_message(sr_faces);\n            let spilled_rends_msg = `free cardboard on the ${f_msg} falls away`;\n            structural_dmg_msgs.push(spilled_rends_msg);\n        }\n\n        if (effects.spilled_dangles.size > 0) {\n            let total_face_membership = new Map<Face, number>();\n            effects.spilled_dangles.keys_array().forEach(function (sd) {\n                let sd_mem = new_box.box_mesh.get_partition_face_membership(sd.partition);\n                total_face_membership = counter_update(total_face_membership, sd_mem);\n            });\n            let sd_faces = counter_order(total_face_membership);\n            let f_msg = face_message(sd_faces);\n            let spilled_dangles_msg = `dangling cardboard on the ${f_msg} swings open`;\n            structural_dmg_msgs.push(spilled_dangles_msg);\n        }\n\n        let spill_msg = this.item_spill_message(effects.spilled_items);\n        let result: string;\n\n        if (structural_dmg_msgs.length > 0) {\n            let structure_dmg_msg = structural_dmg_msgs.join(' and ');\n            result = `${structure_dmg_msg}. ${spill_msg}`;\n        } else {\n            result = spill_msg;\n        }\n        return result;\n    }\n}\n\nlet rotate_y_box: Command<SingleBoxWorld> = {\n    command_name: ['rotate'],\n    \n    execute: function(world:SingleBoxWorld, parser: CommandParser): CommandResult<SingleBoxWorld> {\n        let dir_word = parser.consume_option<RotateYDirWord>(rotate_y_word_tokens);\n        if (!dir_word) {\n            return;\n        }\n        if (!parser.done()){\n            return;\n        }\n\n        let degrees = dir_word == 'right' ? 90 : 270;\n        let new_box = world.box.rotate_y(degrees);\n        let new_world = world.update({box: new_box});\n\n        let message = `You turn the box 90 degrees to the ${dir_word}`;\n\n        return {\n            world: new_world,\n            message: message\n        };\n    }\n}\n\nlet roll_box: Command<SingleBoxWorld> = {\n    command_name: [\"roll\"],\n\n    execute: function(world: SingleBoxWorld, parser: CommandParser): CommandResult<SingleBoxWorld> {\n        return with_world_update(function (effects) {\n            let dir_word = parser.consume_option<RollDirWord>(roll_dir_word_tokens);\n            if (!dir_word) {\n                return;\n            }\n            if (!parser.done()) {\n                return;\n            }\n            let direction = word_2_dir.get(dir_word);\n            let new_box = world.box.roll(direction);\n\n            let dir_msg = (dir_word == 'left' || dir_word == 'right') ? `over to the ${dir_word}` : dir_word;\n\n            let message: string;\n            let new_world: SingleBoxWorld;\n            if (effects.spillage_level == SpillageLevel.none) {\n                message = `You roll the box ${dir_msg}.`;\n                new_world = world.update({box: new_box});\n            } else {\n                let spill_msg = uncapitalize(world.spill_message(new_box));\n                message = `As you roll the box ${dir_msg}, ${spill_msg}`;\n\n                new_world = world.update({box: new_box, spilled_items: effects.spilled_items});\n            }\n\n            if (effects.box_collapsed) {\n                message += '\\nThe added stress on the box causes it to collapse in on itself.';\n                if (effects.collapse_spilled_items.length > 0) {\n                    message += ' ';\n                    message += world.item_spill_message(effects.collapse_spilled_items);\n                }\n            }\n\n            return {\n                world: new_world,\n                message: message\n            };\n        });\n    }\n}\n\nlet lift_box: Command<SingleBoxWorld> = {\n    command_name: ['lift'],\n    execute: function(world: SingleBoxWorld, parser: CommandParser): CommandResult<SingleBoxWorld> {\n        //let inner_this = this;\n        return with_world_update(function (effects) {\n            if (!parser.done()){\n                return;\n            }\n            let new_box = world.box.lift();\n\n            let msg: string;\n            let new_world: SingleBoxWorld;\n            if (effects.spillage_level == SpillageLevel.none) {\n                msg = 'You lift up the box in place.';\n                new_world = world.update({box: new_box});\n            } else {\n                let spill_msg = uncapitalize(world.spill_message(new_box));\n                msg = 'As you start to lift up the box, ' + spill_msg;\n                new_world = world.update({box: new_box, spilled_items: effects.spilled_items});\n            }\n\n            if (effects.spillage_level <= SpillageLevel.heavy && !effects.box_collapsed) {\n                let total_weight = new_box.contents.reduce((x, i) => x + i.weight(), 0);\n                total_weight = Math.floor(total_weight / 2.9); //rule of thumb for translating \"normal item weights\" to \"normal box weights\"\n\n                if (total_weight > Weight.very_heavy) {\n                    total_weight = Weight.very_heavy;\n                }\n                let weight_2_msg = new Map<Weight, string>([\n                    [Weight.empty, 'so light as to be empty'],\n                    [Weight.very_light, 'quite light'],\n                    [Weight.light, 'light'],\n                    [Weight.medium, 'neither light nor heavy'],\n                    [Weight.heavy, 'somewhat heavy'],\n                    [Weight.very_heavy, 'very heavy']\n                ]);\n                let weight_msg = weight_2_msg.get(total_weight);\n                let subject = effects.spillage_level == SpillageLevel.none ? 'It' : 'The box';\n                msg += `\\n${subject} feels ${weight_msg}. You set it back down.`;\n            }\n\n            if (effects.box_collapsed) {\n                msg += '\\nThe added stress on the box causes it to collapse in on itself.';\n                if (effects.collapse_spilled_items.length > 0) {\n                    msg += ' ' + world.item_spill_message(effects.collapse_spilled_items);\n                }\n            }\n\n            return {world:new_world, message: msg};\n        });\n    }\n}\n\nlet cut_box: Command<SingleBoxWorld> = {\n    command_name: ['cut'],\n    execute: cut_or_tape_box\n}\n\nlet tape_box: Command<SingleBoxWorld> = {\n    command_name: ['tape'],\n    execute: cut_or_tape_box\n}\n\ntype cut_or_tape_bindings = {cut_points?: [Point2, Point2][]} & {message?: string};\n\nconst dim_2_pos = [\n    ['left', 'center', 'right'],\n    ['top','middle', 'bottom']\n];\n\nfunction parser_cut_or_tape_box(parser: CommandParser): cut_or_tape_bindings {\n    let operation: EdgeOpWord = <EdgeOpWord>parser.get_match('command').match;\n\n    let dir: Token | false;\n    if (parser.is_done()) {\n        dir = 'horizontally';\n    } else {\n        dir = parser.consume_option(edge_dir_word_tokens);\n\n        if (!dir){\n            return;\n        }\n    }\n\n    let dim_a: number;\n    let dim_b: number;\n\n    if (dir === 'vertically') {\n        dim_a = 0;\n        dim_b = 1;\n    } else {\n        dim_a = 1;\n        dim_b = 0;\n    }\n\n    let start_pos_a: Token | false;\n    if (parser.is_done()){\n        if (dim_a === 0) { //default for vertical\n            start_pos_a = 'center';\n        } else { // default for horizontal\n            start_pos_a = 'middle';\n        }\n    } else {\n        if (!parser.consume_filler(['along'])){\n            return;\n        }\n        start_pos_a = parser.consume_option(position_word_tokens, 'start_pos_a');\n        if (!start_pos_a) {\n            return;\n        }\n        if (dim_2_pos[dim_a].indexOf(start_pos_a) === -1) {\n            parser.get_match('start_pos_a').display = DisplayEltType.error;\n            parser.validity = MatchValidity.invalid;\n            return {message: `invalid start_pos_a for ${dir} ${operation}: ${start_pos_a}`};\n        }\n    }\n    \n    let start_pos_b: Token | false;\n    let end_pos_b: Token | false;\n    if (parser.is_done()) {\n        if (dim_a === 0) { //default for vertical\n            start_pos_b = 'top';\n            end_pos_b = 'bottom';\n        } else { // default for horizontal\n            start_pos_b = 'left';\n            end_pos_b = 'right';\n        }\n    } else {\n        if (!parser.consume_filler(['from'])){\n            return;\n        }\n\n        start_pos_b = parser.consume_option(position_word_tokens, 'start_pos_b');\n        if (!start_pos_b) {\n            return;\n        }\n        if (dim_2_pos[dim_b].indexOf(start_pos_b) === -1) {\n            parser.get_match('start_pos_b').display = DisplayEltType.error;\n            parser.validity = MatchValidity.invalid;\n            return {message: `invalid start_pos_b for ${dir} ${operation}: ${start_pos_b}`};\n        }\n\n        if (!parser.consume_filler(['to'])){\n            return;\n        }\n        end_pos_b = parser.consume_option(position_word_tokens, 'end_pos_b');\n        if (!end_pos_b) {\n            return;\n        }\n        if (dim_2_pos[dim_b].indexOf(end_pos_b) === -1) {\n            parser.get_match('end_pos_b').display = DisplayEltType.error;\n            parser.validity = MatchValidity.invalid;\n            return {message: `invalid end_pos_b for ${dir} ${operation}: ${end_pos_b}`};\n        }\n\n    }\n    \n    let pt1: Point2 = [null, null];\n    let pt2: Point2 = [null, null];\n\n    pt1[dim_a] = pt2[dim_a] = dim_2_pos[dim_a].indexOf(start_pos_a);\n\n    pt1[dim_b] = dim_2_pos[dim_b].indexOf(start_pos_b);\n    pt2[dim_b] = dim_2_pos[dim_b].indexOf(end_pos_b);\n\n    if (Math.abs(pt1[dim_b] - pt2[dim_b]) == 0) {\n        parser.get_match('end_pos_b').display = DisplayEltType.error;\n        return {message: 'no change between start_pos_b and end_pos_b.'};\n    }\n\n    if (!parser.done()){\n        return;\n    }\n\n    let cut_points: [Point2, Point2][];\n    if (Math.abs(pt1[dim_b] - pt2[dim_b]) === 2) {\n        let pt3: Point2 = [null, null];\n        pt3[dim_a] = dim_2_pos[dim_a].indexOf(start_pos_a);\n        pt3[dim_b] = 1;\n\n        cut_points = [[pt1, pt3], [pt3, pt2]];\n    } else {\n        cut_points = [[pt1, pt2]];\n    }\n\n    return {cut_points};\n}\n\nfunction cut_or_tape_box(world: SingleBoxWorld, parser: CommandParser): CommandResult<SingleBoxWorld> {\n    //operation: EdgeOpWord, face_w: FaceWord, dir: EdgeDirWord, start_pos_a: PositionWord, start_pos_b: PositionWord, end_pos_b: PositionWord): CommandResult {\n    //let inner_this = this;\n    return with_world_update(function (effects) {\n        let operation: EdgeOpWord = <EdgeOpWord>parser.get_match('command').match;\n        \n        let parse_result = parser_cut_or_tape_box(parser);\n        if (parse_result === undefined || parse_result.message !== undefined) {\n            return parse_result;\n        }\n\n        let {cut_points} = parse_result;\n\n        let cut_edge_states: EdgeState[] = [];\n\n        let new_box = world.box;\n        let face = Face.t;\n        cut_points.forEach(function ([p1, p2]) {\n            let vertices = new_box.box_mesh.face_meshes.get(face).vertices;\n            let v1 = vertices.get(p1[0], p1[1]);\n            let v2 = vertices.get(p2[0], p2[1]);\n            let edge = new Edge(v1, v2);\n\n            let new_state: EdgeState;\n            if (new_box.edge_state.has_key(edge)) {\n                new_state = new_box.edge_state.get(edge);\n            } else {\n                new_state = new EdgeState();\n            }\n\n            cut_edge_states.push(new_state);\n            new_box = new_box.cut_or_tape(word_2_edge_op.get(operation), face, p1, p2);\n        });\n\n        effects.new_dangles.forEach(function (nd) {\n            if (array_fuck_contains(effects.new_rends, nd.partition)) {\n                effects.new_dangles.splice(effects.new_dangles.indexOf(nd), 1);\n            }\n        });\n\n        effects.repaired_dangles.forEach(function (rd) {\n            if (array_fuck_contains(effects.new_rends, rd.partition)) {\n                effects.repaired_dangles.splice(effects.repaired_dangles.indexOf(rd), 1);\n            }\n        });\n\n        let message: string;\n        if (operation == 'cut') {\n            message = world.cut_message(new_box, cut_edge_states, effects);\n        } else {\n            message = world.tape_message(new_box, cut_edge_states, effects);\n        }\n\n        return {world: world.update({box: new_box}), message: message};\n    });\n}\n\nlet open_dangle: Command<SingleBoxWorld> = {\n    command_name: ['open'],\n    execute: open_or_close_dangle\n}\n\n\nlet close_dangle: Command<SingleBoxWorld> = {\n    command_name: ['close'],\n    execute: open_or_close_dangle\n}\n\nfunction open_or_close_dangle(world: SingleBoxWorld, parser: CommandParser): CommandResult<SingleBoxWorld> {\n    // operation: DangleOpWord, face_w: FaceWord)\n    return with_world_update(function (effects) {\n        let operation = <DangleOpWord>parser.get_match('command').match;\n        let face_w = parser.consume_option<FaceWord>(face_word_tokens, 'face');\n        if (!face_w || !parser.done()) {\n            return;\n        }\n\n        let face = word_2_face.get(face_w)\n        let applicable_dangles = world.box.dangle_state.keys_array().filter((d) => d.free_face == face);\n        let new_box = world.box;\n        let updated: Dangle[] = [];\n        applicable_dangles.forEach(function (d){\n            let err = false;\n            try {\n                new_box = new_box.open_or_close_dangle(word_2_dangle_op.get(operation), d);\n            } catch (e) {\n                err = true;\n                if (!(e instanceof WorldUpdateError)) {\n                    throw e;\n                }\n            }\n            if (!err) {\n                updated.push(d);\n            }\n        });\n        if (updated.length === 0) {\n            parser.get_match('face').display = DisplayEltType.error;\n            parser.validity = MatchValidity.invalid;\n            return {message: `No dangles to ${operation} on ${face_w} face`};\n        }\n\n        let swing_dir_msg = operation === 'close' ? 'in' : 'out';\n        let num_hinges = new Set(updated.map((d) => d.fixed_face)).size;\n        let hinge_msg: string;\n        if (num_hinges == 1) {\n            hinge_msg = 'hinge';\n        } else {\n            hinge_msg = 'hinges';\n        }\n\n        let message = `You swing the cardboard on the ${face_w} of the box ${swing_dir_msg} on its ${hinge_msg}`;\n        if (!world.box.appears_open() && new_box.appears_open()) {\n            message += '\\nYou get a glimpse inside the box through the opening.';\n\n            if (new_box.appears_empty()) {\n                message += \" It's empty.\";\n            } else {\n                message += ` You can see ${new_box.next_item().pre_gestalt()} inside.`;\n            }\n        }\n        if (effects.box_collapsed) {\n            message += '\\nThe added stress on the box causes it to collapse in on itself.';\n            if (effects.collapse_spilled_items.length > 0) {\n                message += ' ' + world.item_spill_message(effects.collapse_spilled_items);\n            }\n        }\n        return {world: world.update({box: new_box}), message: message};\n    });\n}\n\nlet remove_rend: Command<SingleBoxWorld> = {\n    command_name: ['remove'],\n    execute: remove_or_replace_rend\n}\n\nlet replace_rend: Command<SingleBoxWorld> = {\n    command_name: ['replace'],\n    execute: remove_or_replace_rend\n}\n\nfunction remove_or_replace_rend(world: SingleBoxWorld, parser: CommandParser): CommandResult<SingleBoxWorld> {\n    //operation: RendOpWord, face_w: FaceWord): CommandResult {\n    return with_world_update(function (effects) {\n        let operation = <RendOpWord>parser.get_match('command').match;\n        let face_w = parser.consume_option<FaceWord>(face_word_tokens, 'face');\n        if (!face_w || !parser.done()) {\n            return;\n        }\n\n        let face = word_2_face.get(face_w);\n        let applicable_rends: Partition[] = [];\n        world.box.rend_state.entries_array().forEach(function ([r, s]) {\n            let face_membership = world.box.box_mesh.get_partition_face_membership(r);\n            if (face_membership.get(face) > 0) {\n                applicable_rends.push(r);\n            }\n        });\n\n        let new_box = world.box;\n        let updated: Partition[] = [];\n        applicable_rends.forEach(function (r){\n            let err = false;\n            try {\n                new_box = new_box.open_or_close_rend(word_2_rend_op.get(operation), r);\n            } catch (e) {\n                err = true;\n                if (!(e instanceof WorldUpdateError)) {\n                    throw e;\n                }\n            }\n            if (!err) {\n                updated.push(r);\n            }\n        });\n        if (updated.length == 0) {\n            parser.get_match('face').display = DisplayEltType.error;\n            parser.validity = MatchValidity.invalid;\n            return {message: `No rends to ${operation} on ${face_w} face`};\n        }\n\n        let total_face_membership = new Map<Face, number>();\n        total_face_membership = updated.reduce(\n            (total, r) => counter_update(\n                total,\n                world.box.box_mesh.get_partition_face_membership(r)),\n            total_face_membership);\n\n        let face_msg = face_message(counter_order(total_face_membership));\n\n        let message: string;\n        if (operation === 'remove') {\n            message = `You remove the free cardboard from the ${face_msg} and place it to the side.`;\n        } else {\n            `You replace the missing cardboard from the ${face_msg}.`;\n        }\n\n        if (!world.box.appears_open() && new_box.appears_open()) {\n            message += '\\nYou get a glimpse inside the box through the opening.';\n\n            if (new_box.appears_empty()) {\n                message += \" It's empty.\";\n            } else {\n                message += ` You can see ${new_box.next_item().pre_gestalt()} inside.`;\n            }\n        }\n        if (effects.box_collapsed) {\n            message += '\\nThe added stress on the box causes it to collapse in on itself.';\n            if (effects.collapse_spilled_items.length > 0) {\n                message += ' ' + world.item_spill_message(effects.collapse_spilled_items);\n            }\n        }\n        return {world: world.update({box: new_box}), message:message};\n    });\n}\n\nlet take_item: Command<SingleBoxWorld> = {\n    command_name: ['take', 'item'],\n    execute: function(world: SingleBoxWorld, parser: CommandParser): CommandResult<SingleBoxWorld> {\n        return with_world_update(function (effects) {\n            if (!parser.done()) {\n                return;\n            }\n\n            let new_box = world.box.take_next_item();\n\n            let new_taken_items = world.taken_items;\n            new_taken_items.push(...effects.taken_items);\n\n            let item = effects.taken_items[0];\n            let message = `You reach in and take ${item.pre_gestalt()}. It's ${item.post_gestalt()}; ${item.article()} ${item.name()}.`;\n        \n            if (new_box.appears_empty()) {\n                message += '\\nThe box is empty now.';\n            } else {\n                message += `\\nYou can now see ${new_box.next_item().pre_gestalt()} inside the box.`;\n            }\n\n            return {world: world.update({box: new_box, taken_items: new_taken_items}), message: message};\n        });\n    }\n}\n\nexport function test() {\n    let contents: Item[] = [new Codex(), new Pinecone(), new CityKey()];\n    let world = new SingleBoxWorld({box: new Box({contents: contents})});\n\n    console.log('NEW WORLD: test heavy spillage when rolling\\n\\n\\n');\n\n    let d = new WorldDriver(world);\n    d.apply_command('lift');\n    d.apply_command('roll forward');\n    d.apply_command('rotate left');\n\n    d.apply_command('rotate le', false);\n\n    // cut the top face vertically along the center from top to bottom\n    d.apply_command('cut on top vertically along center from top to bottom');\n\n    // cut the top face vertically along the right edge from top to bottom\n    d.apply_command('cut on top vertically along right from top to bottom');\n\n    // should result in a dangle\n    // cut the top face horizontally along the top edge from center to right\n    d.apply_command('cut on top horizontally along top from center to right');\n\n    // should result in a rend\n    // cut the top face horizontally along the bottom edge from center to right\n    d.apply_command('cut on top horizontally along bottom from center to right');\n\n    d.apply_command('roll forward');\n\n    // should result in the rend facing straight down, maybe spilling\n    d.apply_command('roll forward');\n\n    d.apply_command('lift');\n\n    console.log('\\n\\n\\nNEW WORLD: test heavy spillage and collapse from bottom when lifting\\n\\n\\n');\n    let d2 = new WorldDriver(world);\n\n    d2.apply_command('cut on front horizontally along bottom from left to right');\n    d2.apply_command('rotate left');\n    d2.apply_command('cut on front horizontally along bottom from left to right');\n    d2.apply_command('rotate left');\n    d2.apply_command('cut on front horizontally along bottom from left to right');\n    d2.apply_command('rotate left');\n    d2.apply_command('cut on front horizontally along bottom from left to right');\n    d2.apply_command('lift');\n    \n    console.log('\\n\\n\\nNEW WORLD: test taping\\n\\n\\n');\n    let d3 = new WorldDriver(world);\n\n    d3.apply_command('cut on top horizontally along top from left to right');\n    d3.apply_command('cut on top horizontally along bottom from left to right');\n    d3.apply_command('cut on top vertically along left from top to bottom');\n\n    d3.apply_command('open top');\n    d3.apply_command('take item');\n\n    d3.apply_command('close top');\n\n    d3.apply_command('cut on top vertically along right from top to bottom');\n    d3.apply_command('remove top');\n    d3.apply_command('take item');\n    d3.apply_command('take item');\n    d3.apply_command('replace top');\n\n    d3.apply_command('tape on top vertically along right from top to bottom');\n    d3.apply_command('tape on top vertically along left from top to middle');\n\n    console.log('\\n\\n\\nNEW WORLD: test light spillage when rolling and lifting\\n\\n\\n');\n    let d4 = new WorldDriver(world);\n\n    d4.apply_command('cut on front horizontally along top from left to right');\n    d4.apply_command('cut on front horizontally along bottom from left to right');\n    d4.apply_command('cut on front vertically along left from top to bottom');\n\n    d4.apply_command('lift');\n\n    d4.apply_command('cut on front vertically along right from top to bottom');\n\n    d4.apply_command('roll right');\n}\n\n//test();\n\n\n// WEBPACK FOOTER //\n// ./src/typescript/world.ts","import * as Datatypes from './datatypes';\n\n// import {Map, List, Set, OrderedSet, is} from 'immutable';\n\nexport class WorldUpdateEffects {\n    spill_faces: Datatypes.Face[] = [];\n    spilled_items: Datatypes.Item[] = [];\n    spilled_rends: Datatypes.FuckSet<Datatypes.Partition> = new Datatypes.FuckDict<Datatypes.Partition, undefined>();\n    spilled_dangles: Datatypes.FuckSet<Datatypes.Dangle> = new Datatypes.FuckDict<Datatypes.Dangle, undefined>();\n    spillage_level = Datatypes.SpillageLevel.none;\n    taken_items: Datatypes.Item[] = [];\n    new_rends: Datatypes.Partition[] = [];\n    new_dangles: Datatypes.Dangle[] = [];\n    repaired_rends: Datatypes.Partition[] = [];\n    repaired_dangles: Datatypes.Dangle[] = [];\n    box_collapsed = false;\n    collapse_spilled_items: Datatypes.Item[] = [];\n}\n\ninterface WorldUpdateEffectsRef {\n    effects?: WorldUpdateEffects\n}\n\nexport let world_update: WorldUpdateEffectsRef = {};\n\nexport function with_world_update<T>(f: (effects: WorldUpdateEffects) => T) {\n    //TODO validate: error if world_update.effects isn't null/undefined\n    world_update.effects = new WorldUpdateEffects();\n    let result = f(world_update.effects);\n    world_update.effects = undefined;\n    return result;\n}\n\n//TODO define world update exceptions\n\n\n// WEBPACK FOOTER //\n// ./src/typescript/world_update_effects.ts"],"sourceRoot":""}