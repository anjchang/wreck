(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/**
 *  Copyright (c) 2014-2015, Facebook, Inc.
 *  All rights reserved.
 *
 *  This source code is licensed under the BSD-style license found in the
 *  LICENSE file in the root directory of this source tree. An additional grant
 *  of patent rights can be found in the PATENTS file in the same directory.
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.Immutable = global.Immutable || {})));
}(this, (function (exports) { 'use strict';

// Used for setting prototype methods that IE8 chokes on.
var DELETE = 'delete';

// Constants describing the size of trie nodes.
var SHIFT = 5; // Resulted in best performance after ______?
var SIZE = 1 << SHIFT;
var MASK = SIZE - 1;

// A consistent shared value representing "not set" which equals nothing other
// than itself, and nothing that could be provided externally.
var NOT_SET = {};

// Boolean references, Rough equivalent of `bool &`.
var CHANGE_LENGTH = { value: false };
var DID_ALTER = { value: false };

function MakeRef(ref) {
  ref.value = false;
  return ref;
}

function SetRef(ref) {
  ref && (ref.value = true);
}

// A function which returns a value representing an "owner" for transient writes
// to tries. The return value will only ever equal itself, and will not equal
// the return of any subsequent call of this function.
function OwnerID() {}

// http://jsperf.com/copy-array-inline
function arrCopy(arr, offset) {
  offset = offset || 0;
  var len = Math.max(0, arr.length - offset);
  var newArr = new Array(len);
  for (var ii = 0; ii < len; ii++) {
    newArr[ii] = arr[ii + offset];
  }
  return newArr;
}

function ensureSize(iter) {
  if (iter.size === undefined) {
    iter.size = iter.__iterate(returnTrue);
  }
  return iter.size;
}

function wrapIndex(iter, index) {
  // This implements "is array index" which the ECMAString spec defines as:
  //
  //     A String property name P is an array index if and only if
  //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal
  //     to 2^32âˆ’1.
  //
  // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects
  if (typeof index !== 'number') {
    var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32
    if ('' + uint32Index !== index || uint32Index === 4294967295) {
      return NaN;
    }
    index = uint32Index;
  }
  return index < 0 ? ensureSize(iter) + index : index;
}

function returnTrue() {
  return true;
}

function wholeSlice(begin, end, size) {
  return (begin === 0 || (size !== undefined && begin <= -size)) &&
    (end === undefined || (size !== undefined && end >= size));
}

function resolveBegin(begin, size) {
  return resolveIndex(begin, size, 0);
}

function resolveEnd(end, size) {
  return resolveIndex(end, size, size);
}

function resolveIndex(index, size, defaultIndex) {
  // Sanitize indices using this shorthand for ToInt32(argument)
  // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
  return index === undefined
    ? defaultIndex
    : index < 0
        ? size === Infinity ? size : Math.max(0, size + index) | 0
        : size === undefined || size === index
            ? index
            : Math.min(size, index) | 0;
}

function isImmutable(maybeImmutable) {
  return (isCollection(maybeImmutable) || isRecord(maybeImmutable)) &&
    !maybeImmutable.__ownerID;
}

function isCollection(maybeCollection) {
  return !!(maybeCollection && maybeCollection[IS_ITERABLE_SENTINEL]);
}

function isKeyed(maybeKeyed) {
  return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);
}

function isIndexed(maybeIndexed) {
  return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);
}

function isAssociative(maybeAssociative) {
  return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);
}

function isOrdered(maybeOrdered) {
  return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);
}

function isRecord(maybeRecord) {
  return !!(maybeRecord && maybeRecord[IS_RECORD_SENTINEL]);
}

function isValueObject(maybeValue) {
  return !!(maybeValue &&
    typeof maybeValue.equals === 'function' &&
    typeof maybeValue.hashCode === 'function');
}

var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';
var IS_RECORD_SENTINEL = '@@__IMMUTABLE_RECORD__@@';

var Collection = function Collection(value) {
  return isCollection(value) ? value : Seq(value);
};

var KeyedCollection = (function (Collection) {
  function KeyedCollection(value) {
    return isKeyed(value) ? value : KeyedSeq(value);
  }

  if ( Collection ) KeyedCollection.__proto__ = Collection;
  KeyedCollection.prototype = Object.create( Collection && Collection.prototype );
  KeyedCollection.prototype.constructor = KeyedCollection;

  return KeyedCollection;
}(Collection));

var IndexedCollection = (function (Collection) {
  function IndexedCollection(value) {
    return isIndexed(value) ? value : IndexedSeq(value);
  }

  if ( Collection ) IndexedCollection.__proto__ = Collection;
  IndexedCollection.prototype = Object.create( Collection && Collection.prototype );
  IndexedCollection.prototype.constructor = IndexedCollection;

  return IndexedCollection;
}(Collection));

var SetCollection = (function (Collection) {
  function SetCollection(value) {
    return isCollection(value) && !isAssociative(value) ? value : SetSeq(value);
  }

  if ( Collection ) SetCollection.__proto__ = Collection;
  SetCollection.prototype = Object.create( Collection && Collection.prototype );
  SetCollection.prototype.constructor = SetCollection;

  return SetCollection;
}(Collection));

Collection.Keyed = KeyedCollection;
Collection.Indexed = IndexedCollection;
Collection.Set = SetCollection;

var ITERATE_KEYS = 0;
var ITERATE_VALUES = 1;
var ITERATE_ENTRIES = 2;

var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator';

var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;

var Iterator = function Iterator(next) {
  this.next = next;
};

Iterator.prototype.toString = function toString () {
  return '[Iterator]';
};

Iterator.KEYS = ITERATE_KEYS;
Iterator.VALUES = ITERATE_VALUES;
Iterator.ENTRIES = ITERATE_ENTRIES;

Iterator.prototype.inspect = (Iterator.prototype.toSource = function() {
  return this.toString();
});
Iterator.prototype[ITERATOR_SYMBOL] = function() {
  return this;
};

function iteratorValue(type, k, v, iteratorResult) {
  var value = type === 0 ? k : type === 1 ? v : [k, v];
  iteratorResult
    ? (iteratorResult.value = value)
    : (iteratorResult = {
        value: value,
        done: false
      });
  return iteratorResult;
}

function iteratorDone() {
  return { value: undefined, done: true };
}

function hasIterator(maybeIterable) {
  return !!getIteratorFn(maybeIterable);
}

function isIterator(maybeIterator) {
  return maybeIterator && typeof maybeIterator.next === 'function';
}

function getIterator(iterable) {
  var iteratorFn = getIteratorFn(iterable);
  return iteratorFn && iteratorFn.call(iterable);
}

function getIteratorFn(iterable) {
  var iteratorFn = iterable &&
    ((REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) ||
      iterable[FAUX_ITERATOR_SYMBOL]);
  if (typeof iteratorFn === 'function') {
    return iteratorFn;
  }
}

function isArrayLike(value) {
  return value && typeof value.length === 'number';
}

var Seq = (function (Collection$$1) {
  function Seq(value) {
    return value === null || value === undefined
      ? emptySequence()
      : isCollection(value) || isRecord(value)
          ? value.toSeq()
          : seqFromValue(value);
  }

  if ( Collection$$1 ) Seq.__proto__ = Collection$$1;
  Seq.prototype = Object.create( Collection$$1 && Collection$$1.prototype );
  Seq.prototype.constructor = Seq;

  Seq.of = function of (/*...values*/) {
    return Seq(arguments);
  };

  Seq.prototype.toSeq = function toSeq () {
    return this;
  };

  Seq.prototype.toString = function toString () {
    return this.__toString('Seq {', '}');
  };

  Seq.prototype.cacheResult = function cacheResult () {
    if (!this._cache && this.__iterateUncached) {
      this._cache = this.entrySeq().toArray();
      this.size = this._cache.length;
    }
    return this;
  };

  // abstract __iterateUncached(fn, reverse)

  Seq.prototype.__iterate = function __iterate (fn, reverse) {
    var this$1 = this;

    var cache = this._cache;
    if (cache) {
      var size = cache.length;
      var i = 0;
      while (i !== size) {
        var entry = cache[reverse ? size - ++i : i++];
        if (fn(entry[1], entry[0], this$1) === false) {
          break;
        }
      }
      return i;
    }
    return this.__iterateUncached(fn, reverse);
  };

  // abstract __iteratorUncached(type, reverse)

  Seq.prototype.__iterator = function __iterator (type, reverse) {
    var cache = this._cache;
    if (cache) {
      var size = cache.length;
      var i = 0;
      return new Iterator(function () {
        if (i === size) {
          return iteratorDone();
        }
        var entry = cache[reverse ? size - ++i : i++];
        return iteratorValue(type, entry[0], entry[1]);
      });
    }
    return this.__iteratorUncached(type, reverse);
  };

  return Seq;
}(Collection));

var KeyedSeq = (function (Seq) {
  function KeyedSeq(value) {
    return value === null || value === undefined
      ? emptySequence().toKeyedSeq()
      : isCollection(value)
          ? isKeyed(value) ? value.toSeq() : value.fromEntrySeq()
          : isRecord(value) ? value.toSeq() : keyedSeqFromValue(value);
  }

  if ( Seq ) KeyedSeq.__proto__ = Seq;
  KeyedSeq.prototype = Object.create( Seq && Seq.prototype );
  KeyedSeq.prototype.constructor = KeyedSeq;

  KeyedSeq.prototype.toKeyedSeq = function toKeyedSeq () {
    return this;
  };

  return KeyedSeq;
}(Seq));

var IndexedSeq = (function (Seq) {
  function IndexedSeq(value) {
    return value === null || value === undefined
      ? emptySequence()
      : isCollection(value)
          ? isKeyed(value) ? value.entrySeq() : value.toIndexedSeq()
          : isRecord(value)
              ? value.toSeq().entrySeq()
              : indexedSeqFromValue(value);
  }

  if ( Seq ) IndexedSeq.__proto__ = Seq;
  IndexedSeq.prototype = Object.create( Seq && Seq.prototype );
  IndexedSeq.prototype.constructor = IndexedSeq;

  IndexedSeq.of = function of (/*...values*/) {
    return IndexedSeq(arguments);
  };

  IndexedSeq.prototype.toIndexedSeq = function toIndexedSeq () {
    return this;
  };

  IndexedSeq.prototype.toString = function toString () {
    return this.__toString('Seq [', ']');
  };

  return IndexedSeq;
}(Seq));

var SetSeq = (function (Seq) {
  function SetSeq(value) {
    return (isCollection(value) && !isAssociative(value)
      ? value
      : IndexedSeq(value)).toSetSeq();
  }

  if ( Seq ) SetSeq.__proto__ = Seq;
  SetSeq.prototype = Object.create( Seq && Seq.prototype );
  SetSeq.prototype.constructor = SetSeq;

  SetSeq.of = function of (/*...values*/) {
    return SetSeq(arguments);
  };

  SetSeq.prototype.toSetSeq = function toSetSeq () {
    return this;
  };

  return SetSeq;
}(Seq));

Seq.isSeq = isSeq;
Seq.Keyed = KeyedSeq;
Seq.Set = SetSeq;
Seq.Indexed = IndexedSeq;

var IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';

Seq.prototype[IS_SEQ_SENTINEL] = true;

// #pragma Root Sequences

var ArraySeq = (function (IndexedSeq) {
  function ArraySeq(array) {
    this._array = array;
    this.size = array.length;
  }

  if ( IndexedSeq ) ArraySeq.__proto__ = IndexedSeq;
  ArraySeq.prototype = Object.create( IndexedSeq && IndexedSeq.prototype );
  ArraySeq.prototype.constructor = ArraySeq;

  ArraySeq.prototype.get = function get (index, notSetValue) {
    return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;
  };

  ArraySeq.prototype.__iterate = function __iterate (fn, reverse) {
    var this$1 = this;

    var array = this._array;
    var size = array.length;
    var i = 0;
    while (i !== size) {
      var ii = reverse ? size - ++i : i++;
      if (fn(array[ii], ii, this$1) === false) {
        break;
      }
    }
    return i;
  };

  ArraySeq.prototype.__iterator = function __iterator (type, reverse) {
    var array = this._array;
    var size = array.length;
    var i = 0;
    return new Iterator(function () {
      if (i === size) {
        return iteratorDone();
      }
      var ii = reverse ? size - ++i : i++;
      return iteratorValue(type, ii, array[ii]);
    });
  };

  return ArraySeq;
}(IndexedSeq));

var ObjectSeq = (function (KeyedSeq) {
  function ObjectSeq(object) {
    var keys = Object.keys(object);
    this._object = object;
    this._keys = keys;
    this.size = keys.length;
  }

  if ( KeyedSeq ) ObjectSeq.__proto__ = KeyedSeq;
  ObjectSeq.prototype = Object.create( KeyedSeq && KeyedSeq.prototype );
  ObjectSeq.prototype.constructor = ObjectSeq;

  ObjectSeq.prototype.get = function get (key, notSetValue) {
    if (notSetValue !== undefined && !this.has(key)) {
      return notSetValue;
    }
    return this._object[key];
  };

  ObjectSeq.prototype.has = function has (key) {
    return this._object.hasOwnProperty(key);
  };

  ObjectSeq.prototype.__iterate = function __iterate (fn, reverse) {
    var this$1 = this;

    var object = this._object;
    var keys = this._keys;
    var size = keys.length;
    var i = 0;
    while (i !== size) {
      var key = keys[reverse ? size - ++i : i++];
      if (fn(object[key], key, this$1) === false) {
        break;
      }
    }
    return i;
  };

  ObjectSeq.prototype.__iterator = function __iterator (type, reverse) {
    var object = this._object;
    var keys = this._keys;
    var size = keys.length;
    var i = 0;
    return new Iterator(function () {
      if (i === size) {
        return iteratorDone();
      }
      var key = keys[reverse ? size - ++i : i++];
      return iteratorValue(type, key, object[key]);
    });
  };

  return ObjectSeq;
}(KeyedSeq));
ObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;

var CollectionSeq = (function (IndexedSeq) {
  function CollectionSeq(collection) {
    this._collection = collection;
    this.size = collection.length || collection.size;
  }

  if ( IndexedSeq ) CollectionSeq.__proto__ = IndexedSeq;
  CollectionSeq.prototype = Object.create( IndexedSeq && IndexedSeq.prototype );
  CollectionSeq.prototype.constructor = CollectionSeq;

  CollectionSeq.prototype.__iterateUncached = function __iterateUncached (fn, reverse) {
    var this$1 = this;

    if (reverse) {
      return this.cacheResult().__iterate(fn, reverse);
    }
    var collection = this._collection;
    var iterator = getIterator(collection);
    var iterations = 0;
    if (isIterator(iterator)) {
      var step;
      while (!(step = iterator.next()).done) {
        if (fn(step.value, iterations++, this$1) === false) {
          break;
        }
      }
    }
    return iterations;
  };

  CollectionSeq.prototype.__iteratorUncached = function __iteratorUncached (type, reverse) {
    if (reverse) {
      return this.cacheResult().__iterator(type, reverse);
    }
    var collection = this._collection;
    var iterator = getIterator(collection);
    if (!isIterator(iterator)) {
      return new Iterator(iteratorDone);
    }
    var iterations = 0;
    return new Iterator(function () {
      var step = iterator.next();
      return step.done ? step : iteratorValue(type, iterations++, step.value);
    });
  };

  return CollectionSeq;
}(IndexedSeq));

var IteratorSeq = (function (IndexedSeq) {
  function IteratorSeq(iterator) {
    this._iterator = iterator;
    this._iteratorCache = [];
  }

  if ( IndexedSeq ) IteratorSeq.__proto__ = IndexedSeq;
  IteratorSeq.prototype = Object.create( IndexedSeq && IndexedSeq.prototype );
  IteratorSeq.prototype.constructor = IteratorSeq;

  IteratorSeq.prototype.__iterateUncached = function __iterateUncached (fn, reverse) {
    var this$1 = this;

    if (reverse) {
      return this.cacheResult().__iterate(fn, reverse);
    }
    var iterator = this._iterator;
    var cache = this._iteratorCache;
    var iterations = 0;
    while (iterations < cache.length) {
      if (fn(cache[iterations], iterations++, this$1) === false) {
        return iterations;
      }
    }
    var step;
    while (!(step = iterator.next()).done) {
      var val = step.value;
      cache[iterations] = val;
      if (fn(val, iterations++, this$1) === false) {
        break;
      }
    }
    return iterations;
  };

  IteratorSeq.prototype.__iteratorUncached = function __iteratorUncached (type, reverse) {
    if (reverse) {
      return this.cacheResult().__iterator(type, reverse);
    }
    var iterator = this._iterator;
    var cache = this._iteratorCache;
    var iterations = 0;
    return new Iterator(function () {
      if (iterations >= cache.length) {
        var step = iterator.next();
        if (step.done) {
          return step;
        }
        cache[iterations] = step.value;
      }
      return iteratorValue(type, iterations, cache[iterations++]);
    });
  };

  return IteratorSeq;
}(IndexedSeq));

// # pragma Helper functions

function isSeq(maybeSeq) {
  return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);
}

var EMPTY_SEQ;

function emptySequence() {
  return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));
}

function keyedSeqFromValue(value) {
  var seq = Array.isArray(value)
    ? new ArraySeq(value)
    : isIterator(value)
        ? new IteratorSeq(value)
        : hasIterator(value) ? new CollectionSeq(value) : undefined;
  if (seq) {
    return seq.fromEntrySeq();
  }
  if (typeof value === 'object') {
    return new ObjectSeq(value);
  }
  throw new TypeError(
    'Expected Array or collection object of [k, v] entries, or keyed object: ' +
      value
  );
}

function indexedSeqFromValue(value) {
  var seq = maybeIndexedSeqFromValue(value);
  if (seq) {
    return seq;
  }
  throw new TypeError(
    'Expected Array or collection object of values: ' + value
  );
}

function seqFromValue(value) {
  var seq = maybeIndexedSeqFromValue(value);
  if (seq) {
    return seq;
  }
  if (typeof value === 'object') {
    return new ObjectSeq(value);
  }
  throw new TypeError(
    'Expected Array or collection object of values, or keyed object: ' + value
  );
}

function maybeIndexedSeqFromValue(value) {
  return isArrayLike(value)
    ? new ArraySeq(value)
    : isIterator(value)
        ? new IteratorSeq(value)
        : hasIterator(value) ? new CollectionSeq(value) : undefined;
}

/**
 * An extension of the "same-value" algorithm as [described for use by ES6 Map
 * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)
 *
 * NaN is considered the same as NaN, however -0 and 0 are considered the same
 * value, which is different from the algorithm described by
 * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).
 *
 * This is extended further to allow Objects to describe the values they
 * represent, by way of `valueOf` or `equals` (and `hashCode`).
 *
 * Note: because of this extension, the key equality of Immutable.Map and the
 * value equality of Immutable.Set will differ from ES6 Map and Set.
 *
 * ### Defining custom values
 *
 * The easiest way to describe the value an object represents is by implementing
 * `valueOf`. For example, `Date` represents a value by returning a unix
 * timestamp for `valueOf`:
 *
 *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...
 *     var date2 = new Date(1234567890000);
 *     date1.valueOf(); // 1234567890000
 *     assert( date1 !== date2 );
 *     assert( Immutable.is( date1, date2 ) );
 *
 * Note: overriding `valueOf` may have other implications if you use this object
 * where JavaScript expects a primitive, such as implicit string coercion.
 *
 * For more complex types, especially collections, implementing `valueOf` may
 * not be performant. An alternative is to implement `equals` and `hashCode`.
 *
 * `equals` takes another object, presumably of similar type, and returns true
 * if it is equal. Equality is symmetrical, so the same result should be
 * returned if this and the argument are flipped.
 *
 *     assert( a.equals(b) === b.equals(a) );
 *
 * `hashCode` returns a 32bit integer number representing the object which will
 * be used to determine how to store the value object in a Map or Set. You must
 * provide both or neither methods, one must not exist without the other.
 *
 * Also, an important relationship between these methods must be upheld: if two
 * values are equal, they *must* return the same hashCode. If the values are not
 * equal, they might have the same hashCode; this is called a hash collision,
 * and while undesirable for performance reasons, it is acceptable.
 *
 *     if (a.equals(b)) {
 *       assert( a.hashCode() === b.hashCode() );
 *     }
 *
 * All Immutable collections are Value Objects: they implement `equals()`
 * and `hashCode()`.
 */
function is(valueA, valueB) {
  if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
    return true;
  }
  if (!valueA || !valueB) {
    return false;
  }
  if (
    typeof valueA.valueOf === 'function' && typeof valueB.valueOf === 'function'
  ) {
    valueA = valueA.valueOf();
    valueB = valueB.valueOf();
    if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
      return true;
    }
    if (!valueA || !valueB) {
      return false;
    }
  }
  return !!(isValueObject(valueA) &&
    isValueObject(valueB) &&
    valueA.equals(valueB));
}

function fromJS(value, converter) {
  return fromJSWith(
    [],
    converter || defaultConverter,
    value,
    '',
    converter && converter.length > 2 ? [] : undefined,
    { '': value }
  );
}

function fromJSWith(stack, converter, value, key, keyPath, parentValue) {
  var toSeq = Array.isArray(value)
    ? IndexedSeq
    : isPlainObj(value) ? KeyedSeq : null;
  if (toSeq) {
    if (~stack.indexOf(value)) {
      throw new TypeError('Cannot convert circular structure to Immutable');
    }
    stack.push(value);
    keyPath && key !== '' && keyPath.push(key);
    var converted = converter.call(
      parentValue,
      key,
      toSeq(value).map(function (v, k) { return fromJSWith(stack, converter, v, k, keyPath, value); }),
      keyPath && keyPath.slice()
    );
    stack.pop();
    keyPath && keyPath.pop();
    return converted;
  }
  return value;
}

function defaultConverter(k, v) {
  return isKeyed(v) ? v.toMap() : v.toList();
}

function isPlainObj(value) {
  return value &&
    (value.constructor === Object || value.constructor === undefined);
}

var imul = typeof Math.imul === 'function' &&
  Math.imul(0xffffffff, 2) === -2
  ? Math.imul
  : function imul(a, b) {
      a |= 0; // int
      b |= 0; // int
      var c = a & 0xffff;
      var d = b & 0xffff;
      // Shift by 0 fixes the sign on the high part.
      return c * d + ((a >>> 16) * d + c * (b >>> 16) << 16 >>> 0) | 0; // int
    };

// v8 has an optimization for storing 31-bit signed numbers.
// Values which have either 00 or 11 as the high order bits qualify.
// This function drops the highest order bit in a signed number, maintaining
// the sign bit.
function smi(i32) {
  return i32 >>> 1 & 0x40000000 | i32 & 0xbfffffff;
}

function hash(o) {
  if (o === false || o === null || o === undefined) {
    return 0;
  }
  if (typeof o.valueOf === 'function') {
    o = o.valueOf();
    if (o === false || o === null || o === undefined) {
      return 0;
    }
  }
  if (o === true) {
    return 1;
  }
  var type = typeof o;
  if (type === 'number') {
    if (o !== o || o === Infinity) {
      return 0;
    }
    var h = o | 0;
    if (h !== o) {
      h ^= o * 0xffffffff;
    }
    while (o > 0xffffffff) {
      o /= 0xffffffff;
      h ^= o;
    }
    return smi(h);
  }
  if (type === 'string') {
    return o.length > STRING_HASH_CACHE_MIN_STRLEN
      ? cachedHashString(o)
      : hashString(o);
  }
  if (typeof o.hashCode === 'function') {
    return o.hashCode();
  }
  if (type === 'object') {
    return hashJSObj(o);
  }
  if (typeof o.toString === 'function') {
    return hashString(o.toString());
  }
  throw new Error('Value type ' + type + ' cannot be hashed.');
}

function cachedHashString(string) {
  var hash = stringHashCache[string];
  if (hash === undefined) {
    hash = hashString(string);
    if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
      STRING_HASH_CACHE_SIZE = 0;
      stringHashCache = {};
    }
    STRING_HASH_CACHE_SIZE++;
    stringHashCache[string] = hash;
  }
  return hash;
}

// http://jsperf.com/hashing-strings
function hashString(string) {
  // This is the hash from JVM
  // The hash code for a string is computed as
  // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],
  // where s[i] is the ith character of the string and n is the length of
  // the string. We "mod" the result to make it between 0 (inclusive) and 2^31
  // (exclusive) by dropping high bits.
  var hash = 0;
  for (var ii = 0; ii < string.length; ii++) {
    hash = 31 * hash + string.charCodeAt(ii) | 0;
  }
  return smi(hash);
}

function hashJSObj(obj) {
  var hash;
  if (usingWeakMap) {
    hash = weakMap.get(obj);
    if (hash !== undefined) {
      return hash;
    }
  }

  hash = obj[UID_HASH_KEY];
  if (hash !== undefined) {
    return hash;
  }

  if (!canDefineProperty) {
    hash = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];
    if (hash !== undefined) {
      return hash;
    }

    hash = getIENodeHash(obj);
    if (hash !== undefined) {
      return hash;
    }
  }

  hash = ++objHashUID;
  if (objHashUID & 0x40000000) {
    objHashUID = 0;
  }

  if (usingWeakMap) {
    weakMap.set(obj, hash);
  } else if (isExtensible !== undefined && isExtensible(obj) === false) {
    throw new Error('Non-extensible objects are not allowed as keys.');
  } else if (canDefineProperty) {
    Object.defineProperty(obj, UID_HASH_KEY, {
      enumerable: false,
      configurable: false,
      writable: false,
      value: hash
    });
  } else if (
    obj.propertyIsEnumerable !== undefined &&
    obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable
  ) {
    // Since we can't define a non-enumerable property on the object
    // we'll hijack one of the less-used non-enumerable properties to
    // save our hash on it. Since this is a function it will not show up in
    // `JSON.stringify` which is what we want.
    obj.propertyIsEnumerable = function() {
      return this.constructor.prototype.propertyIsEnumerable.apply(
        this,
        arguments
      );
    };
    obj.propertyIsEnumerable[UID_HASH_KEY] = hash;
  } else if (obj.nodeType !== undefined) {
    // At this point we couldn't get the IE `uniqueID` to use as a hash
    // and we couldn't use a non-enumerable property to exploit the
    // dontEnum bug so we simply add the `UID_HASH_KEY` on the node
    // itself.
    obj[UID_HASH_KEY] = hash;
  } else {
    throw new Error('Unable to set a non-enumerable property on object.');
  }

  return hash;
}

// Get references to ES5 object methods.
var isExtensible = Object.isExtensible;

// True if Object.defineProperty works as expected. IE8 fails this test.
var canDefineProperty = (function() {
  try {
    Object.defineProperty({}, '@', {});
    return true;
  } catch (e) {
    return false;
  }
})();

// IE has a `uniqueID` property on DOM nodes. We can construct the hash from it
// and avoid memory leaks from the IE cloneNode bug.
function getIENodeHash(node) {
  if (node && node.nodeType > 0) {
    switch (node.nodeType) {
      case 1: // Element
        return node.uniqueID;
      case 9: // Document
        return node.documentElement && node.documentElement.uniqueID;
    }
  }
}

// If possible, use a WeakMap.
var usingWeakMap = typeof WeakMap === 'function';
var weakMap;
if (usingWeakMap) {
  weakMap = new WeakMap();
}

var objHashUID = 0;

var UID_HASH_KEY = '__immutablehash__';
if (typeof Symbol === 'function') {
  UID_HASH_KEY = Symbol(UID_HASH_KEY);
}

var STRING_HASH_CACHE_MIN_STRLEN = 16;
var STRING_HASH_CACHE_MAX_SIZE = 255;
var STRING_HASH_CACHE_SIZE = 0;
var stringHashCache = {};

var ToKeyedSequence = (function (KeyedSeq$$1) {
  function ToKeyedSequence(indexed, useKeys) {
    this._iter = indexed;
    this._useKeys = useKeys;
    this.size = indexed.size;
  }

  if ( KeyedSeq$$1 ) ToKeyedSequence.__proto__ = KeyedSeq$$1;
  ToKeyedSequence.prototype = Object.create( KeyedSeq$$1 && KeyedSeq$$1.prototype );
  ToKeyedSequence.prototype.constructor = ToKeyedSequence;

  ToKeyedSequence.prototype.get = function get (key, notSetValue) {
    return this._iter.get(key, notSetValue);
  };

  ToKeyedSequence.prototype.has = function has (key) {
    return this._iter.has(key);
  };

  ToKeyedSequence.prototype.valueSeq = function valueSeq () {
    return this._iter.valueSeq();
  };

  ToKeyedSequence.prototype.reverse = function reverse () {
    var this$1 = this;

    var reversedSequence = reverseFactory(this, true);
    if (!this._useKeys) {
      reversedSequence.valueSeq = function () { return this$1._iter.toSeq().reverse(); };
    }
    return reversedSequence;
  };

  ToKeyedSequence.prototype.map = function map (mapper, context) {
    var this$1 = this;

    var mappedSequence = mapFactory(this, mapper, context);
    if (!this._useKeys) {
      mappedSequence.valueSeq = function () { return this$1._iter.toSeq().map(mapper, context); };
    }
    return mappedSequence;
  };

  ToKeyedSequence.prototype.__iterate = function __iterate (fn, reverse) {
    var this$1 = this;

    return this._iter.__iterate(function (v, k) { return fn(v, k, this$1); }, reverse);
  };

  ToKeyedSequence.prototype.__iterator = function __iterator (type, reverse) {
    return this._iter.__iterator(type, reverse);
  };

  return ToKeyedSequence;
}(KeyedSeq));
ToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;

var ToIndexedSequence = (function (IndexedSeq$$1) {
  function ToIndexedSequence(iter) {
    this._iter = iter;
    this.size = iter.size;
  }

  if ( IndexedSeq$$1 ) ToIndexedSequence.__proto__ = IndexedSeq$$1;
  ToIndexedSequence.prototype = Object.create( IndexedSeq$$1 && IndexedSeq$$1.prototype );
  ToIndexedSequence.prototype.constructor = ToIndexedSequence;

  ToIndexedSequence.prototype.includes = function includes (value) {
    return this._iter.includes(value);
  };

  ToIndexedSequence.prototype.__iterate = function __iterate (fn, reverse) {
    var this$1 = this;

    var i = 0;
    reverse && ensureSize(this);
    return this._iter.__iterate(
      function (v) { return fn(v, reverse ? this$1.size - ++i : i++, this$1); },
      reverse
    );
  };

  ToIndexedSequence.prototype.__iterator = function __iterator (type, reverse) {
    var this$1 = this;

    var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
    var i = 0;
    reverse && ensureSize(this);
    return new Iterator(function () {
      var step = iterator.next();
      return step.done
        ? step
        : iteratorValue(
            type,
            reverse ? this$1.size - ++i : i++,
            step.value,
            step
          );
    });
  };

  return ToIndexedSequence;
}(IndexedSeq));

var ToSetSequence = (function (SetSeq$$1) {
  function ToSetSequence(iter) {
    this._iter = iter;
    this.size = iter.size;
  }

  if ( SetSeq$$1 ) ToSetSequence.__proto__ = SetSeq$$1;
  ToSetSequence.prototype = Object.create( SetSeq$$1 && SetSeq$$1.prototype );
  ToSetSequence.prototype.constructor = ToSetSequence;

  ToSetSequence.prototype.has = function has (key) {
    return this._iter.includes(key);
  };

  ToSetSequence.prototype.__iterate = function __iterate (fn, reverse) {
    var this$1 = this;

    return this._iter.__iterate(function (v) { return fn(v, v, this$1); }, reverse);
  };

  ToSetSequence.prototype.__iterator = function __iterator (type, reverse) {
    var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
    return new Iterator(function () {
      var step = iterator.next();
      return step.done
        ? step
        : iteratorValue(type, step.value, step.value, step);
    });
  };

  return ToSetSequence;
}(SetSeq));

var FromEntriesSequence = (function (KeyedSeq$$1) {
  function FromEntriesSequence(entries) {
    this._iter = entries;
    this.size = entries.size;
  }

  if ( KeyedSeq$$1 ) FromEntriesSequence.__proto__ = KeyedSeq$$1;
  FromEntriesSequence.prototype = Object.create( KeyedSeq$$1 && KeyedSeq$$1.prototype );
  FromEntriesSequence.prototype.constructor = FromEntriesSequence;

  FromEntriesSequence.prototype.entrySeq = function entrySeq () {
    return this._iter.toSeq();
  };

  FromEntriesSequence.prototype.__iterate = function __iterate (fn, reverse) {
    var this$1 = this;

    return this._iter.__iterate(
      function (entry) {
        // Check if entry exists first so array access doesn't throw for holes
        // in the parent iteration.
        if (entry) {
          validateEntry(entry);
          var indexedCollection = isCollection(entry);
          return fn(
            indexedCollection ? entry.get(1) : entry[1],
            indexedCollection ? entry.get(0) : entry[0],
            this$1
          );
        }
      },
      reverse
    );
  };

  FromEntriesSequence.prototype.__iterator = function __iterator (type, reverse) {
    var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
    return new Iterator(function () {
      while (true) {
        var step = iterator.next();
        if (step.done) {
          return step;
        }
        var entry = step.value;
        // Check if entry exists first so array access doesn't throw for holes
        // in the parent iteration.
        if (entry) {
          validateEntry(entry);
          var indexedCollection = isCollection(entry);
          return iteratorValue(
            type,
            indexedCollection ? entry.get(0) : entry[0],
            indexedCollection ? entry.get(1) : entry[1],
            step
          );
        }
      }
    });
  };

  return FromEntriesSequence;
}(KeyedSeq));

ToIndexedSequence.prototype.cacheResult = (ToKeyedSequence.prototype.cacheResult = (ToSetSequence.prototype.cacheResult = (FromEntriesSequence.prototype.cacheResult = cacheResultThrough)));

function flipFactory(collection) {
  var flipSequence = makeSequence(collection);
  flipSequence._iter = collection;
  flipSequence.size = collection.size;
  flipSequence.flip = function () { return collection; };
  flipSequence.reverse = function() {
    var reversedSequence = collection.reverse.apply(this); // super.reverse()
    reversedSequence.flip = function () { return collection.reverse(); };
    return reversedSequence;
  };
  flipSequence.has = function (key) { return collection.includes(key); };
  flipSequence.includes = function (key) { return collection.has(key); };
  flipSequence.cacheResult = cacheResultThrough;
  flipSequence.__iterateUncached = function(fn, reverse) {
    var this$1 = this;

    return collection.__iterate(function (v, k) { return fn(k, v, this$1) !== false; }, reverse);
  };
  flipSequence.__iteratorUncached = function(type, reverse) {
    if (type === ITERATE_ENTRIES) {
      var iterator = collection.__iterator(type, reverse);
      return new Iterator(function () {
        var step = iterator.next();
        if (!step.done) {
          var k = step.value[0];
          step.value[0] = step.value[1];
          step.value[1] = k;
        }
        return step;
      });
    }
    return collection.__iterator(
      type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,
      reverse
    );
  };
  return flipSequence;
}

function mapFactory(collection, mapper, context) {
  var mappedSequence = makeSequence(collection);
  mappedSequence.size = collection.size;
  mappedSequence.has = function (key) { return collection.has(key); };
  mappedSequence.get = function (key, notSetValue) {
    var v = collection.get(key, NOT_SET);
    return v === NOT_SET
      ? notSetValue
      : mapper.call(context, v, key, collection);
  };
  mappedSequence.__iterateUncached = function(fn, reverse) {
    var this$1 = this;

    return collection.__iterate(
      function (v, k, c) { return fn(mapper.call(context, v, k, c), k, this$1) !== false; },
      reverse
    );
  };
  mappedSequence.__iteratorUncached = function(type, reverse) {
    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);
    return new Iterator(function () {
      var step = iterator.next();
      if (step.done) {
        return step;
      }
      var entry = step.value;
      var key = entry[0];
      return iteratorValue(
        type,
        key,
        mapper.call(context, entry[1], key, collection),
        step
      );
    });
  };
  return mappedSequence;
}

function reverseFactory(collection, useKeys) {
  var this$1 = this;

  var reversedSequence = makeSequence(collection);
  reversedSequence._iter = collection;
  reversedSequence.size = collection.size;
  reversedSequence.reverse = function () { return collection; };
  if (collection.flip) {
    reversedSequence.flip = function() {
      var flipSequence = flipFactory(collection);
      flipSequence.reverse = function () { return collection.flip(); };
      return flipSequence;
    };
  }
  reversedSequence.get = function (key, notSetValue) { return collection.get(useKeys ? key : -1 - key, notSetValue); };
  reversedSequence.has = function (key) { return collection.has(useKeys ? key : -1 - key); };
  reversedSequence.includes = function (value) { return collection.includes(value); };
  reversedSequence.cacheResult = cacheResultThrough;
  reversedSequence.__iterate = function(fn, reverse) {
    var this$1 = this;

    var i = 0;
    reverse && ensureSize(collection);
    return collection.__iterate(
      function (v, k) { return fn(v, useKeys ? k : reverse ? this$1.size - ++i : i++, this$1); },
      !reverse
    );
  };
  reversedSequence.__iterator = function (type, reverse) {
    var i = 0;
    reverse && ensureSize(collection);
    var iterator = collection.__iterator(ITERATE_ENTRIES, !reverse);
    return new Iterator(function () {
      var step = iterator.next();
      if (step.done) {
        return step;
      }
      var entry = step.value;
      return iteratorValue(
        type,
        useKeys ? entry[0] : reverse ? this$1.size - ++i : i++,
        entry[1],
        step
      );
    });
  };
  return reversedSequence;
}

function filterFactory(collection, predicate, context, useKeys) {
  var filterSequence = makeSequence(collection);
  if (useKeys) {
    filterSequence.has = function (key) {
      var v = collection.get(key, NOT_SET);
      return v !== NOT_SET && !!predicate.call(context, v, key, collection);
    };
    filterSequence.get = function (key, notSetValue) {
      var v = collection.get(key, NOT_SET);
      return v !== NOT_SET && predicate.call(context, v, key, collection)
        ? v
        : notSetValue;
    };
  }
  filterSequence.__iterateUncached = function(fn, reverse) {
    var this$1 = this;

    var iterations = 0;
    collection.__iterate(
      function (v, k, c) {
        if (predicate.call(context, v, k, c)) {
          return fn(v, useKeys ? k : iterations++, this$1);
        }
      },
      reverse
    );
    return iterations;
  };
  filterSequence.__iteratorUncached = function(type, reverse) {
    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);
    var iterations = 0;
    return new Iterator(function () {
      while (true) {
        var step = iterator.next();
        if (step.done) {
          return step;
        }
        var entry = step.value;
        var key = entry[0];
        var value = entry[1];
        if (predicate.call(context, value, key, collection)) {
          return iteratorValue(type, useKeys ? key : iterations++, value, step);
        }
      }
    });
  };
  return filterSequence;
}

function countByFactory(collection, grouper, context) {
  var groups = Map().asMutable();
  collection.__iterate(function (v, k) {
    groups.update(grouper.call(context, v, k, collection), 0, function (a) { return a + 1; });
  });
  return groups.asImmutable();
}

function groupByFactory(collection, grouper, context) {
  var isKeyedIter = isKeyed(collection);
  var groups = (isOrdered(collection) ? OrderedMap() : Map()).asMutable();
  collection.__iterate(function (v, k) {
    groups.update(
      grouper.call(context, v, k, collection),
      function (a) { return ((a = a || []), a.push(isKeyedIter ? [k, v] : v), a); }
    );
  });
  var coerce = collectionClass(collection);
  return groups.map(function (arr) { return reify(collection, coerce(arr)); });
}

function sliceFactory(collection, begin, end, useKeys) {
  var originalSize = collection.size;

  if (wholeSlice(begin, end, originalSize)) {
    return collection;
  }

  var resolvedBegin = resolveBegin(begin, originalSize);
  var resolvedEnd = resolveEnd(end, originalSize);

  // begin or end will be NaN if they were provided as negative numbers and
  // this collection's size is unknown. In that case, cache first so there is
  // a known size and these do not resolve to NaN.
  if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {
    return sliceFactory(collection.toSeq().cacheResult(), begin, end, useKeys);
  }

  // Note: resolvedEnd is undefined when the original sequence's length is
  // unknown and this slice did not supply an end and should contain all
  // elements after resolvedBegin.
  // In that case, resolvedSize will be NaN and sliceSize will remain undefined.
  var resolvedSize = resolvedEnd - resolvedBegin;
  var sliceSize;
  if (resolvedSize === resolvedSize) {
    sliceSize = resolvedSize < 0 ? 0 : resolvedSize;
  }

  var sliceSeq = makeSequence(collection);

  // If collection.size is undefined, the size of the realized sliceSeq is
  // unknown at this point unless the number of items to slice is 0
  sliceSeq.size = sliceSize === 0
    ? sliceSize
    : (collection.size && sliceSize) || undefined;

  if (!useKeys && isSeq(collection) && sliceSize >= 0) {
    sliceSeq.get = function(index, notSetValue) {
      index = wrapIndex(this, index);
      return index >= 0 && index < sliceSize
        ? collection.get(index + resolvedBegin, notSetValue)
        : notSetValue;
    };
  }

  sliceSeq.__iterateUncached = function(fn, reverse) {
    var this$1 = this;

    if (sliceSize === 0) {
      return 0;
    }
    if (reverse) {
      return this.cacheResult().__iterate(fn, reverse);
    }
    var skipped = 0;
    var isSkipping = true;
    var iterations = 0;
    collection.__iterate(function (v, k) {
      if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
        iterations++;
        return fn(v, useKeys ? k : iterations - 1, this$1) !== false &&
          iterations !== sliceSize;
      }
    });
    return iterations;
  };

  sliceSeq.__iteratorUncached = function(type, reverse) {
    if (sliceSize !== 0 && reverse) {
      return this.cacheResult().__iterator(type, reverse);
    }
    // Don't bother instantiating parent iterator if taking 0.
    var iterator = sliceSize !== 0 && collection.__iterator(type, reverse);
    var skipped = 0;
    var iterations = 0;
    return new Iterator(function () {
      while (skipped++ < resolvedBegin) {
        iterator.next();
      }
      if (++iterations > sliceSize) {
        return iteratorDone();
      }
      var step = iterator.next();
      if (useKeys || type === ITERATE_VALUES) {
        return step;
      }
      if (type === ITERATE_KEYS) {
        return iteratorValue(type, iterations - 1, undefined, step);
      }
      return iteratorValue(type, iterations - 1, step.value[1], step);
    });
  };

  return sliceSeq;
}

function takeWhileFactory(collection, predicate, context) {
  var takeSequence = makeSequence(collection);
  takeSequence.__iterateUncached = function(fn, reverse) {
    var this$1 = this;

    if (reverse) {
      return this.cacheResult().__iterate(fn, reverse);
    }
    var iterations = 0;
    collection.__iterate(
      function (v, k, c) { return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$1); }
    );
    return iterations;
  };
  takeSequence.__iteratorUncached = function(type, reverse) {
    var this$1 = this;

    if (reverse) {
      return this.cacheResult().__iterator(type, reverse);
    }
    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);
    var iterating = true;
    return new Iterator(function () {
      if (!iterating) {
        return iteratorDone();
      }
      var step = iterator.next();
      if (step.done) {
        return step;
      }
      var entry = step.value;
      var k = entry[0];
      var v = entry[1];
      if (!predicate.call(context, v, k, this$1)) {
        iterating = false;
        return iteratorDone();
      }
      return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);
    });
  };
  return takeSequence;
}

function skipWhileFactory(collection, predicate, context, useKeys) {
  var skipSequence = makeSequence(collection);
  skipSequence.__iterateUncached = function(fn, reverse) {
    var this$1 = this;

    if (reverse) {
      return this.cacheResult().__iterate(fn, reverse);
    }
    var isSkipping = true;
    var iterations = 0;
    collection.__iterate(function (v, k, c) {
      if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {
        iterations++;
        return fn(v, useKeys ? k : iterations - 1, this$1);
      }
    });
    return iterations;
  };
  skipSequence.__iteratorUncached = function(type, reverse) {
    var this$1 = this;

    if (reverse) {
      return this.cacheResult().__iterator(type, reverse);
    }
    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);
    var skipping = true;
    var iterations = 0;
    return new Iterator(function () {
      var step;
      var k;
      var v;
      do {
        step = iterator.next();
        if (step.done) {
          if (useKeys || type === ITERATE_VALUES) {
            return step;
          }
          if (type === ITERATE_KEYS) {
            return iteratorValue(type, iterations++, undefined, step);
          }
          return iteratorValue(type, iterations++, step.value[1], step);
        }
        var entry = step.value;
        k = entry[0];
        v = entry[1];
        skipping && (skipping = predicate.call(context, v, k, this$1));
      } while (skipping);
      return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);
    });
  };
  return skipSequence;
}

function concatFactory(collection, values) {
  var isKeyedCollection = isKeyed(collection);
  var iters = [collection]
    .concat(values)
    .map(function (v) {
      if (!isCollection(v)) {
        v = isKeyedCollection
          ? keyedSeqFromValue(v)
          : indexedSeqFromValue(Array.isArray(v) ? v : [v]);
      } else if (isKeyedCollection) {
        v = KeyedCollection(v);
      }
      return v;
    })
    .filter(function (v) { return v.size !== 0; });

  if (iters.length === 0) {
    return collection;
  }

  if (iters.length === 1) {
    var singleton = iters[0];
    if (
      singleton === collection ||
      (isKeyedCollection && isKeyed(singleton)) ||
      (isIndexed(collection) && isIndexed(singleton))
    ) {
      return singleton;
    }
  }

  var concatSeq = new ArraySeq(iters);
  if (isKeyedCollection) {
    concatSeq = concatSeq.toKeyedSeq();
  } else if (!isIndexed(collection)) {
    concatSeq = concatSeq.toSetSeq();
  }
  concatSeq = concatSeq.flatten(true);
  concatSeq.size = iters.reduce(
    function (sum, seq) {
      if (sum !== undefined) {
        var size = seq.size;
        if (size !== undefined) {
          return sum + size;
        }
      }
    },
    0
  );
  return concatSeq;
}

function flattenFactory(collection, depth, useKeys) {
  var flatSequence = makeSequence(collection);
  flatSequence.__iterateUncached = function(fn, reverse) {
    if (reverse) {
      return this.cacheResult().__iterate(fn, reverse);
    }
    var iterations = 0;
    var stopped = false;
    function flatDeep(iter, currentDepth) {
      iter.__iterate(
        function (v, k) {
          if ((!depth || currentDepth < depth) && isCollection(v)) {
            flatDeep(v, currentDepth + 1);
          } else if (
            fn(v, useKeys ? k : iterations++, flatSequence) === false
          ) {
            stopped = true;
          }
          return !stopped;
        },
        reverse
      );
    }
    flatDeep(collection, 0);
    return iterations;
  };
  flatSequence.__iteratorUncached = function(type, reverse) {
    if (reverse) {
      return this.cacheResult().__iterator(type, reverse);
    }
    var iterator = collection.__iterator(type, reverse);
    var stack = [];
    var iterations = 0;
    return new Iterator(function () {
      while (iterator) {
        var step = iterator.next();
        if (step.done !== false) {
          iterator = stack.pop();
          continue;
        }
        var v = step.value;
        if (type === ITERATE_ENTRIES) {
          v = v[1];
        }
        if ((!depth || stack.length < depth) && isCollection(v)) {
          stack.push(iterator);
          iterator = v.__iterator(type, reverse);
        } else {
          return useKeys ? step : iteratorValue(type, iterations++, v, step);
        }
      }
      return iteratorDone();
    });
  };
  return flatSequence;
}

function flatMapFactory(collection, mapper, context) {
  var coerce = collectionClass(collection);
  return collection
    .toSeq()
    .map(function (v, k) { return coerce(mapper.call(context, v, k, collection)); })
    .flatten(true);
}

function interposeFactory(collection, separator) {
  var interposedSequence = makeSequence(collection);
  interposedSequence.size = collection.size && collection.size * 2 - 1;
  interposedSequence.__iterateUncached = function(fn, reverse) {
    var this$1 = this;

    var iterations = 0;
    collection.__iterate(
      function (v) { return (!iterations || fn(separator, iterations++, this$1) !== false) &&
        fn(v, iterations++, this$1) !== false; },
      reverse
    );
    return iterations;
  };
  interposedSequence.__iteratorUncached = function(type, reverse) {
    var iterator = collection.__iterator(ITERATE_VALUES, reverse);
    var iterations = 0;
    var step;
    return new Iterator(function () {
      if (!step || iterations % 2) {
        step = iterator.next();
        if (step.done) {
          return step;
        }
      }
      return iterations % 2
        ? iteratorValue(type, iterations++, separator)
        : iteratorValue(type, iterations++, step.value, step);
    });
  };
  return interposedSequence;
}

function sortFactory(collection, comparator, mapper) {
  if (!comparator) {
    comparator = defaultComparator;
  }
  var isKeyedCollection = isKeyed(collection);
  var index = 0;
  var entries = collection
    .toSeq()
    .map(function (v, k) { return [k, v, index++, mapper ? mapper(v, k, collection) : v]; })
    .toArray();
  entries.sort(function (a, b) { return comparator(a[3], b[3]) || a[2] - b[2]; }).forEach(
    isKeyedCollection
      ? function (v, i) {
          entries[i].length = 2;
        }
      : function (v, i) {
          entries[i] = v[1];
        }
  );
  return isKeyedCollection
    ? KeyedSeq(entries)
    : isIndexed(collection) ? IndexedSeq(entries) : SetSeq(entries);
}

function maxFactory(collection, comparator, mapper) {
  if (!comparator) {
    comparator = defaultComparator;
  }
  if (mapper) {
    var entry = collection
      .toSeq()
      .map(function (v, k) { return [v, mapper(v, k, collection)]; })
      .reduce(function (a, b) { return maxCompare(comparator, a[1], b[1]) ? b : a; });
    return entry && entry[0];
  }
  return collection.reduce(function (a, b) { return maxCompare(comparator, a, b) ? b : a; });
}

function maxCompare(comparator, a, b) {
  var comp = comparator(b, a);
  // b is considered the new max if the comparator declares them equal, but
  // they are not equal and b is in fact a nullish value.
  return (comp === 0 &&
    b !== a &&
    (b === undefined || b === null || b !== b)) ||
    comp > 0;
}

function zipWithFactory(keyIter, zipper, iters) {
  var zipSequence = makeSequence(keyIter);
  zipSequence.size = new ArraySeq(iters).map(function (i) { return i.size; }).min();
  // Note: this a generic base implementation of __iterate in terms of
  // __iterator which may be more generically useful in the future.
  zipSequence.__iterate = function(fn, reverse) {
    var this$1 = this;

    /* generic:
    var iterator = this.__iterator(ITERATE_ENTRIES, reverse);
    var step;
    var iterations = 0;
    while (!(step = iterator.next()).done) {
      iterations++;
      if (fn(step.value[1], step.value[0], this) === false) {
        break;
      }
    }
    return iterations;
    */
    // indexed:
    var iterator = this.__iterator(ITERATE_VALUES, reverse);
    var step;
    var iterations = 0;
    while (!(step = iterator.next()).done) {
      if (fn(step.value, iterations++, this$1) === false) {
        break;
      }
    }
    return iterations;
  };
  zipSequence.__iteratorUncached = function(type, reverse) {
    var iterators = iters.map(
      function (i) { return ((i = Collection(i)), getIterator(reverse ? i.reverse() : i)); }
    );
    var iterations = 0;
    var isDone = false;
    return new Iterator(function () {
      var steps;
      if (!isDone) {
        steps = iterators.map(function (i) { return i.next(); });
        isDone = steps.some(function (s) { return s.done; });
      }
      if (isDone) {
        return iteratorDone();
      }
      return iteratorValue(
        type,
        iterations++,
        zipper.apply(null, steps.map(function (s) { return s.value; }))
      );
    });
  };
  return zipSequence;
}

// #pragma Helper Functions

function reify(iter, seq) {
  return iter === seq ? iter : isSeq(iter) ? seq : iter.constructor(seq);
}

function validateEntry(entry) {
  if (entry !== Object(entry)) {
    throw new TypeError('Expected [K, V] tuple: ' + entry);
  }
}

function collectionClass(collection) {
  return isKeyed(collection)
    ? KeyedCollection
    : isIndexed(collection) ? IndexedCollection : SetCollection;
}

function makeSequence(collection) {
  return Object.create(
    (isKeyed(collection)
      ? KeyedSeq
      : isIndexed(collection) ? IndexedSeq : SetSeq).prototype
  );
}

function cacheResultThrough() {
  if (this._iter.cacheResult) {
    this._iter.cacheResult();
    this.size = this._iter.size;
    return this;
  }
  return Seq.prototype.cacheResult.call(this);
}

function defaultComparator(a, b) {
  if (a === undefined && b === undefined) {
    return 0;
  }

  if (a === undefined) {
    return 1;
  }

  if (b === undefined) {
    return -1;
  }

  return a > b ? 1 : a < b ? -1 : 0;
}

function coerceKeyPath(keyPath) {
  if (isArrayLike(keyPath) && typeof keyPath !== 'string') {
    return keyPath;
  }
  if (isOrdered(keyPath)) {
    return keyPath.toArray();
  }
  throw new TypeError(
    'Invalid keyPath: expected Ordered Collection or Array: ' + keyPath
  );
}

function invariant(condition, error) {
  if (!condition) { throw new Error(error); }
}

function assertNotInfinite(size) {
  invariant(
    size !== Infinity,
    'Cannot perform this action with an infinite size.'
  );
}

/**
 * Converts a value to a string, adding quotes if a string was provided.
 */
function quoteString(value) {
  return typeof value === 'string' ? JSON.stringify(value) : String(value);
}

var Map = (function (KeyedCollection$$1) {
  function Map(value) {
    return value === null || value === undefined
      ? emptyMap()
      : isMap(value) && !isOrdered(value)
          ? value
          : emptyMap().withMutations(function (map) {
              var iter = KeyedCollection$$1(value);
              assertNotInfinite(iter.size);
              iter.forEach(function (v, k) { return map.set(k, v); });
            });
  }

  if ( KeyedCollection$$1 ) Map.__proto__ = KeyedCollection$$1;
  Map.prototype = Object.create( KeyedCollection$$1 && KeyedCollection$$1.prototype );
  Map.prototype.constructor = Map;

  Map.of = function of () {
    var keyValues = [], len = arguments.length;
    while ( len-- ) keyValues[ len ] = arguments[ len ];

    return emptyMap().withMutations(function (map) {
      for (var i = 0; i < keyValues.length; i += 2) {
        if (i + 1 >= keyValues.length) {
          throw new Error('Missing value for key: ' + keyValues[i]);
        }
        map.set(keyValues[i], keyValues[i + 1]);
      }
    });
  };

  Map.prototype.toString = function toString () {
    return this.__toString('Map {', '}');
  };

  // @pragma Access

  Map.prototype.get = function get (k, notSetValue) {
    return this._root
      ? this._root.get(0, undefined, k, notSetValue)
      : notSetValue;
  };

  // @pragma Modification

  Map.prototype.set = function set (k, v) {
    return updateMap(this, k, v);
  };

  Map.prototype.setIn = function setIn (keyPath, v) {
    return this.updateIn(keyPath, NOT_SET, function () { return v; });
  };

  Map.prototype.remove = function remove (k) {
    return updateMap(this, k, NOT_SET);
  };

  Map.prototype.deleteIn = function deleteIn (keyPath) {
    keyPath = [].concat( coerceKeyPath(keyPath) );
    if (keyPath.length) {
      var lastKey = keyPath.pop();
      return this.updateIn(keyPath, function (c) { return c && c.remove(lastKey); });
    }
  };

  Map.prototype.deleteAll = function deleteAll (keys) {
    var collection = Collection(keys);

    if (collection.size === 0) {
      return this;
    }

    return this.withMutations(function (map) {
      collection.forEach(function (key) { return map.remove(key); });
    });
  };

  Map.prototype.update = function update (k, notSetValue, updater) {
    return arguments.length === 1
      ? k(this)
      : this.updateIn([k], notSetValue, updater);
  };

  Map.prototype.updateIn = function updateIn (keyPath, notSetValue, updater) {
    if (!updater) {
      updater = notSetValue;
      notSetValue = undefined;
    }
    var updatedValue = updateInDeepMap(
      this,
      coerceKeyPath(keyPath),
      0,
      notSetValue,
      updater
    );
    return updatedValue === NOT_SET ? notSetValue : updatedValue;
  };

  Map.prototype.clear = function clear () {
    if (this.size === 0) {
      return this;
    }
    if (this.__ownerID) {
      this.size = 0;
      this._root = null;
      this.__hash = undefined;
      this.__altered = true;
      return this;
    }
    return emptyMap();
  };

  // @pragma Composition

  Map.prototype.merge = function merge (/*...iters*/) {
    return mergeIntoMapWith(this, undefined, arguments);
  };

  Map.prototype.mergeWith = function mergeWith (merger) {
    var iters = [], len = arguments.length - 1;
    while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];

    return mergeIntoMapWith(this, merger, iters);
  };

  Map.prototype.mergeIn = function mergeIn (keyPath) {
    var iters = [], len = arguments.length - 1;
    while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];

    return this.updateIn(
      keyPath,
      emptyMap(),
      function (m) { return typeof m.merge === 'function'
          ? m.merge.apply(m, iters)
          : iters[iters.length - 1]; }
    );
  };

  Map.prototype.mergeDeep = function mergeDeep (/*...iters*/) {
    return mergeIntoMapWith(this, deepMerger, arguments);
  };

  Map.prototype.mergeDeepWith = function mergeDeepWith (merger) {
    var iters = [], len = arguments.length - 1;
    while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];

    return mergeIntoMapWith(this, deepMergerWith(merger), iters);
  };

  Map.prototype.mergeDeepIn = function mergeDeepIn (keyPath) {
    var iters = [], len = arguments.length - 1;
    while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];

    return this.updateIn(
      keyPath,
      emptyMap(),
      function (m) { return typeof m.mergeDeep === 'function'
          ? m.mergeDeep.apply(m, iters)
          : iters[iters.length - 1]; }
    );
  };

  Map.prototype.sort = function sort (comparator) {
    // Late binding
    return OrderedMap(sortFactory(this, comparator));
  };

  Map.prototype.sortBy = function sortBy (mapper, comparator) {
    // Late binding
    return OrderedMap(sortFactory(this, comparator, mapper));
  };

  // @pragma Mutability

  Map.prototype.withMutations = function withMutations (fn) {
    var mutable = this.asMutable();
    fn(mutable);
    return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
  };

  Map.prototype.asMutable = function asMutable () {
    return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
  };

  Map.prototype.asImmutable = function asImmutable () {
    return this.__ensureOwner();
  };

  Map.prototype.wasAltered = function wasAltered () {
    return this.__altered;
  };

  Map.prototype.__iterator = function __iterator (type, reverse) {
    return new MapIterator(this, type, reverse);
  };

  Map.prototype.__iterate = function __iterate (fn, reverse) {
    var this$1 = this;

    var iterations = 0;
    this._root &&
      this._root.iterate(
        function (entry) {
          iterations++;
          return fn(entry[1], entry[0], this$1);
        },
        reverse
      );
    return iterations;
  };

  Map.prototype.__ensureOwner = function __ensureOwner (ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }
    if (!ownerID) {
      if (this.size === 0) {
        return emptyMap();
      }
      this.__ownerID = ownerID;
      this.__altered = false;
      return this;
    }
    return makeMap(this.size, this._root, ownerID, this.__hash);
  };

  return Map;
}(KeyedCollection));

function isMap(maybeMap) {
  return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);
}

Map.isMap = isMap;

var IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';

var MapPrototype = Map.prototype;
MapPrototype[IS_MAP_SENTINEL] = true;
MapPrototype[DELETE] = MapPrototype.remove;
MapPrototype.removeIn = MapPrototype.deleteIn;
MapPrototype.removeAll = MapPrototype.deleteAll;

// #pragma Trie Nodes

var ArrayMapNode = function ArrayMapNode(ownerID, entries) {
  this.ownerID = ownerID;
  this.entries = entries;
};

ArrayMapNode.prototype.get = function get (shift, keyHash, key, notSetValue) {
  var entries = this.entries;
  for (var ii = 0, len = entries.length; ii < len; ii++) {
    if (is(key, entries[ii][0])) {
      return entries[ii][1];
    }
  }
  return notSetValue;
};

ArrayMapNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
  var removed = value === NOT_SET;

  var entries = this.entries;
  var idx = 0;
  var len = entries.length;
  for (; idx < len; idx++) {
    if (is(key, entries[idx][0])) {
      break;
    }
  }
  var exists = idx < len;

  if (exists ? entries[idx][1] === value : removed) {
    return this;
  }

  SetRef(didAlter);
  (removed || !exists) && SetRef(didChangeSize);

  if (removed && entries.length === 1) {
    return; // undefined
  }

  if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {
    return createNodes(ownerID, entries, key, value);
  }

  var isEditable = ownerID && ownerID === this.ownerID;
  var newEntries = isEditable ? entries : arrCopy(entries);

  if (exists) {
    if (removed) {
      idx === len - 1
        ? newEntries.pop()
        : (newEntries[idx] = newEntries.pop());
    } else {
      newEntries[idx] = [key, value];
    }
  } else {
    newEntries.push([key, value]);
  }

  if (isEditable) {
    this.entries = newEntries;
    return this;
  }

  return new ArrayMapNode(ownerID, newEntries);
};

var BitmapIndexedNode = function BitmapIndexedNode(ownerID, bitmap, nodes) {
  this.ownerID = ownerID;
  this.bitmap = bitmap;
  this.nodes = nodes;
};

BitmapIndexedNode.prototype.get = function get (shift, keyHash, key, notSetValue) {
  if (keyHash === undefined) {
    keyHash = hash(key);
  }
  var bit = 1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK);
  var bitmap = this.bitmap;
  return (bitmap & bit) === 0
    ? notSetValue
    : this.nodes[popCount(bitmap & bit - 1)].get(
        shift + SHIFT,
        keyHash,
        key,
        notSetValue
      );
};

BitmapIndexedNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
  if (keyHash === undefined) {
    keyHash = hash(key);
  }
  var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
  var bit = 1 << keyHashFrag;
  var bitmap = this.bitmap;
  var exists = (bitmap & bit) !== 0;

  if (!exists && value === NOT_SET) {
    return this;
  }

  var idx = popCount(bitmap & bit - 1);
  var nodes = this.nodes;
  var node = exists ? nodes[idx] : undefined;
  var newNode = updateNode(
    node,
    ownerID,
    shift + SHIFT,
    keyHash,
    key,
    value,
    didChangeSize,
    didAlter
  );

  if (newNode === node) {
    return this;
  }

  if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
    return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
  }

  if (
    exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])
  ) {
    return nodes[idx ^ 1];
  }

  if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
    return newNode;
  }

  var isEditable = ownerID && ownerID === this.ownerID;
  var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
  var newNodes = exists
    ? newNode
        ? setIn(nodes, idx, newNode, isEditable)
        : spliceOut(nodes, idx, isEditable)
    : spliceIn(nodes, idx, newNode, isEditable);

  if (isEditable) {
    this.bitmap = newBitmap;
    this.nodes = newNodes;
    return this;
  }

  return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
};

var HashArrayMapNode = function HashArrayMapNode(ownerID, count, nodes) {
  this.ownerID = ownerID;
  this.count = count;
  this.nodes = nodes;
};

HashArrayMapNode.prototype.get = function get (shift, keyHash, key, notSetValue) {
  if (keyHash === undefined) {
    keyHash = hash(key);
  }
  var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
  var node = this.nodes[idx];
  return node
    ? node.get(shift + SHIFT, keyHash, key, notSetValue)
    : notSetValue;
};

HashArrayMapNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
  if (keyHash === undefined) {
    keyHash = hash(key);
  }
  var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
  var removed = value === NOT_SET;
  var nodes = this.nodes;
  var node = nodes[idx];

  if (removed && !node) {
    return this;
  }

  var newNode = updateNode(
    node,
    ownerID,
    shift + SHIFT,
    keyHash,
    key,
    value,
    didChangeSize,
    didAlter
  );
  if (newNode === node) {
    return this;
  }

  var newCount = this.count;
  if (!node) {
    newCount++;
  } else if (!newNode) {
    newCount--;
    if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
      return packNodes(ownerID, nodes, newCount, idx);
    }
  }

  var isEditable = ownerID && ownerID === this.ownerID;
  var newNodes = setIn(nodes, idx, newNode, isEditable);

  if (isEditable) {
    this.count = newCount;
    this.nodes = newNodes;
    return this;
  }

  return new HashArrayMapNode(ownerID, newCount, newNodes);
};

var HashCollisionNode = function HashCollisionNode(ownerID, keyHash, entries) {
  this.ownerID = ownerID;
  this.keyHash = keyHash;
  this.entries = entries;
};

HashCollisionNode.prototype.get = function get (shift, keyHash, key, notSetValue) {
  var entries = this.entries;
  for (var ii = 0, len = entries.length; ii < len; ii++) {
    if (is(key, entries[ii][0])) {
      return entries[ii][1];
    }
  }
  return notSetValue;
};

HashCollisionNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
  if (keyHash === undefined) {
    keyHash = hash(key);
  }

  var removed = value === NOT_SET;

  if (keyHash !== this.keyHash) {
    if (removed) {
      return this;
    }
    SetRef(didAlter);
    SetRef(didChangeSize);
    return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);
  }

  var entries = this.entries;
  var idx = 0;
  var len = entries.length;
  for (; idx < len; idx++) {
    if (is(key, entries[idx][0])) {
      break;
    }
  }
  var exists = idx < len;

  if (exists ? entries[idx][1] === value : removed) {
    return this;
  }

  SetRef(didAlter);
  (removed || !exists) && SetRef(didChangeSize);

  if (removed && len === 2) {
    return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);
  }

  var isEditable = ownerID && ownerID === this.ownerID;
  var newEntries = isEditable ? entries : arrCopy(entries);

  if (exists) {
    if (removed) {
      idx === len - 1
        ? newEntries.pop()
        : (newEntries[idx] = newEntries.pop());
    } else {
      newEntries[idx] = [key, value];
    }
  } else {
    newEntries.push([key, value]);
  }

  if (isEditable) {
    this.entries = newEntries;
    return this;
  }

  return new HashCollisionNode(ownerID, this.keyHash, newEntries);
};

var ValueNode = function ValueNode(ownerID, keyHash, entry) {
  this.ownerID = ownerID;
  this.keyHash = keyHash;
  this.entry = entry;
};

ValueNode.prototype.get = function get (shift, keyHash, key, notSetValue) {
  return is(key, this.entry[0]) ? this.entry[1] : notSetValue;
};

ValueNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
  var removed = value === NOT_SET;
  var keyMatch = is(key, this.entry[0]);
  if (keyMatch ? value === this.entry[1] : removed) {
    return this;
  }

  SetRef(didAlter);

  if (removed) {
    SetRef(didChangeSize);
    return; // undefined
  }

  if (keyMatch) {
    if (ownerID && ownerID === this.ownerID) {
      this.entry[1] = value;
      return this;
    }
    return new ValueNode(ownerID, this.keyHash, [key, value]);
  }

  SetRef(didChangeSize);
  return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);
};

// #pragma Iterators

ArrayMapNode.prototype.iterate = (HashCollisionNode.prototype.iterate = function(
  fn,
  reverse
) {
  var entries = this.entries;
  for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {
    if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {
      return false;
    }
  }
});

BitmapIndexedNode.prototype.iterate = (HashArrayMapNode.prototype.iterate = function(
  fn,
  reverse
) {
  var nodes = this.nodes;
  for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
    var node = nodes[reverse ? maxIndex - ii : ii];
    if (node && node.iterate(fn, reverse) === false) {
      return false;
    }
  }
});

// eslint-disable-next-line no-unused-vars
ValueNode.prototype.iterate = function(fn, reverse) {
  return fn(this.entry);
};

var MapIterator = (function (Iterator$$1) {
  function MapIterator(map, type, reverse) {
    this._type = type;
    this._reverse = reverse;
    this._stack = map._root && mapIteratorFrame(map._root);
  }

  if ( Iterator$$1 ) MapIterator.__proto__ = Iterator$$1;
  MapIterator.prototype = Object.create( Iterator$$1 && Iterator$$1.prototype );
  MapIterator.prototype.constructor = MapIterator;

  MapIterator.prototype.next = function next () {
    var this$1 = this;

    var type = this._type;
    var stack = this._stack;
    while (stack) {
      var node = stack.node;
      var index = stack.index++;
      var maxIndex = (void 0);
      if (node.entry) {
        if (index === 0) {
          return mapIteratorValue(type, node.entry);
        }
      } else if (node.entries) {
        maxIndex = node.entries.length - 1;
        if (index <= maxIndex) {
          return mapIteratorValue(
            type,
            node.entries[this$1._reverse ? maxIndex - index : index]
          );
        }
      } else {
        maxIndex = node.nodes.length - 1;
        if (index <= maxIndex) {
          var subNode = node.nodes[this$1._reverse ? maxIndex - index : index];
          if (subNode) {
            if (subNode.entry) {
              return mapIteratorValue(type, subNode.entry);
            }
            stack = (this$1._stack = mapIteratorFrame(subNode, stack));
          }
          continue;
        }
      }
      stack = (this$1._stack = this$1._stack.__prev);
    }
    return iteratorDone();
  };

  return MapIterator;
}(Iterator));

function mapIteratorValue(type, entry) {
  return iteratorValue(type, entry[0], entry[1]);
}

function mapIteratorFrame(node, prev) {
  return {
    node: node,
    index: 0,
    __prev: prev
  };
}

function makeMap(size, root, ownerID, hash$$1) {
  var map = Object.create(MapPrototype);
  map.size = size;
  map._root = root;
  map.__ownerID = ownerID;
  map.__hash = hash$$1;
  map.__altered = false;
  return map;
}

var EMPTY_MAP;
function emptyMap() {
  return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
}

function updateMap(map, k, v) {
  var newRoot;
  var newSize;
  if (!map._root) {
    if (v === NOT_SET) {
      return map;
    }
    newSize = 1;
    newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);
  } else {
    var didChangeSize = MakeRef(CHANGE_LENGTH);
    var didAlter = MakeRef(DID_ALTER);
    newRoot = updateNode(
      map._root,
      map.__ownerID,
      0,
      undefined,
      k,
      v,
      didChangeSize,
      didAlter
    );
    if (!didAlter.value) {
      return map;
    }
    newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);
  }
  if (map.__ownerID) {
    map.size = newSize;
    map._root = newRoot;
    map.__hash = undefined;
    map.__altered = true;
    return map;
  }
  return newRoot ? makeMap(newSize, newRoot) : emptyMap();
}

function updateNode(
  node,
  ownerID,
  shift,
  keyHash,
  key,
  value,
  didChangeSize,
  didAlter
) {
  if (!node) {
    if (value === NOT_SET) {
      return node;
    }
    SetRef(didAlter);
    SetRef(didChangeSize);
    return new ValueNode(ownerID, keyHash, [key, value]);
  }
  return node.update(
    ownerID,
    shift,
    keyHash,
    key,
    value,
    didChangeSize,
    didAlter
  );
}

function isLeafNode(node) {
  return node.constructor === ValueNode ||
    node.constructor === HashCollisionNode;
}

function mergeIntoNode(node, ownerID, shift, keyHash, entry) {
  if (node.keyHash === keyHash) {
    return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);
  }

  var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;
  var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;

  var newNode;
  var nodes = idx1 === idx2
    ? [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)]
    : ((newNode = new ValueNode(ownerID, keyHash, entry)), idx1 < idx2
        ? [node, newNode]
        : [newNode, node]);

  return new BitmapIndexedNode(ownerID, 1 << idx1 | 1 << idx2, nodes);
}

function createNodes(ownerID, entries, key, value) {
  if (!ownerID) {
    ownerID = new OwnerID();
  }
  var node = new ValueNode(ownerID, hash(key), [key, value]);
  for (var ii = 0; ii < entries.length; ii++) {
    var entry = entries[ii];
    node = node.update(ownerID, 0, undefined, entry[0], entry[1]);
  }
  return node;
}

function packNodes(ownerID, nodes, count, excluding) {
  var bitmap = 0;
  var packedII = 0;
  var packedNodes = new Array(count);
  for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, (bit <<= 1)) {
    var node = nodes[ii];
    if (node !== undefined && ii !== excluding) {
      bitmap |= bit;
      packedNodes[packedII++] = node;
    }
  }
  return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
}

function expandNodes(ownerID, nodes, bitmap, including, node) {
  var count = 0;
  var expandedNodes = new Array(SIZE);
  for (var ii = 0; bitmap !== 0; ii++, (bitmap >>>= 1)) {
    expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;
  }
  expandedNodes[including] = node;
  return new HashArrayMapNode(ownerID, count + 1, expandedNodes);
}

function mergeIntoMapWith(map, merger, collections) {
  var iters = [];
  for (var ii = 0; ii < collections.length; ii++) {
    var value = collections[ii];
    var iter = KeyedCollection(value);
    if (!isCollection(value)) {
      iter = iter.map(function (v) { return fromJS(v); });
    }
    iters.push(iter);
  }
  return mergeIntoCollectionWith(map, merger, iters);
}

function deepMerger(oldVal, newVal) {
  return oldVal && oldVal.mergeDeep && isCollection(newVal)
    ? oldVal.mergeDeep(newVal)
    : is(oldVal, newVal) ? oldVal : newVal;
}

function deepMergerWith(merger) {
  return function (oldVal, newVal, key) {
    if (oldVal && oldVal.mergeDeepWith && isCollection(newVal)) {
      return oldVal.mergeDeepWith(merger, newVal);
    }
    var nextValue = merger(oldVal, newVal, key);
    return is(oldVal, nextValue) ? oldVal : nextValue;
  };
}

function mergeIntoCollectionWith(collection, merger, iters) {
  iters = iters.filter(function (x) { return x.size !== 0; });
  if (iters.length === 0) {
    return collection;
  }
  if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {
    return collection.constructor(iters[0]);
  }
  return collection.withMutations(function (collection) {
    var mergeIntoMap = merger
      ? function (value, key) {
          collection.update(
            key,
            NOT_SET,
            function (oldVal) { return oldVal === NOT_SET ? value : merger(oldVal, value, key); }
          );
        }
      : function (value, key) {
          collection.set(key, value);
        };
    for (var ii = 0; ii < iters.length; ii++) {
      iters[ii].forEach(mergeIntoMap);
    }
  });
}

function updateInDeepMap(existing, keyPath, i, notSetValue, updater) {
  var isNotSet = existing === NOT_SET;
  if (i === keyPath.length) {
    var existingValue = isNotSet ? notSetValue : existing;
    var newValue = updater(existingValue);
    return newValue === existingValue ? existing : newValue;
  }
  if (!(isNotSet || (existing && existing.set))) {
    throw new TypeError(
      'Invalid keyPath: Value at [' +
        keyPath.slice(0, i).map(quoteString) +
        '] does not have a .set() method and cannot be updated: ' +
        existing
    );
  }
  var key = keyPath[i];
  var nextExisting = isNotSet ? NOT_SET : existing.get(key, NOT_SET);
  var nextUpdated = updateInDeepMap(
    nextExisting,
    keyPath,
    i + 1,
    notSetValue,
    updater
  );
  return nextUpdated === nextExisting
    ? existing
    : nextUpdated === NOT_SET
        ? existing.remove(key)
        : (isNotSet ? emptyMap() : existing).set(key, nextUpdated);
}

function popCount(x) {
  x -= x >> 1 & 0x55555555;
  x = (x & 0x33333333) + (x >> 2 & 0x33333333);
  x = x + (x >> 4) & 0x0f0f0f0f;
  x += x >> 8;
  x += x >> 16;
  return x & 0x7f;
}

function setIn(array, idx, val, canEdit) {
  var newArray = canEdit ? array : arrCopy(array);
  newArray[idx] = val;
  return newArray;
}

function spliceIn(array, idx, val, canEdit) {
  var newLen = array.length + 1;
  if (canEdit && idx + 1 === newLen) {
    array[idx] = val;
    return array;
  }
  var newArray = new Array(newLen);
  var after = 0;
  for (var ii = 0; ii < newLen; ii++) {
    if (ii === idx) {
      newArray[ii] = val;
      after = -1;
    } else {
      newArray[ii] = array[ii + after];
    }
  }
  return newArray;
}

function spliceOut(array, idx, canEdit) {
  var newLen = array.length - 1;
  if (canEdit && idx === newLen) {
    array.pop();
    return array;
  }
  var newArray = new Array(newLen);
  var after = 0;
  for (var ii = 0; ii < newLen; ii++) {
    if (ii === idx) {
      after = 1;
    }
    newArray[ii] = array[ii + after];
  }
  return newArray;
}

var MAX_ARRAY_MAP_SIZE = SIZE / 4;
var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;

var List = (function (IndexedCollection$$1) {
  function List(value) {
    var empty = emptyList();
    if (value === null || value === undefined) {
      return empty;
    }
    if (isList(value)) {
      return value;
    }
    var iter = IndexedCollection$$1(value);
    var size = iter.size;
    if (size === 0) {
      return empty;
    }
    assertNotInfinite(size);
    if (size > 0 && size < SIZE) {
      return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));
    }
    return empty.withMutations(function (list) {
      list.setSize(size);
      iter.forEach(function (v, i) { return list.set(i, v); });
    });
  }

  if ( IndexedCollection$$1 ) List.__proto__ = IndexedCollection$$1;
  List.prototype = Object.create( IndexedCollection$$1 && IndexedCollection$$1.prototype );
  List.prototype.constructor = List;

  List.of = function of (/*...values*/) {
    return this(arguments);
  };

  List.prototype.toString = function toString () {
    return this.__toString('List [', ']');
  };

  // @pragma Access

  List.prototype.get = function get (index, notSetValue) {
    index = wrapIndex(this, index);
    if (index >= 0 && index < this.size) {
      index += this._origin;
      var node = listNodeFor(this, index);
      return node && node.array[index & MASK];
    }
    return notSetValue;
  };

  // @pragma Modification

  List.prototype.set = function set (index, value) {
    return updateList(this, index, value);
  };

  List.prototype.remove = function remove (index) {
    return !this.has(index)
      ? this
      : index === 0
          ? this.shift()
          : index === this.size - 1 ? this.pop() : this.splice(index, 1);
  };

  List.prototype.insert = function insert (index, value) {
    return this.splice(index, 0, value);
  };

  List.prototype.clear = function clear () {
    if (this.size === 0) {
      return this;
    }
    if (this.__ownerID) {
      this.size = (this._origin = (this._capacity = 0));
      this._level = SHIFT;
      this._root = (this._tail = null);
      this.__hash = undefined;
      this.__altered = true;
      return this;
    }
    return emptyList();
  };

  List.prototype.push = function push (/*...values*/) {
    var values = arguments;
    var oldSize = this.size;
    return this.withMutations(function (list) {
      setListBounds(list, 0, oldSize + values.length);
      for (var ii = 0; ii < values.length; ii++) {
        list.set(oldSize + ii, values[ii]);
      }
    });
  };

  List.prototype.pop = function pop () {
    return setListBounds(this, 0, -1);
  };

  List.prototype.unshift = function unshift (/*...values*/) {
    var values = arguments;
    return this.withMutations(function (list) {
      setListBounds(list, -values.length);
      for (var ii = 0; ii < values.length; ii++) {
        list.set(ii, values[ii]);
      }
    });
  };

  List.prototype.shift = function shift () {
    return setListBounds(this, 1);
  };

  // @pragma Composition

  List.prototype.merge = function merge (/*...iters*/) {
    return mergeIntoListWith(this, undefined, arguments);
  };

  List.prototype.mergeWith = function mergeWith (merger) {
    var iters = [], len = arguments.length - 1;
    while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];

    return mergeIntoListWith(this, merger, iters);
  };

  List.prototype.mergeDeep = function mergeDeep (/*...iters*/) {
    return mergeIntoListWith(this, deepMerger, arguments);
  };

  List.prototype.mergeDeepWith = function mergeDeepWith (merger) {
    var iters = [], len = arguments.length - 1;
    while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];

    return mergeIntoListWith(this, deepMergerWith(merger), iters);
  };

  List.prototype.setSize = function setSize (size) {
    return setListBounds(this, 0, size);
  };

  // @pragma Iteration

  List.prototype.slice = function slice (begin, end) {
    var size = this.size;
    if (wholeSlice(begin, end, size)) {
      return this;
    }
    return setListBounds(
      this,
      resolveBegin(begin, size),
      resolveEnd(end, size)
    );
  };

  List.prototype.__iterator = function __iterator (type, reverse) {
    var index = reverse ? this.size : 0;
    var values = iterateList(this, reverse);
    return new Iterator(function () {
      var value = values();
      return value === DONE
        ? iteratorDone()
        : iteratorValue(type, reverse ? --index : index++, value);
    });
  };

  List.prototype.__iterate = function __iterate (fn, reverse) {
    var this$1 = this;

    var index = reverse ? this.size : 0;
    var values = iterateList(this, reverse);
    var value;
    while ((value = values()) !== DONE) {
      if (fn(value, reverse ? --index : index++, this$1) === false) {
        break;
      }
    }
    return index;
  };

  List.prototype.__ensureOwner = function __ensureOwner (ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }
    if (!ownerID) {
      if (this.size === 0) {
        return emptyList();
      }
      this.__ownerID = ownerID;
      return this;
    }
    return makeList(
      this._origin,
      this._capacity,
      this._level,
      this._root,
      this._tail,
      ownerID,
      this.__hash
    );
  };

  return List;
}(IndexedCollection));

function isList(maybeList) {
  return !!(maybeList && maybeList[IS_LIST_SENTINEL]);
}

List.isList = isList;

var IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';

var ListPrototype = List.prototype;
ListPrototype[IS_LIST_SENTINEL] = true;
ListPrototype[DELETE] = ListPrototype.remove;
ListPrototype.setIn = MapPrototype.setIn;
ListPrototype.deleteIn = (ListPrototype.removeIn = MapPrototype.removeIn);
ListPrototype.update = MapPrototype.update;
ListPrototype.updateIn = MapPrototype.updateIn;
ListPrototype.mergeIn = MapPrototype.mergeIn;
ListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
ListPrototype.withMutations = MapPrototype.withMutations;
ListPrototype.asMutable = MapPrototype.asMutable;
ListPrototype.asImmutable = MapPrototype.asImmutable;
ListPrototype.wasAltered = MapPrototype.wasAltered;

var VNode = function VNode(array, ownerID) {
  this.array = array;
  this.ownerID = ownerID;
};

// TODO: seems like these methods are very similar

VNode.prototype.removeBefore = function removeBefore (ownerID, level, index) {
  if (index === level ? 1 << level : 0 || this.array.length === 0) {
    return this;
  }
  var originIndex = index >>> level & MASK;
  if (originIndex >= this.array.length) {
    return new VNode([], ownerID);
  }
  var removingFirst = originIndex === 0;
  var newChild;
  if (level > 0) {
    var oldChild = this.array[originIndex];
    newChild = oldChild &&
      oldChild.removeBefore(ownerID, level - SHIFT, index);
    if (newChild === oldChild && removingFirst) {
      return this;
    }
  }
  if (removingFirst && !newChild) {
    return this;
  }
  var editable = editableVNode(this, ownerID);
  if (!removingFirst) {
    for (var ii = 0; ii < originIndex; ii++) {
      editable.array[ii] = undefined;
    }
  }
  if (newChild) {
    editable.array[originIndex] = newChild;
  }
  return editable;
};

VNode.prototype.removeAfter = function removeAfter (ownerID, level, index) {
  if (index === (level ? 1 << level : 0) || this.array.length === 0) {
    return this;
  }
  var sizeIndex = index - 1 >>> level & MASK;
  if (sizeIndex >= this.array.length) {
    return this;
  }

  var newChild;
  if (level > 0) {
    var oldChild = this.array[sizeIndex];
    newChild = oldChild &&
      oldChild.removeAfter(ownerID, level - SHIFT, index);
    if (newChild === oldChild && sizeIndex === this.array.length - 1) {
      return this;
    }
  }

  var editable = editableVNode(this, ownerID);
  editable.array.splice(sizeIndex + 1);
  if (newChild) {
    editable.array[sizeIndex] = newChild;
  }
  return editable;
};

var DONE = {};

function iterateList(list, reverse) {
  var left = list._origin;
  var right = list._capacity;
  var tailPos = getTailOffset(right);
  var tail = list._tail;

  return iterateNodeOrLeaf(list._root, list._level, 0);

  function iterateNodeOrLeaf(node, level, offset) {
    return level === 0
      ? iterateLeaf(node, offset)
      : iterateNode(node, level, offset);
  }

  function iterateLeaf(node, offset) {
    var array = offset === tailPos ? tail && tail.array : node && node.array;
    var from = offset > left ? 0 : left - offset;
    var to = right - offset;
    if (to > SIZE) {
      to = SIZE;
    }
    return function () {
      if (from === to) {
        return DONE;
      }
      var idx = reverse ? --to : from++;
      return array && array[idx];
    };
  }

  function iterateNode(node, level, offset) {
    var values;
    var array = node && node.array;
    var from = offset > left ? 0 : left - offset >> level;
    var to = (right - offset >> level) + 1;
    if (to > SIZE) {
      to = SIZE;
    }
    return function () {
      while (true) {
        if (values) {
          var value = values();
          if (value !== DONE) {
            return value;
          }
          values = null;
        }
        if (from === to) {
          return DONE;
        }
        var idx = reverse ? --to : from++;
        values = iterateNodeOrLeaf(
          array && array[idx],
          level - SHIFT,
          offset + (idx << level)
        );
      }
    };
  }
}

function makeList(origin, capacity, level, root, tail, ownerID, hash) {
  var list = Object.create(ListPrototype);
  list.size = capacity - origin;
  list._origin = origin;
  list._capacity = capacity;
  list._level = level;
  list._root = root;
  list._tail = tail;
  list.__ownerID = ownerID;
  list.__hash = hash;
  list.__altered = false;
  return list;
}

var EMPTY_LIST;
function emptyList() {
  return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));
}

function updateList(list, index, value) {
  index = wrapIndex(list, index);

  if (index !== index) {
    return list;
  }

  if (index >= list.size || index < 0) {
    return list.withMutations(function (list) {
      index < 0
        ? setListBounds(list, index).set(0, value)
        : setListBounds(list, 0, index + 1).set(index, value);
    });
  }

  index += list._origin;

  var newTail = list._tail;
  var newRoot = list._root;
  var didAlter = MakeRef(DID_ALTER);
  if (index >= getTailOffset(list._capacity)) {
    newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);
  } else {
    newRoot = updateVNode(
      newRoot,
      list.__ownerID,
      list._level,
      index,
      value,
      didAlter
    );
  }

  if (!didAlter.value) {
    return list;
  }

  if (list.__ownerID) {
    list._root = newRoot;
    list._tail = newTail;
    list.__hash = undefined;
    list.__altered = true;
    return list;
  }
  return makeList(list._origin, list._capacity, list._level, newRoot, newTail);
}

function updateVNode(node, ownerID, level, index, value, didAlter) {
  var idx = index >>> level & MASK;
  var nodeHas = node && idx < node.array.length;
  if (!nodeHas && value === undefined) {
    return node;
  }

  var newNode;

  if (level > 0) {
    var lowerNode = node && node.array[idx];
    var newLowerNode = updateVNode(
      lowerNode,
      ownerID,
      level - SHIFT,
      index,
      value,
      didAlter
    );
    if (newLowerNode === lowerNode) {
      return node;
    }
    newNode = editableVNode(node, ownerID);
    newNode.array[idx] = newLowerNode;
    return newNode;
  }

  if (nodeHas && node.array[idx] === value) {
    return node;
  }

  SetRef(didAlter);

  newNode = editableVNode(node, ownerID);
  if (value === undefined && idx === newNode.array.length - 1) {
    newNode.array.pop();
  } else {
    newNode.array[idx] = value;
  }
  return newNode;
}

function editableVNode(node, ownerID) {
  if (ownerID && node && ownerID === node.ownerID) {
    return node;
  }
  return new VNode(node ? node.array.slice() : [], ownerID);
}

function listNodeFor(list, rawIndex) {
  if (rawIndex >= getTailOffset(list._capacity)) {
    return list._tail;
  }
  if (rawIndex < 1 << list._level + SHIFT) {
    var node = list._root;
    var level = list._level;
    while (node && level > 0) {
      node = node.array[rawIndex >>> level & MASK];
      level -= SHIFT;
    }
    return node;
  }
}

function setListBounds(list, begin, end) {
  // Sanitize begin & end using this shorthand for ToInt32(argument)
  // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
  if (begin !== undefined) {
    begin |= 0;
  }
  if (end !== undefined) {
    end |= 0;
  }
  var owner = list.__ownerID || new OwnerID();
  var oldOrigin = list._origin;
  var oldCapacity = list._capacity;
  var newOrigin = oldOrigin + begin;
  var newCapacity = end === undefined
    ? oldCapacity
    : end < 0 ? oldCapacity + end : oldOrigin + end;
  if (newOrigin === oldOrigin && newCapacity === oldCapacity) {
    return list;
  }

  // If it's going to end after it starts, it's empty.
  if (newOrigin >= newCapacity) {
    return list.clear();
  }

  var newLevel = list._level;
  var newRoot = list._root;

  // New origin might need creating a higher root.
  var offsetShift = 0;
  while (newOrigin + offsetShift < 0) {
    newRoot = new VNode(
      newRoot && newRoot.array.length ? [undefined, newRoot] : [],
      owner
    );
    newLevel += SHIFT;
    offsetShift += 1 << newLevel;
  }
  if (offsetShift) {
    newOrigin += offsetShift;
    oldOrigin += offsetShift;
    newCapacity += offsetShift;
    oldCapacity += offsetShift;
  }

  var oldTailOffset = getTailOffset(oldCapacity);
  var newTailOffset = getTailOffset(newCapacity);

  // New size might need creating a higher root.
  while (newTailOffset >= 1 << newLevel + SHIFT) {
    newRoot = new VNode(
      newRoot && newRoot.array.length ? [newRoot] : [],
      owner
    );
    newLevel += SHIFT;
  }

  // Locate or create the new tail.
  var oldTail = list._tail;
  var newTail = newTailOffset < oldTailOffset
    ? listNodeFor(list, newCapacity - 1)
    : newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;

  // Merge Tail into tree.
  if (
    oldTail &&
    newTailOffset > oldTailOffset &&
    newOrigin < oldCapacity &&
    oldTail.array.length
  ) {
    newRoot = editableVNode(newRoot, owner);
    var node = newRoot;
    for (var level = newLevel; level > SHIFT; level -= SHIFT) {
      var idx = oldTailOffset >>> level & MASK;
      node = (node.array[idx] = editableVNode(node.array[idx], owner));
    }
    node.array[oldTailOffset >>> SHIFT & MASK] = oldTail;
  }

  // If the size has been reduced, there's a chance the tail needs to be trimmed.
  if (newCapacity < oldCapacity) {
    newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
  }

  // If the new origin is within the tail, then we do not need a root.
  if (newOrigin >= newTailOffset) {
    newOrigin -= newTailOffset;
    newCapacity -= newTailOffset;
    newLevel = SHIFT;
    newRoot = null;
    newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);

    // Otherwise, if the root has been trimmed, garbage collect.
  } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
    offsetShift = 0;

    // Identify the new top root node of the subtree of the old root.
    while (newRoot) {
      var beginIndex = newOrigin >>> newLevel & MASK;
      if (beginIndex !== newTailOffset >>> newLevel & MASK) {
        break;
      }
      if (beginIndex) {
        offsetShift += (1 << newLevel) * beginIndex;
      }
      newLevel -= SHIFT;
      newRoot = newRoot.array[beginIndex];
    }

    // Trim the new sides of the new root.
    if (newRoot && newOrigin > oldOrigin) {
      newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
    }
    if (newRoot && newTailOffset < oldTailOffset) {
      newRoot = newRoot.removeAfter(
        owner,
        newLevel,
        newTailOffset - offsetShift
      );
    }
    if (offsetShift) {
      newOrigin -= offsetShift;
      newCapacity -= offsetShift;
    }
  }

  if (list.__ownerID) {
    list.size = newCapacity - newOrigin;
    list._origin = newOrigin;
    list._capacity = newCapacity;
    list._level = newLevel;
    list._root = newRoot;
    list._tail = newTail;
    list.__hash = undefined;
    list.__altered = true;
    return list;
  }
  return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);
}

function mergeIntoListWith(list, merger, collections) {
  var iters = [];
  var maxSize = 0;
  for (var ii = 0; ii < collections.length; ii++) {
    var value = collections[ii];
    var iter = IndexedCollection(value);
    if (iter.size > maxSize) {
      maxSize = iter.size;
    }
    if (!isCollection(value)) {
      iter = iter.map(function (v) { return fromJS(v); });
    }
    iters.push(iter);
  }
  if (maxSize > list.size) {
    list = list.setSize(maxSize);
  }
  return mergeIntoCollectionWith(list, merger, iters);
}

function getTailOffset(size) {
  return size < SIZE ? 0 : size - 1 >>> SHIFT << SHIFT;
}

var OrderedMap = (function (Map$$1) {
  function OrderedMap(value) {
    return value === null || value === undefined
      ? emptyOrderedMap()
      : isOrderedMap(value)
          ? value
          : emptyOrderedMap().withMutations(function (map) {
              var iter = KeyedCollection(value);
              assertNotInfinite(iter.size);
              iter.forEach(function (v, k) { return map.set(k, v); });
            });
  }

  if ( Map$$1 ) OrderedMap.__proto__ = Map$$1;
  OrderedMap.prototype = Object.create( Map$$1 && Map$$1.prototype );
  OrderedMap.prototype.constructor = OrderedMap;

  OrderedMap.of = function of (/*...values*/) {
    return this(arguments);
  };

  OrderedMap.prototype.toString = function toString () {
    return this.__toString('OrderedMap {', '}');
  };

  // @pragma Access

  OrderedMap.prototype.get = function get (k, notSetValue) {
    var index = this._map.get(k);
    return index !== undefined ? this._list.get(index)[1] : notSetValue;
  };

  // @pragma Modification

  OrderedMap.prototype.clear = function clear () {
    if (this.size === 0) {
      return this;
    }
    if (this.__ownerID) {
      this.size = 0;
      this._map.clear();
      this._list.clear();
      return this;
    }
    return emptyOrderedMap();
  };

  OrderedMap.prototype.set = function set (k, v) {
    return updateOrderedMap(this, k, v);
  };

  OrderedMap.prototype.remove = function remove (k) {
    return updateOrderedMap(this, k, NOT_SET);
  };

  OrderedMap.prototype.wasAltered = function wasAltered () {
    return this._map.wasAltered() || this._list.wasAltered();
  };

  OrderedMap.prototype.__iterate = function __iterate (fn, reverse) {
    var this$1 = this;

    return this._list.__iterate(
      function (entry) { return entry && fn(entry[1], entry[0], this$1); },
      reverse
    );
  };

  OrderedMap.prototype.__iterator = function __iterator (type, reverse) {
    return this._list.fromEntrySeq().__iterator(type, reverse);
  };

  OrderedMap.prototype.__ensureOwner = function __ensureOwner (ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }
    var newMap = this._map.__ensureOwner(ownerID);
    var newList = this._list.__ensureOwner(ownerID);
    if (!ownerID) {
      if (this.size === 0) {
        return emptyOrderedMap();
      }
      this.__ownerID = ownerID;
      this._map = newMap;
      this._list = newList;
      return this;
    }
    return makeOrderedMap(newMap, newList, ownerID, this.__hash);
  };

  return OrderedMap;
}(Map));

function isOrderedMap(maybeOrderedMap) {
  return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);
}

OrderedMap.isOrderedMap = isOrderedMap;

OrderedMap.prototype[IS_ORDERED_SENTINEL] = true;
OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;

function makeOrderedMap(map, list, ownerID, hash) {
  var omap = Object.create(OrderedMap.prototype);
  omap.size = map ? map.size : 0;
  omap._map = map;
  omap._list = list;
  omap.__ownerID = ownerID;
  omap.__hash = hash;
  return omap;
}

var EMPTY_ORDERED_MAP;
function emptyOrderedMap() {
  return EMPTY_ORDERED_MAP ||
    (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));
}

function updateOrderedMap(omap, k, v) {
  var map = omap._map;
  var list = omap._list;
  var i = map.get(k);
  var has = i !== undefined;
  var newMap;
  var newList;
  if (v === NOT_SET) {
    // removed
    if (!has) {
      return omap;
    }
    if (list.size >= SIZE && list.size >= map.size * 2) {
      newList = list.filter(function (entry, idx) { return entry !== undefined && i !== idx; });
      newMap = newList.toKeyedSeq().map(function (entry) { return entry[0]; }).flip().toMap();
      if (omap.__ownerID) {
        newMap.__ownerID = (newList.__ownerID = omap.__ownerID);
      }
    } else {
      newMap = map.remove(k);
      newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);
    }
  } else if (has) {
    if (v === list.get(i)[1]) {
      return omap;
    }
    newMap = map;
    newList = list.set(i, [k, v]);
  } else {
    newMap = map.set(k, list.size);
    newList = list.set(list.size, [k, v]);
  }
  if (omap.__ownerID) {
    omap.size = newMap.size;
    omap._map = newMap;
    omap._list = newList;
    omap.__hash = undefined;
    return omap;
  }
  return makeOrderedMap(newMap, newList);
}

var Stack = (function (IndexedCollection$$1) {
  function Stack(value) {
    return value === null || value === undefined
      ? emptyStack()
      : isStack(value) ? value : emptyStack().pushAll(value);
  }

  if ( IndexedCollection$$1 ) Stack.__proto__ = IndexedCollection$$1;
  Stack.prototype = Object.create( IndexedCollection$$1 && IndexedCollection$$1.prototype );
  Stack.prototype.constructor = Stack;

  Stack.of = function of (/*...values*/) {
    return this(arguments);
  };

  Stack.prototype.toString = function toString () {
    return this.__toString('Stack [', ']');
  };

  // @pragma Access

  Stack.prototype.get = function get (index, notSetValue) {
    var head = this._head;
    index = wrapIndex(this, index);
    while (head && index--) {
      head = head.next;
    }
    return head ? head.value : notSetValue;
  };

  Stack.prototype.peek = function peek () {
    return this._head && this._head.value;
  };

  // @pragma Modification

  Stack.prototype.push = function push (/*...values*/) {
    var arguments$1 = arguments;

    if (arguments.length === 0) {
      return this;
    }
    var newSize = this.size + arguments.length;
    var head = this._head;
    for (var ii = arguments.length - 1; ii >= 0; ii--) {
      head = {
        value: arguments$1[ii],
        next: head
      };
    }
    if (this.__ownerID) {
      this.size = newSize;
      this._head = head;
      this.__hash = undefined;
      this.__altered = true;
      return this;
    }
    return makeStack(newSize, head);
  };

  Stack.prototype.pushAll = function pushAll (iter) {
    iter = IndexedCollection$$1(iter);
    if (iter.size === 0) {
      return this;
    }
    if (this.size === 0 && isStack(iter)) {
      return iter;
    }
    assertNotInfinite(iter.size);
    var newSize = this.size;
    var head = this._head;
    iter.__iterate(
      function (value) {
        newSize++;
        head = {
          value: value,
          next: head
        };
      },
      /* reverse */ true
    );
    if (this.__ownerID) {
      this.size = newSize;
      this._head = head;
      this.__hash = undefined;
      this.__altered = true;
      return this;
    }
    return makeStack(newSize, head);
  };

  Stack.prototype.pop = function pop () {
    return this.slice(1);
  };

  Stack.prototype.clear = function clear () {
    if (this.size === 0) {
      return this;
    }
    if (this.__ownerID) {
      this.size = 0;
      this._head = undefined;
      this.__hash = undefined;
      this.__altered = true;
      return this;
    }
    return emptyStack();
  };

  Stack.prototype.slice = function slice (begin, end) {
    if (wholeSlice(begin, end, this.size)) {
      return this;
    }
    var resolvedBegin = resolveBegin(begin, this.size);
    var resolvedEnd = resolveEnd(end, this.size);
    if (resolvedEnd !== this.size) {
      // super.slice(begin, end);
      return IndexedCollection$$1.prototype.slice.call(this, begin, end);
    }
    var newSize = this.size - resolvedBegin;
    var head = this._head;
    while (resolvedBegin--) {
      head = head.next;
    }
    if (this.__ownerID) {
      this.size = newSize;
      this._head = head;
      this.__hash = undefined;
      this.__altered = true;
      return this;
    }
    return makeStack(newSize, head);
  };

  // @pragma Mutability

  Stack.prototype.__ensureOwner = function __ensureOwner (ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }
    if (!ownerID) {
      if (this.size === 0) {
        return emptyStack();
      }
      this.__ownerID = ownerID;
      this.__altered = false;
      return this;
    }
    return makeStack(this.size, this._head, ownerID, this.__hash);
  };

  // @pragma Iteration

  Stack.prototype.__iterate = function __iterate (fn, reverse) {
    var this$1 = this;

    if (reverse) {
      return new ArraySeq(this.toArray()).__iterate(
        function (v, k) { return fn(v, k, this$1); },
        reverse
      );
    }
    var iterations = 0;
    var node = this._head;
    while (node) {
      if (fn(node.value, iterations++, this$1) === false) {
        break;
      }
      node = node.next;
    }
    return iterations;
  };

  Stack.prototype.__iterator = function __iterator (type, reverse) {
    if (reverse) {
      return new ArraySeq(this.toArray()).__iterator(type, reverse);
    }
    var iterations = 0;
    var node = this._head;
    return new Iterator(function () {
      if (node) {
        var value = node.value;
        node = node.next;
        return iteratorValue(type, iterations++, value);
      }
      return iteratorDone();
    });
  };

  return Stack;
}(IndexedCollection));

function isStack(maybeStack) {
  return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);
}

Stack.isStack = isStack;

var IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';

var StackPrototype = Stack.prototype;
StackPrototype[IS_STACK_SENTINEL] = true;
StackPrototype.withMutations = MapPrototype.withMutations;
StackPrototype.asMutable = MapPrototype.asMutable;
StackPrototype.asImmutable = MapPrototype.asImmutable;
StackPrototype.wasAltered = MapPrototype.wasAltered;
StackPrototype.shift = StackPrototype.pop;
StackPrototype.unshift = StackPrototype.push;
StackPrototype.unshiftAll = StackPrototype.pushAll;

function makeStack(size, head, ownerID, hash) {
  var map = Object.create(StackPrototype);
  map.size = size;
  map._head = head;
  map.__ownerID = ownerID;
  map.__hash = hash;
  map.__altered = false;
  return map;
}

var EMPTY_STACK;
function emptyStack() {
  return EMPTY_STACK || (EMPTY_STACK = makeStack(0));
}

function deepEqual(a, b) {
  if (a === b) {
    return true;
  }

  if (
    !isCollection(b) ||
    (a.size !== undefined && b.size !== undefined && a.size !== b.size) ||
    (a.__hash !== undefined &&
      b.__hash !== undefined &&
      a.__hash !== b.__hash) ||
    isKeyed(a) !== isKeyed(b) ||
    isIndexed(a) !== isIndexed(b) ||
    isOrdered(a) !== isOrdered(b)
  ) {
    return false;
  }

  if (a.size === 0 && b.size === 0) {
    return true;
  }

  var notAssociative = !isAssociative(a);

  if (isOrdered(a)) {
    var entries = a.entries();
    return b.every(function (v, k) {
      var entry = entries.next().value;
      return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));
    }) && entries.next().done;
  }

  var flipped = false;

  if (a.size === undefined) {
    if (b.size === undefined) {
      if (typeof a.cacheResult === 'function') {
        a.cacheResult();
      }
    } else {
      flipped = true;
      var _ = a;
      a = b;
      b = _;
    }
  }

  var allEqual = true;
  var bSize = b.__iterate(function (v, k) {
    if (
      notAssociative
        ? !a.has(v)
        : flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)
    ) {
      allEqual = false;
      return false;
    }
  });

  return allEqual && a.size === bSize;
}

/**
 * Contributes additional methods to a constructor
 */
function mixin(ctor, methods) {
  var keyCopier = function (key) {
    ctor.prototype[key] = methods[key];
  };
  Object.keys(methods).forEach(keyCopier);
  Object.getOwnPropertySymbols &&
    Object.getOwnPropertySymbols(methods).forEach(keyCopier);
  return ctor;
}

var Set = (function (SetCollection$$1) {
  function Set(value) {
    return value === null || value === undefined
      ? emptySet()
      : isSet(value) && !isOrdered(value)
          ? value
          : emptySet().withMutations(function (set) {
              var iter = SetCollection$$1(value);
              assertNotInfinite(iter.size);
              iter.forEach(function (v) { return set.add(v); });
            });
  }

  if ( SetCollection$$1 ) Set.__proto__ = SetCollection$$1;
  Set.prototype = Object.create( SetCollection$$1 && SetCollection$$1.prototype );
  Set.prototype.constructor = Set;

  Set.of = function of (/*...values*/) {
    return this(arguments);
  };

  Set.fromKeys = function fromKeys (value) {
    return this(KeyedCollection(value).keySeq());
  };

  Set.intersect = function intersect (sets) {
    sets = Collection(sets).toArray();
    return sets.length
      ? SetPrototype.intersect.apply(Set(sets.pop()), sets)
      : emptySet();
  };

  Set.union = function union (sets) {
    sets = Collection(sets).toArray();
    return sets.length
      ? SetPrototype.union.apply(Set(sets.pop()), sets)
      : emptySet();
  };

  Set.prototype.toString = function toString () {
    return this.__toString('Set {', '}');
  };

  // @pragma Access

  Set.prototype.has = function has (value) {
    return this._map.has(value);
  };

  // @pragma Modification

  Set.prototype.add = function add (value) {
    return updateSet(this, this._map.set(value, true));
  };

  Set.prototype.remove = function remove (value) {
    return updateSet(this, this._map.remove(value));
  };

  Set.prototype.clear = function clear () {
    return updateSet(this, this._map.clear());
  };

  // @pragma Composition

  Set.prototype.union = function union () {
    var iters = [], len = arguments.length;
    while ( len-- ) iters[ len ] = arguments[ len ];

    iters = iters.filter(function (x) { return x.size !== 0; });
    if (iters.length === 0) {
      return this;
    }
    if (this.size === 0 && !this.__ownerID && iters.length === 1) {
      return this.constructor(iters[0]);
    }
    return this.withMutations(function (set) {
      for (var ii = 0; ii < iters.length; ii++) {
        SetCollection$$1(iters[ii]).forEach(function (value) { return set.add(value); });
      }
    });
  };

  Set.prototype.intersect = function intersect () {
    var iters = [], len = arguments.length;
    while ( len-- ) iters[ len ] = arguments[ len ];

    if (iters.length === 0) {
      return this;
    }
    iters = iters.map(function (iter) { return SetCollection$$1(iter); });
    var toRemove = [];
    this.forEach(function (value) {
      if (!iters.every(function (iter) { return iter.includes(value); })) {
        toRemove.push(value);
      }
    });
    return this.withMutations(function (set) {
      toRemove.forEach(function (value) {
        set.remove(value);
      });
    });
  };

  Set.prototype.subtract = function subtract () {
    var iters = [], len = arguments.length;
    while ( len-- ) iters[ len ] = arguments[ len ];

    if (iters.length === 0) {
      return this;
    }
    var toRemove = [];
    this.forEach(function (value) {
      if (iters.some(function (iter) { return iter.includes(value); })) {
        toRemove.push(value);
      }
    });
    return this.withMutations(function (set) {
      toRemove.forEach(function (value) {
        set.remove(value);
      });
    });
  };

  Set.prototype.merge = function merge () {
    return this.union.apply(this, arguments);
  };

  Set.prototype.mergeWith = function mergeWith (merger) {
    var iters = [], len = arguments.length - 1;
    while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];

    return this.union.apply(this, iters);
  };

  Set.prototype.sort = function sort (comparator) {
    // Late binding
    return OrderedSet(sortFactory(this, comparator));
  };

  Set.prototype.sortBy = function sortBy (mapper, comparator) {
    // Late binding
    return OrderedSet(sortFactory(this, comparator, mapper));
  };

  Set.prototype.wasAltered = function wasAltered () {
    return this._map.wasAltered();
  };

  Set.prototype.__iterate = function __iterate (fn, reverse) {
    var this$1 = this;

    return this._map.__iterate(function (_, k) { return fn(k, k, this$1); }, reverse);
  };

  Set.prototype.__iterator = function __iterator (type, reverse) {
    return this._map.map(function (_, k) { return k; }).__iterator(type, reverse);
  };

  Set.prototype.__ensureOwner = function __ensureOwner (ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }
    var newMap = this._map.__ensureOwner(ownerID);
    if (!ownerID) {
      if (this.size === 0) {
        return emptySet();
      }
      this.__ownerID = ownerID;
      this._map = newMap;
      return this;
    }
    return this.__make(newMap, ownerID);
  };

  return Set;
}(SetCollection));

function isSet(maybeSet) {
  return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);
}

Set.isSet = isSet;

var IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';

var SetPrototype = Set.prototype;
SetPrototype[IS_SET_SENTINEL] = true;
SetPrototype[DELETE] = SetPrototype.remove;
SetPrototype.mergeDeep = SetPrototype.merge;
SetPrototype.mergeDeepWith = SetPrototype.mergeWith;
SetPrototype.withMutations = MapPrototype.withMutations;
SetPrototype.asMutable = MapPrototype.asMutable;
SetPrototype.asImmutable = MapPrototype.asImmutable;

SetPrototype.__empty = emptySet;
SetPrototype.__make = makeSet;

function updateSet(set, newMap) {
  if (set.__ownerID) {
    set.size = newMap.size;
    set._map = newMap;
    return set;
  }
  return newMap === set._map
    ? set
    : newMap.size === 0 ? set.__empty() : set.__make(newMap);
}

function makeSet(map, ownerID) {
  var set = Object.create(SetPrototype);
  set.size = map ? map.size : 0;
  set._map = map;
  set.__ownerID = ownerID;
  return set;
}

var EMPTY_SET;
function emptySet() {
  return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));
}

/**
 * Returns a lazy seq of nums from start (inclusive) to end
 * (exclusive), by step, where start defaults to 0, step to 1, and end to
 * infinity. When start is equal to end, returns empty list.
 */
var Range = (function (IndexedSeq$$1) {
  function Range(start, end, step) {
    if (!(this instanceof Range)) {
      return new Range(start, end, step);
    }
    invariant(step !== 0, 'Cannot step a Range by 0');
    start = start || 0;
    if (end === undefined) {
      end = Infinity;
    }
    step = step === undefined ? 1 : Math.abs(step);
    if (end < start) {
      step = -step;
    }
    this._start = start;
    this._end = end;
    this._step = step;
    this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);
    if (this.size === 0) {
      if (EMPTY_RANGE) {
        return EMPTY_RANGE;
      }
      EMPTY_RANGE = this;
    }
  }

  if ( IndexedSeq$$1 ) Range.__proto__ = IndexedSeq$$1;
  Range.prototype = Object.create( IndexedSeq$$1 && IndexedSeq$$1.prototype );
  Range.prototype.constructor = Range;

  Range.prototype.toString = function toString () {
    if (this.size === 0) {
      return 'Range []';
    }
    return 'Range [ ' +
      this._start +
      '...' +
      this._end +
      (this._step !== 1 ? ' by ' + this._step : '') +
      ' ]';
  };

  Range.prototype.get = function get (index, notSetValue) {
    return this.has(index)
      ? this._start + wrapIndex(this, index) * this._step
      : notSetValue;
  };

  Range.prototype.includes = function includes (searchValue) {
    var possibleIndex = (searchValue - this._start) / this._step;
    return possibleIndex >= 0 &&
      possibleIndex < this.size &&
      possibleIndex === Math.floor(possibleIndex);
  };

  Range.prototype.slice = function slice (begin, end) {
    if (wholeSlice(begin, end, this.size)) {
      return this;
    }
    begin = resolveBegin(begin, this.size);
    end = resolveEnd(end, this.size);
    if (end <= begin) {
      return new Range(0, 0);
    }
    return new Range(
      this.get(begin, this._end),
      this.get(end, this._end),
      this._step
    );
  };

  Range.prototype.indexOf = function indexOf (searchValue) {
    var offsetValue = searchValue - this._start;
    if (offsetValue % this._step === 0) {
      var index = offsetValue / this._step;
      if (index >= 0 && index < this.size) {
        return index;
      }
    }
    return -1;
  };

  Range.prototype.lastIndexOf = function lastIndexOf (searchValue) {
    return this.indexOf(searchValue);
  };

  Range.prototype.__iterate = function __iterate (fn, reverse) {
    var this$1 = this;

    var size = this.size;
    var step = this._step;
    var value = reverse ? this._start + (size - 1) * step : this._start;
    var i = 0;
    while (i !== size) {
      if (fn(value, reverse ? size - ++i : i++, this$1) === false) {
        break;
      }
      value += reverse ? -step : step;
    }
    return i;
  };

  Range.prototype.__iterator = function __iterator (type, reverse) {
    var size = this.size;
    var step = this._step;
    var value = reverse ? this._start + (size - 1) * step : this._start;
    var i = 0;
    return new Iterator(function () {
      if (i === size) {
        return iteratorDone();
      }
      var v = value;
      value += reverse ? -step : step;
      return iteratorValue(type, reverse ? size - ++i : i++, v);
    });
  };

  Range.prototype.equals = function equals (other) {
    return other instanceof Range
      ? this._start === other._start &&
          this._end === other._end &&
          this._step === other._step
      : deepEqual(this, other);
  };

  return Range;
}(IndexedSeq));

var EMPTY_RANGE;

// Note: all of these methods are deprecated.
Collection.isIterable = isCollection;
Collection.isKeyed = isKeyed;
Collection.isIndexed = isIndexed;
Collection.isAssociative = isAssociative;
Collection.isOrdered = isOrdered;

Collection.Iterator = Iterator;

mixin(Collection, {
  // ### Conversion to other types

  toArray: function toArray() {
    assertNotInfinite(this.size);
    var array = new Array(this.size || 0);
    this.valueSeq().__iterate(function (v, i) {
      array[i] = v;
    });
    return array;
  },

  toIndexedSeq: function toIndexedSeq() {
    return new ToIndexedSequence(this);
  },

  toJS: function toJS$1() {
    return this.toSeq().map(toJS).toJSON();
  },

  toKeyedSeq: function toKeyedSeq() {
    return new ToKeyedSequence(this, true);
  },

  toMap: function toMap() {
    // Use Late Binding here to solve the circular dependency.
    return Map(this.toKeyedSeq());
  },

  toObject: function toObject() {
    assertNotInfinite(this.size);
    var object = {};
    this.__iterate(function (v, k) {
      object[k] = v;
    });
    return object;
  },

  toOrderedMap: function toOrderedMap() {
    // Use Late Binding here to solve the circular dependency.
    return OrderedMap(this.toKeyedSeq());
  },

  toOrderedSet: function toOrderedSet() {
    // Use Late Binding here to solve the circular dependency.
    return OrderedSet(isKeyed(this) ? this.valueSeq() : this);
  },

  toSet: function toSet() {
    // Use Late Binding here to solve the circular dependency.
    return Set(isKeyed(this) ? this.valueSeq() : this);
  },

  toSetSeq: function toSetSeq() {
    return new ToSetSequence(this);
  },

  toSeq: function toSeq() {
    return isIndexed(this)
      ? this.toIndexedSeq()
      : isKeyed(this) ? this.toKeyedSeq() : this.toSetSeq();
  },

  toStack: function toStack() {
    // Use Late Binding here to solve the circular dependency.
    return Stack(isKeyed(this) ? this.valueSeq() : this);
  },

  toList: function toList() {
    // Use Late Binding here to solve the circular dependency.
    return List(isKeyed(this) ? this.valueSeq() : this);
  },

  // ### Common JavaScript methods and properties

  toString: function toString() {
    return '[Collection]';
  },

  __toString: function __toString(head, tail) {
    if (this.size === 0) {
      return head + tail;
    }
    return head +
      ' ' +
      this.toSeq().map(this.__toStringMapper).join(', ') +
      ' ' +
      tail;
  },

  // ### ES6 Collection methods (ES6 Array and Map)

  concat: function concat() {
    var values = [], len = arguments.length;
    while ( len-- ) values[ len ] = arguments[ len ];

    return reify(this, concatFactory(this, values));
  },

  includes: function includes(searchValue) {
    return this.some(function (value) { return is(value, searchValue); });
  },

  entries: function entries() {
    return this.__iterator(ITERATE_ENTRIES);
  },

  every: function every(predicate, context) {
    assertNotInfinite(this.size);
    var returnValue = true;
    this.__iterate(function (v, k, c) {
      if (!predicate.call(context, v, k, c)) {
        returnValue = false;
        return false;
      }
    });
    return returnValue;
  },

  filter: function filter(predicate, context) {
    return reify(this, filterFactory(this, predicate, context, true));
  },

  find: function find(predicate, context, notSetValue) {
    var entry = this.findEntry(predicate, context);
    return entry ? entry[1] : notSetValue;
  },

  forEach: function forEach(sideEffect, context) {
    assertNotInfinite(this.size);
    return this.__iterate(context ? sideEffect.bind(context) : sideEffect);
  },

  join: function join(separator) {
    assertNotInfinite(this.size);
    separator = separator !== undefined ? '' + separator : ',';
    var joined = '';
    var isFirst = true;
    this.__iterate(function (v) {
      isFirst ? (isFirst = false) : (joined += separator);
      joined += v !== null && v !== undefined ? v.toString() : '';
    });
    return joined;
  },

  keys: function keys() {
    return this.__iterator(ITERATE_KEYS);
  },

  map: function map(mapper, context) {
    return reify(this, mapFactory(this, mapper, context));
  },

  reduce: function reduce$1(reducer, initialReduction, context) {
    return reduce(
      this,
      reducer,
      initialReduction,
      context,
      arguments.length < 2,
      false
    );
  },

  reduceRight: function reduceRight(reducer, initialReduction, context) {
    return reduce(
      this,
      reducer,
      initialReduction,
      context,
      arguments.length < 2,
      true
    );
  },

  reverse: function reverse() {
    return reify(this, reverseFactory(this, true));
  },

  slice: function slice(begin, end) {
    return reify(this, sliceFactory(this, begin, end, true));
  },

  some: function some(predicate, context) {
    return !this.every(not(predicate), context);
  },

  sort: function sort(comparator) {
    return reify(this, sortFactory(this, comparator));
  },

  values: function values() {
    return this.__iterator(ITERATE_VALUES);
  },

  // ### More sequential methods

  butLast: function butLast() {
    return this.slice(0, -1);
  },

  isEmpty: function isEmpty() {
    return this.size !== undefined ? this.size === 0 : !this.some(function () { return true; });
  },

  count: function count(predicate, context) {
    return ensureSize(
      predicate ? this.toSeq().filter(predicate, context) : this
    );
  },

  countBy: function countBy(grouper, context) {
    return countByFactory(this, grouper, context);
  },

  equals: function equals(other) {
    return deepEqual(this, other);
  },

  entrySeq: function entrySeq() {
    var collection = this;
    if (collection._cache) {
      // We cache as an entries array, so we can just return the cache!
      return new ArraySeq(collection._cache);
    }
    var entriesSequence = collection.toSeq().map(entryMapper).toIndexedSeq();
    entriesSequence.fromEntrySeq = function () { return collection.toSeq(); };

    // Entries are plain Array, which do not define toJS, so it must
    // manually converts keys and values before conversion.
    entriesSequence.toJS = function() {
      return this.map(function (entry) { return [toJS(entry[0]), toJS(entry[1])]; }).toJSON();
    };

    return entriesSequence;
  },

  filterNot: function filterNot(predicate, context) {
    return this.filter(not(predicate), context);
  },

  findEntry: function findEntry(predicate, context, notSetValue) {
    var found = notSetValue;
    this.__iterate(function (v, k, c) {
      if (predicate.call(context, v, k, c)) {
        found = [k, v];
        return false;
      }
    });
    return found;
  },

  findKey: function findKey(predicate, context) {
    var entry = this.findEntry(predicate, context);
    return entry && entry[0];
  },

  findLast: function findLast(predicate, context, notSetValue) {
    return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);
  },

  findLastEntry: function findLastEntry(predicate, context, notSetValue) {
    return this.toKeyedSeq()
      .reverse()
      .findEntry(predicate, context, notSetValue);
  },

  findLastKey: function findLastKey(predicate, context) {
    return this.toKeyedSeq().reverse().findKey(predicate, context);
  },

  first: function first() {
    return this.find(returnTrue);
  },

  flatMap: function flatMap(mapper, context) {
    return reify(this, flatMapFactory(this, mapper, context));
  },

  flatten: function flatten(depth) {
    return reify(this, flattenFactory(this, depth, true));
  },

  fromEntrySeq: function fromEntrySeq() {
    return new FromEntriesSequence(this);
  },

  get: function get(searchKey, notSetValue) {
    return this.find(function (_, key) { return is(key, searchKey); }, undefined, notSetValue);
  },

  getIn: function getIn(searchKeyPath, notSetValue) {
    var nested = this;
    var keyPath = coerceKeyPath(searchKeyPath);
    var i = 0;
    while (i !== keyPath.length) {
      if (!nested || !nested.get) {
        throw new TypeError(
          'Invalid keyPath: Value at [' +
            keyPath.slice(0, i).map(quoteString) +
            '] does not have a .get() method: ' +
            nested
        );
      }
      nested = nested.get(keyPath[i++], NOT_SET);
      if (nested === NOT_SET) {
        return notSetValue;
      }
    }
    return nested;
    // var step;
    // while (!(step = iter.next()).done) {
    //   var key = step.value;
    //   nested = nested && nested.get ? nested.get(key, NOT_SET) : NOT_SET;
    //   if (nested === NOT_SET) {
    //     return notSetValue;
    //   }
    // }
    // return nested;
  },

  groupBy: function groupBy(grouper, context) {
    return groupByFactory(this, grouper, context);
  },

  has: function has(searchKey) {
    return this.get(searchKey, NOT_SET) !== NOT_SET;
  },

  hasIn: function hasIn(searchKeyPath) {
    return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;
  },

  isSubset: function isSubset(iter) {
    iter = typeof iter.includes === 'function' ? iter : Collection(iter);
    return this.every(function (value) { return iter.includes(value); });
  },

  isSuperset: function isSuperset(iter) {
    iter = typeof iter.isSubset === 'function' ? iter : Collection(iter);
    return iter.isSubset(this);
  },

  keyOf: function keyOf(searchValue) {
    return this.findKey(function (value) { return is(value, searchValue); });
  },

  keySeq: function keySeq() {
    return this.toSeq().map(keyMapper).toIndexedSeq();
  },

  last: function last() {
    return this.toSeq().reverse().first();
  },

  lastKeyOf: function lastKeyOf(searchValue) {
    return this.toKeyedSeq().reverse().keyOf(searchValue);
  },

  max: function max(comparator) {
    return maxFactory(this, comparator);
  },

  maxBy: function maxBy(mapper, comparator) {
    return maxFactory(this, comparator, mapper);
  },

  min: function min(comparator) {
    return maxFactory(
      this,
      comparator ? neg(comparator) : defaultNegComparator
    );
  },

  minBy: function minBy(mapper, comparator) {
    return maxFactory(
      this,
      comparator ? neg(comparator) : defaultNegComparator,
      mapper
    );
  },

  rest: function rest() {
    return this.slice(1);
  },

  skip: function skip(amount) {
    return amount === 0 ? this : this.slice(Math.max(0, amount));
  },

  skipLast: function skipLast(amount) {
    return amount === 0 ? this : this.slice(0, -Math.max(0, amount));
  },

  skipWhile: function skipWhile(predicate, context) {
    return reify(this, skipWhileFactory(this, predicate, context, true));
  },

  skipUntil: function skipUntil(predicate, context) {
    return this.skipWhile(not(predicate), context);
  },

  sortBy: function sortBy(mapper, comparator) {
    return reify(this, sortFactory(this, comparator, mapper));
  },

  take: function take(amount) {
    return this.slice(0, Math.max(0, amount));
  },

  takeLast: function takeLast(amount) {
    return this.slice(-Math.max(0, amount));
  },

  takeWhile: function takeWhile(predicate, context) {
    return reify(this, takeWhileFactory(this, predicate, context));
  },

  takeUntil: function takeUntil(predicate, context) {
    return this.takeWhile(not(predicate), context);
  },

  update: function update(fn) {
    return fn(this);
  },

  valueSeq: function valueSeq() {
    return this.toIndexedSeq();
  },

  // ### Hashable Object

  hashCode: function hashCode() {
    return this.__hash || (this.__hash = hashCollection(this));
  }

  // ### Internal

  // abstract __iterate(fn, reverse)

  // abstract __iterator(type, reverse)
});

var CollectionPrototype = Collection.prototype;
CollectionPrototype[IS_ITERABLE_SENTINEL] = true;
CollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.values;
CollectionPrototype.toJSON = CollectionPrototype.toArray;
CollectionPrototype.__toStringMapper = quoteString;
CollectionPrototype.inspect = (CollectionPrototype.toSource = function() {
  return this.toString();
});
CollectionPrototype.chain = CollectionPrototype.flatMap;
CollectionPrototype.contains = CollectionPrototype.includes;

mixin(KeyedCollection, {
  // ### More sequential methods

  flip: function flip() {
    return reify(this, flipFactory(this));
  },

  mapEntries: function mapEntries(mapper, context) {
    var this$1 = this;

    var iterations = 0;
    return reify(
      this,
      this.toSeq()
        .map(function (v, k) { return mapper.call(context, [k, v], iterations++, this$1); })
        .fromEntrySeq()
    );
  },

  mapKeys: function mapKeys(mapper, context) {
    var this$1 = this;

    return reify(
      this,
      this.toSeq().flip().map(function (k, v) { return mapper.call(context, k, v, this$1); }).flip()
    );
  }
});

var KeyedCollectionPrototype = KeyedCollection.prototype;
KeyedCollectionPrototype[IS_KEYED_SENTINEL] = true;
KeyedCollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.entries;
KeyedCollectionPrototype.toJSON = CollectionPrototype.toObject;
KeyedCollectionPrototype.__toStringMapper = function (v, k) { return quoteString(k) + ': ' + quoteString(v); };

mixin(IndexedCollection, {
  // ### Conversion to other types

  toKeyedSeq: function toKeyedSeq() {
    return new ToKeyedSequence(this, false);
  },

  // ### ES6 Collection methods (ES6 Array and Map)

  filter: function filter(predicate, context) {
    return reify(this, filterFactory(this, predicate, context, false));
  },

  findIndex: function findIndex(predicate, context) {
    var entry = this.findEntry(predicate, context);
    return entry ? entry[0] : -1;
  },

  indexOf: function indexOf(searchValue) {
    var key = this.keyOf(searchValue);
    return key === undefined ? -1 : key;
  },

  lastIndexOf: function lastIndexOf(searchValue) {
    var key = this.lastKeyOf(searchValue);
    return key === undefined ? -1 : key;
  },

  reverse: function reverse() {
    return reify(this, reverseFactory(this, false));
  },

  slice: function slice(begin, end) {
    return reify(this, sliceFactory(this, begin, end, false));
  },

  splice: function splice(index, removeNum /*, ...values*/) {
    var numArgs = arguments.length;
    removeNum = Math.max(removeNum || 0, 0);
    if (numArgs === 0 || (numArgs === 2 && !removeNum)) {
      return this;
    }
    // If index is negative, it should resolve relative to the size of the
    // collection. However size may be expensive to compute if not cached, so
    // only call count() if the number is in fact negative.
    index = resolveBegin(index, index < 0 ? this.count() : this.size);
    var spliced = this.slice(0, index);
    return reify(
      this,
      numArgs === 1
        ? spliced
        : spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))
    );
  },

  // ### More collection methods

  findLastIndex: function findLastIndex(predicate, context) {
    var entry = this.findLastEntry(predicate, context);
    return entry ? entry[0] : -1;
  },

  first: function first() {
    return this.get(0);
  },

  flatten: function flatten(depth) {
    return reify(this, flattenFactory(this, depth, false));
  },

  get: function get(index, notSetValue) {
    index = wrapIndex(this, index);
    return index < 0 ||
      (this.size === Infinity || (this.size !== undefined && index > this.size))
      ? notSetValue
      : this.find(function (_, key) { return key === index; }, undefined, notSetValue);
  },

  has: function has(index) {
    index = wrapIndex(this, index);
    return index >= 0 &&
      (this.size !== undefined
        ? this.size === Infinity || index < this.size
        : this.indexOf(index) !== -1);
  },

  interpose: function interpose(separator) {
    return reify(this, interposeFactory(this, separator));
  },

  interleave: function interleave(/*...collections*/) {
    var collections = [this].concat(arrCopy(arguments));
    var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, collections);
    var interleaved = zipped.flatten(true);
    if (zipped.size) {
      interleaved.size = zipped.size * collections.length;
    }
    return reify(this, interleaved);
  },

  keySeq: function keySeq() {
    return Range(0, this.size);
  },

  last: function last() {
    return this.get(-1);
  },

  skipWhile: function skipWhile(predicate, context) {
    return reify(this, skipWhileFactory(this, predicate, context, false));
  },

  zip: function zip(/*, ...collections */) {
    var collections = [this].concat(arrCopy(arguments));
    return reify(this, zipWithFactory(this, defaultZipper, collections));
  },

  zipWith: function zipWith(zipper /*, ...collections */) {
    var collections = arrCopy(arguments);
    collections[0] = this;
    return reify(this, zipWithFactory(this, zipper, collections));
  }
});

var IndexedCollectionPrototype = IndexedCollection.prototype;
IndexedCollectionPrototype[IS_INDEXED_SENTINEL] = true;
IndexedCollectionPrototype[IS_ORDERED_SENTINEL] = true;

mixin(SetCollection, {
  // ### ES6 Collection methods (ES6 Array and Map)

  get: function get(value, notSetValue) {
    return this.has(value) ? value : notSetValue;
  },

  includes: function includes(value) {
    return this.has(value);
  },

  // ### More sequential methods

  keySeq: function keySeq() {
    return this.valueSeq();
  }
});

SetCollection.prototype.has = CollectionPrototype.includes;
SetCollection.prototype.contains = SetCollection.prototype.includes;

// Mixin subclasses

mixin(KeyedSeq, KeyedCollection.prototype);
mixin(IndexedSeq, IndexedCollection.prototype);
mixin(SetSeq, SetCollection.prototype);

// #pragma Helper functions

function reduce(collection, reducer, reduction, context, useFirst, reverse) {
  assertNotInfinite(collection.size);
  collection.__iterate(
    function (v, k, c) {
      if (useFirst) {
        useFirst = false;
        reduction = v;
      } else {
        reduction = reducer.call(context, reduction, v, k, c);
      }
    },
    reverse
  );
  return reduction;
}

function keyMapper(v, k) {
  return k;
}

function entryMapper(v, k) {
  return [k, v];
}

function toJS(value) {
  return value && typeof value.toJS === 'function' ? value.toJS() : value;
}

function not(predicate) {
  return function() {
    return !predicate.apply(this, arguments);
  };
}

function neg(predicate) {
  return function() {
    return -predicate.apply(this, arguments);
  };
}

function defaultZipper() {
  return arrCopy(arguments);
}

function defaultNegComparator(a, b) {
  return a < b ? 1 : a > b ? -1 : 0;
}

function hashCollection(collection) {
  if (collection.size === Infinity) {
    return 0;
  }
  var ordered = isOrdered(collection);
  var keyed = isKeyed(collection);
  var h = ordered ? 1 : 0;
  var size = collection.__iterate(
    keyed
      ? ordered
          ? function (v, k) {
              h = 31 * h + hashMerge(hash(v), hash(k)) | 0;
            }
          : function (v, k) {
              h = h + hashMerge(hash(v), hash(k)) | 0;
            }
      : ordered
          ? function (v) {
              h = 31 * h + hash(v) | 0;
            }
          : function (v) {
              h = h + hash(v) | 0;
            }
  );
  return murmurHashOfSize(size, h);
}

function murmurHashOfSize(size, h) {
  h = imul(h, 0xcc9e2d51);
  h = imul(h << 15 | h >>> -15, 0x1b873593);
  h = imul(h << 13 | h >>> -13, 5);
  h = (h + 0xe6546b64 | 0) ^ size;
  h = imul(h ^ h >>> 16, 0x85ebca6b);
  h = imul(h ^ h >>> 13, 0xc2b2ae35);
  h = smi(h ^ h >>> 16);
  return h;
}

function hashMerge(a, b) {
  return a ^ b + 0x9e3779b9 + (a << 6) + (a >> 2) | 0; // int
}

var OrderedSet = (function (Set$$1) {
  function OrderedSet(value) {
    return value === null || value === undefined
      ? emptyOrderedSet()
      : isOrderedSet(value)
          ? value
          : emptyOrderedSet().withMutations(function (set) {
              var iter = SetCollection(value);
              assertNotInfinite(iter.size);
              iter.forEach(function (v) { return set.add(v); });
            });
  }

  if ( Set$$1 ) OrderedSet.__proto__ = Set$$1;
  OrderedSet.prototype = Object.create( Set$$1 && Set$$1.prototype );
  OrderedSet.prototype.constructor = OrderedSet;

  OrderedSet.of = function of (/*...values*/) {
    return this(arguments);
  };

  OrderedSet.fromKeys = function fromKeys (value) {
    return this(KeyedCollection(value).keySeq());
  };

  OrderedSet.prototype.toString = function toString () {
    return this.__toString('OrderedSet {', '}');
  };

  return OrderedSet;
}(Set));

function isOrderedSet(maybeOrderedSet) {
  return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);
}

OrderedSet.isOrderedSet = isOrderedSet;

var OrderedSetPrototype = OrderedSet.prototype;
OrderedSetPrototype[IS_ORDERED_SENTINEL] = true;
OrderedSetPrototype.zip = IndexedCollectionPrototype.zip;
OrderedSetPrototype.zipWith = IndexedCollectionPrototype.zipWith;

OrderedSetPrototype.__empty = emptyOrderedSet;
OrderedSetPrototype.__make = makeOrderedSet;

function makeOrderedSet(map, ownerID) {
  var set = Object.create(OrderedSetPrototype);
  set.size = map ? map.size : 0;
  set._map = map;
  set.__ownerID = ownerID;
  return set;
}

var EMPTY_ORDERED_SET;
function emptyOrderedSet() {
  return EMPTY_ORDERED_SET ||
    (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));
}

var Record = function Record(defaultValues, name) {
  var hasInitialized;

  var RecordType = function Record(values) {
    var this$1 = this;

    if (values instanceof RecordType) {
      return values;
    }
    if (!(this instanceof RecordType)) {
      return new RecordType(values);
    }
    if (!hasInitialized) {
      hasInitialized = true;
      var keys = Object.keys(defaultValues);
      var indices = (RecordTypePrototype._indices = {});
      RecordTypePrototype._name = name;
      RecordTypePrototype._keys = keys;
      RecordTypePrototype._defaultValues = defaultValues;
      for (var i = 0; i < keys.length; i++) {
        var propName = keys[i];
        indices[propName] = i;
        if (RecordTypePrototype[propName]) {
          /* eslint-disable no-console */
          typeof console === 'object' &&
            console.warn &&
            console.warn(
              'Cannot define ' +
                recordName(this$1) +
                ' with property "' +
                propName +
                '" since that property name is part of the Record API.'
            );
          /* eslint-enable no-console */
        } else {
          setProp(RecordTypePrototype, propName);
        }
      }
    }
    this.__ownerID = undefined;
    this._values = List().withMutations(function (l) {
      l.setSize(this$1._keys.length);
      KeyedCollection(values).forEach(function (v, k) {
        l.set(this$1._indices[k], v === this$1._defaultValues[k] ? undefined : v);
      });
    });
  };

  var RecordTypePrototype = (RecordType.prototype = Object.create(
    RecordPrototype
  ));
  RecordTypePrototype.constructor = RecordType;

  return RecordType;
};

Record.prototype.toString = function toString () {
    var this$1 = this;

  var str = recordName(this) + ' { ';
  var keys = this._keys;
  var k;
  for (var i = 0, l = keys.length; i !== l; i++) {
    k = keys[i];
    str += (i ? ', ' : '') + k + ': ' + quoteString(this$1.get(k));
  }
  return str + ' }';
};

Record.prototype.equals = function equals (other) {
  return this === other ||
    (this._keys === other._keys && recordSeq(this).equals(recordSeq(other)));
};

Record.prototype.hashCode = function hashCode () {
  return recordSeq(this).hashCode();
};

// @pragma Access

Record.prototype.has = function has (k) {
  return this._indices.hasOwnProperty(k);
};

Record.prototype.get = function get (k, notSetValue) {
  if (!this.has(k)) {
    return notSetValue;
  }
  var index = this._indices[k];
  var value = this._values.get(index);
  return value === undefined ? this._defaultValues[k] : value;
};

// @pragma Modification

Record.prototype.set = function set (k, v) {
  if (this.has(k)) {
    var newValues = this._values.set(
      this._indices[k],
      v === this._defaultValues[k] ? undefined : v
    );
    if (newValues !== this._values && !this.__ownerID) {
      return makeRecord(this, newValues);
    }
  }
  return this;
};

Record.prototype.remove = function remove (k) {
  return this.set(k);
};

Record.prototype.clear = function clear () {
  var newValues = this._values.clear().setSize(this._keys.length);
  return this.__ownerID ? this : makeRecord(this, newValues);
};

Record.prototype.wasAltered = function wasAltered () {
  return this._values.wasAltered();
};

Record.prototype.toSeq = function toSeq () {
  return recordSeq(this);
};

Record.prototype.toJS = function toJS () {
  return recordSeq(this).toJS();
};

Record.prototype.__iterator = function __iterator (type, reverse) {
  return recordSeq(this).__iterator(type, reverse);
};

Record.prototype.__iterate = function __iterate (fn, reverse) {
  return recordSeq(this).__iterate(fn, reverse);
};

Record.prototype.__ensureOwner = function __ensureOwner (ownerID) {
  if (ownerID === this.__ownerID) {
    return this;
  }
  var newValues = this._values.__ensureOwner(ownerID);
  if (!ownerID) {
    this.__ownerID = ownerID;
    this._values = newValues;
    return this;
  }
  return makeRecord(this, newValues, ownerID);
};

Record.isRecord = isRecord;
Record.getDescriptiveName = recordName;
var RecordPrototype = Record.prototype;
RecordPrototype[IS_RECORD_SENTINEL] = true;
RecordPrototype[DELETE] = RecordPrototype.remove;
RecordPrototype.getIn = CollectionPrototype.getIn;
RecordPrototype.hasIn = CollectionPrototype.hasIn;
RecordPrototype.merge = MapPrototype.merge;
RecordPrototype.mergeWith = MapPrototype.mergeWith;
RecordPrototype.mergeIn = MapPrototype.mergeIn;
RecordPrototype.mergeDeep = MapPrototype.mergeDeep;
RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;
RecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
RecordPrototype.setIn = MapPrototype.setIn;
RecordPrototype.update = MapPrototype.update;
RecordPrototype.updateIn = MapPrototype.updateIn;
RecordPrototype.withMutations = MapPrototype.withMutations;
RecordPrototype.asMutable = MapPrototype.asMutable;
RecordPrototype.asImmutable = MapPrototype.asImmutable;
RecordPrototype[ITERATOR_SYMBOL] = CollectionPrototype.entries;
RecordPrototype.toJSON = (RecordPrototype.toObject = CollectionPrototype.toObject);
RecordPrototype.inspect = (RecordPrototype.toSource = CollectionPrototype.toSource);

function makeRecord(likeRecord, values, ownerID) {
  var record = Object.create(Object.getPrototypeOf(likeRecord));
  record._values = values;
  record.__ownerID = ownerID;
  return record;
}

function recordName(record) {
  return record._name || record.constructor.name || 'Record';
}

function recordSeq(record) {
  return keyedSeqFromValue(record._keys.map(function (k) { return [k, record.get(k)]; }));
}

function setProp(prototype, name) {
  try {
    Object.defineProperty(prototype, name, {
      get: function() {
        return this.get(name);
      },
      set: function(value) {
        invariant(this.__ownerID, 'Cannot set on an immutable record.');
        this.set(name, value);
      }
    });
  } catch (error) {
    // Object.defineProperty failed. Probably IE8.
  }
}

/**
 * Returns a lazy Seq of `value` repeated `times` times. When `times` is
 * undefined, returns an infinite sequence of `value`.
 */
var Repeat = (function (IndexedSeq$$1) {
  function Repeat(value, times) {
    if (!(this instanceof Repeat)) {
      return new Repeat(value, times);
    }
    this._value = value;
    this.size = times === undefined ? Infinity : Math.max(0, times);
    if (this.size === 0) {
      if (EMPTY_REPEAT) {
        return EMPTY_REPEAT;
      }
      EMPTY_REPEAT = this;
    }
  }

  if ( IndexedSeq$$1 ) Repeat.__proto__ = IndexedSeq$$1;
  Repeat.prototype = Object.create( IndexedSeq$$1 && IndexedSeq$$1.prototype );
  Repeat.prototype.constructor = Repeat;

  Repeat.prototype.toString = function toString () {
    if (this.size === 0) {
      return 'Repeat []';
    }
    return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';
  };

  Repeat.prototype.get = function get (index, notSetValue) {
    return this.has(index) ? this._value : notSetValue;
  };

  Repeat.prototype.includes = function includes (searchValue) {
    return is(this._value, searchValue);
  };

  Repeat.prototype.slice = function slice (begin, end) {
    var size = this.size;
    return wholeSlice(begin, end, size)
      ? this
      : new Repeat(
          this._value,
          resolveEnd(end, size) - resolveBegin(begin, size)
        );
  };

  Repeat.prototype.reverse = function reverse () {
    return this;
  };

  Repeat.prototype.indexOf = function indexOf (searchValue) {
    if (is(this._value, searchValue)) {
      return 0;
    }
    return -1;
  };

  Repeat.prototype.lastIndexOf = function lastIndexOf (searchValue) {
    if (is(this._value, searchValue)) {
      return this.size;
    }
    return -1;
  };

  Repeat.prototype.__iterate = function __iterate (fn, reverse) {
    var this$1 = this;

    var size = this.size;
    var i = 0;
    while (i !== size) {
      if (fn(this$1._value, reverse ? size - ++i : i++, this$1) === false) {
        break;
      }
    }
    return i;
  };

  Repeat.prototype.__iterator = function __iterator (type, reverse) {
    var this$1 = this;

    var size = this.size;
    var i = 0;
    return new Iterator(
      function () { return i === size
          ? iteratorDone()
          : iteratorValue(type, reverse ? size - ++i : i++, this$1._value); }
    );
  };

  Repeat.prototype.equals = function equals (other) {
    return other instanceof Repeat
      ? is(this._value, other._value)
      : deepEqual(other);
  };

  return Repeat;
}(IndexedSeq));

var EMPTY_REPEAT;

var Immutable = {
  Collection: Collection,
  // Note: Iterable is deprecated
  Iterable: Collection,

  Seq: Seq,
  Map: Map,
  OrderedMap: OrderedMap,
  List: List,
  Stack: Stack,
  Set: Set,
  OrderedSet: OrderedSet,

  Record: Record,
  Range: Range,
  Repeat: Repeat,

  is: is,
  fromJS: fromJS,
  hash: hash,

  isImmutable: isImmutable,
  isCollection: isCollection,
  isKeyed: isKeyed,
  isIndexed: isIndexed,
  isAssociative: isAssociative,
  isOrdered: isOrdered,
  isValueObject: isValueObject
};

// Note: Iterable is deprecated
var Iterable = Collection;

exports['default'] = Immutable;
exports.Collection = Collection;
exports.Iterable = Iterable;
exports.Seq = Seq;
exports.Map = Map;
exports.OrderedMap = OrderedMap;
exports.List = List;
exports.Stack = Stack;
exports.Set = Set;
exports.OrderedSet = OrderedSet;
exports.Record = Record;
exports.Range = Range;
exports.Repeat = Repeat;
exports.is = is;
exports.fromJS = fromJS;
exports.hash = hash;
exports.isImmutable = isImmutable;
exports.isCollection = isCollection;
exports.isKeyed = isKeyed;
exports.isIndexed = isIndexed;
exports.isAssociative = isAssociative;
exports.isOrdered = isOrdered;
exports.isValueObject = isValueObject;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],2:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

Object.defineProperty(exports, "__esModule", { value: true });
var datatypes_1 = require("./datatypes");
var immutable_1 = require("immutable");
var face_vertices = immutable_1.Map([[datatypes_1.Face.t, datatypes_1.make_matrix2([[0, 1, 2], [9, 25, 15], [16, 24, 22]])], [datatypes_1.Face.b, datatypes_1.make_matrix2([[20, 19, 18], [13, 12, 11], [8, 7, 6]])], [datatypes_1.Face.n, datatypes_1.make_matrix2([[2, 1, 0], [5, 4, 3], [8, 7, 6]])], [datatypes_1.Face.e, datatypes_1.make_matrix2([[22, 15, 2], [21, 14, 5], [20, 13, 8]])], [datatypes_1.Face.s, datatypes_1.make_matrix2([[16, 24, 22], [17, 23, 21], [18, 19, 20]])], [datatypes_1.Face.w, datatypes_1.make_matrix2([[0, 9, 16], [3, 10, 17], [6, 11, 18]])]]);
var face_quadrants = immutable_1.Map([[datatypes_1.Face.t, datatypes_1.make_matrix2([[0, 1], [2, 3]])], [datatypes_1.Face.b, datatypes_1.make_matrix2([[4, 5], [6, 7]])], [datatypes_1.Face.n, datatypes_1.make_matrix2([[8, 9], [10, 11]])], [datatypes_1.Face.e, datatypes_1.make_matrix2([[12, 13], [14, 15]])], [datatypes_1.Face.s, datatypes_1.make_matrix2([[16, 17], [18, 19]])], [datatypes_1.Face.w, datatypes_1.make_matrix2([[20, 21], [22, 23]])]]);
function build_edge_quadrant_mappings() {
    var quadrant_2_edges = immutable_1.Map();
    var edge_2_quadrants = immutable_1.Map();
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        var _loop = function _loop() {
            var f = _step.value;

            var vs = face_vertices.get(f);
            var qs = face_quadrants.get(f);
            var _arr = [[0, 0], [1, 0], [0, 1], [1, 1]];

            var _loop2 = function _loop2() {
                var _arr$_i = _slicedToArray(_arr[_i], 2),
                    x = _arr$_i[0],
                    y = _arr$_i[1];

                var q_edges = get_quadrant_edges(vs, x, y);
                quadrant_2_edges = quadrant_2_edges.set(qs.get(x, y), q_edges);
                q_edges.forEach(function (qe) {
                    var q = qs.get(x, y);
                    if (edge_2_quadrants.has(qe)) {
                        edge_2_quadrants = edge_2_quadrants.update(qe, function (xs) {
                            return xs.push(q);
                        });
                    } else {
                        edge_2_quadrants = edge_2_quadrants.set(qe, immutable_1.List([q]));
                    }
                });
            };

            for (var _i = 0; _i < _arr.length; _i++) {
                _loop2();
            }
        };

        for (var _iterator = datatypes_1.faces[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            _loop();
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    return [quadrant_2_edges, edge_2_quadrants];
}
function get_quadrant_edges(m, x, y) {
    var offsets = [[0, 0, 0, 1], [0, 0, 1, 0], [1, 1, 0, 1], [1, 1, 1, 0]];
    var edges = immutable_1.List();
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
        for (var _iterator2 = offsets[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var _step2$value = _slicedToArray(_step2.value, 4),
                x1 = _step2$value[0],
                y1 = _step2$value[1],
                x2 = _step2$value[2],
                y2 = _step2$value[3];

            var e1 = m.get(x + x1, y + y1);
            var e2 = m.get(x + x2, y + y2);
            if (e2 < e1) {
                edges = edges.push(new datatypes_1.Edge(e2, e1));
            } else {
                edges = edges.push(new datatypes_1.Edge(e1, e2));
            }
        }
    } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
            }
        } finally {
            if (_didIteratorError2) {
                throw _iteratorError2;
            }
        }
    }

    return edges;
}
_a = build_edge_quadrant_mappings(), exports.quadrant_2_edges = _a[0], exports.edge_2_quadrants = _a[1];
function get_quadrant_partition(quadrant, cut_edges) {
    var current_partition = immutable_1.Set([quadrant]).asMutable();
    var horizon = immutable_1.List(exports.quadrant_2_edges.get(quadrant)).asMutable();
    while (horizon.size > 0) {
        var e = horizon.first();
        horizon = horizon.shift();
        if (cut_edges.contains(e)) {
            continue;
        }
        var next_qs = immutable_1.Set(exports.edge_2_quadrants.get(e));
        var new_qs = next_qs.subtract(current_partition);
        if (new_qs.size > 0) {
            new_qs.forEach(function (q) {
                var _horizon;

                (_horizon = horizon).push.apply(_horizon, _toConsumableArray(exports.quadrant_2_edges.get(q).toArray()));
                current_partition.add(q);
            });
        }
    }
    return current_partition.asImmutable();
}
function range(x) {
    var arr = [];
    for (var i = 0; i < x; i++) {
        arr.push(i);
    }
    return arr;
}
function get_partitions(cut_edges) {
    var partitions = immutable_1.List().asMutable();
    var quadrants = immutable_1.Set(range(24)).asMutable();
    while (quadrants.size > 0) {
        var q = quadrants.first();
        quadrants.remove(q);
        var partition = get_quadrant_partition(q, cut_edges);
        partitions.push(partition);
        quadrants.subtract(partition);
    }
    return partitions.asImmutable();
}

var FaceMesh = function () {
    function FaceMesh(vertices, quadrants) {
        _classCallCheck(this, FaceMesh);

        this.vertices = vertices;
        this.quadrants = quadrants;
    }

    _createClass(FaceMesh, [{
        key: "rotate",
        value: function rotate(degrees) {
            return new FaceMesh(this.vertices.rotate(degrees), this.quadrants.rotate(degrees));
        }
    }]);

    return FaceMesh;
}();

exports.FaceMesh = FaceMesh;

var BoxMesh = function () {
    function BoxMesh(_ref) {
        var dimensions = _ref.dimensions,
            face_meshes = _ref.face_meshes,
            cut_edges = _ref.cut_edges;

        _classCallCheck(this, BoxMesh);

        this.dimensions = dimensions;
        if (face_meshes === undefined) {
            face_meshes = immutable_1.Map();
            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
                for (var _iterator3 = datatypes_1.faces[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                    var f = _step3.value;

                    face_meshes = face_meshes.set(f, new FaceMesh(face_vertices.get(f), face_quadrants.get(f)));
                }
            } catch (err) {
                _didIteratorError3 = true;
                _iteratorError3 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion3 && _iterator3.return) {
                        _iterator3.return();
                    }
                } finally {
                    if (_didIteratorError3) {
                        throw _iteratorError3;
                    }
                }
            }
        }
        this.face_meshes = face_meshes;
        if (cut_edges === undefined) {
            cut_edges = immutable_1.List();
        }
        this.cut_edges = cut_edges;
    }

    _createClass(BoxMesh, [{
        key: "update",
        value: function update(_ref2) {
            var dimensions = _ref2.dimensions,
                face_meshes = _ref2.face_meshes,
                cut_edges = _ref2.cut_edges;

            if (dimensions === undefined) {
                dimensions = this.dimensions;
            }
            if (face_meshes === undefined) {
                face_meshes = this.face_meshes;
            }
            if (cut_edges === undefined) {
                cut_edges = this.cut_edges;
            }
            return new BoxMesh({ dimensions: dimensions, face_meshes: face_meshes, cut_edges: cut_edges });
        }
    }, {
        key: "cut",
        value: function cut(face, start, end) {
            return this.cut_or_tape(datatypes_1.EdgeOperation.cut, face, start, end);
        }
    }, {
        key: "tape",
        value: function tape(face, start, end) {
            return this.cut_or_tape(datatypes_1.EdgeOperation.tape, face, start, end);
        }
    }, {
        key: "cut_or_tape",
        value: function cut_or_tape(operation, face, start, end) {
            var _start = _slicedToArray(start, 2),
                x1 = _start[0],
                y1 = _start[1];

            var _end = _slicedToArray(end, 2),
                x2 = _end[0],
                y2 = _end[1];

            if (Math.abs(x2 - x1) + Math.abs(y2 - y1) != 1) {
                throw "start and end points of cut/tape are not adjacent: " + start + " and " + end;
            }
            var f = this.face_meshes.get(face).vertices;
            var fs = f.get(x1, y1);
            var fe = f.get(x2, y2);
            var new_edge = new datatypes_1.Edge(fs, fe);
            var new_cut_edges = this.cut_edges;
            if (operation == datatypes_1.EdgeOperation.cut && !new_cut_edges.contains(new_edge)) {
                new_cut_edges = new_cut_edges.push(new_edge);
            }
            if (operation == datatypes_1.EdgeOperation.tape && new_cut_edges.contains(new_edge)) {
                new_cut_edges = new_cut_edges.remove(new_cut_edges.indexOf(new_edge));
            }
            return this.update({ cut_edges: new_cut_edges });
        }
    }, {
        key: "get_rends",
        value: function get_rends() {
            return get_partitions(this.cut_edges);
        }
    }, {
        key: "get_free_rends",
        value: function get_free_rends() {
            var _this = this;

            return this.get_rends().filter(function (x) {
                return !_this.is_partition_fixed(x);
            });
        }
    }, {
        key: "is_partition_fixed",
        value: function is_partition_fixed(partition) {
            var face_membership = this.get_partition_face_membership(partition);
            return face_membership.get(datatypes_1.Face.b) > 0;
        }
    }, {
        key: "get_partition_face_membership",
        value: function get_partition_face_membership(partition) {
            var _this2 = this;

            var face_membership = immutable_1.Map().asMutable();
            var _iteratorNormalCompletion4 = true;
            var _didIteratorError4 = false;
            var _iteratorError4 = undefined;

            try {
                var _loop3 = function _loop3() {
                    var f = _step4.value;

                    var total = 0;
                    var quadrants = _this2.face_meshes.get(f).quadrants;
                    partition.forEach(function (q) {
                        if (quadrants.contains(q)) {
                            total += 1;
                        }
                    });
                    face_membership.set(f, total);
                };

                for (var _iterator4 = datatypes_1.faces[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                    _loop3();
                }
            } catch (err) {
                _didIteratorError4 = true;
                _iteratorError4 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion4 && _iterator4.return) {
                        _iterator4.return();
                    }
                } finally {
                    if (_didIteratorError4) {
                        throw _iteratorError4;
                    }
                }
            }

            return face_membership.asImmutable();
        }
    }, {
        key: "get_quadrant_face",
        value: function get_quadrant_face(quadrant) {
            var _iteratorNormalCompletion5 = true;
            var _didIteratorError5 = false;
            var _iteratorError5 = undefined;

            try {
                for (var _iterator5 = datatypes_1.faces[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                    var f = _step5.value;

                    if (this.face_meshes.get(f).quadrants.contains(quadrant)) {
                        return f;
                    }
                }
            } catch (err) {
                _didIteratorError5 = true;
                _iteratorError5 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion5 && _iterator5.return) {
                        _iterator5.return();
                    }
                } finally {
                    if (_didIteratorError5) {
                        throw _iteratorError5;
                    }
                }
            }
        }
    }, {
        key: "get_dangles",
        value: function get_dangles() {
            var _this3 = this;

            var rends = this.get_rends();
            var fixed_rends = rends.filter(function (x) {
                return _this3.is_partition_fixed(x);
            });
            var dangles = immutable_1.List().asMutable();
            var inner_this = this;
            this.get_box_edges().forEach(function (_ref3) {
                var _dangles;

                var _ref4 = _slicedToArray(_ref3, 2),
                    e1 = _ref4[0],
                    e2 = _ref4[1];

                var e_2_q_2_f = immutable_1.Map().asMutable();
                var _arr2 = [e1, e2];

                var _loop4 = function _loop4() {
                    var e = _arr2[_i2];
                    var inner_map = immutable_1.Map().asMutable();
                    exports.edge_2_quadrants.get(e).forEach(function (q) {
                        inner_map.set(q, inner_this.get_quadrant_face(q));
                    });
                    inner_map = inner_map.asImmutable();
                    e_2_q_2_f.set(e, inner_map);
                };

                for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
                    _loop4();
                }
                e_2_q_2_f = e_2_q_2_f.asImmutable();
                var edge_dangles = immutable_1.List().asMutable();
                var _arr3 = [[e1, e2], [e1], [e2]];

                var _loop5 = function _loop5() {
                    var _inner_this$cut_edges;

                    var es = _arr3[_i3];
                    var new_cut_edges = (_inner_this$cut_edges = inner_this.cut_edges).push.apply(_inner_this$cut_edges, _toConsumableArray(es));
                    var new_partitions = get_partitions(new_cut_edges);
                    if (new_partitions.size != rends.size) {
                        new_partitions.forEach(function (np) {
                            if (rends.contains(np)) {
                                return;
                            }
                            if (inner_this.is_partition_fixed(np)) {
                                return;
                            }
                            var any_intersections = false;
                            fixed_rends.forEach(function (fixed_rend) {
                                if (np.intersect(fixed_rend).size > 0) {
                                    any_intersections = true;
                                }
                            });
                            if (!any_intersections) {
                                return;
                            }
                            var any_dangle_matches = false;
                            edge_dangles.forEach(function (ed) {
                                if (immutable_1.is(np, ed.partition)) {
                                    any_dangle_matches = true;
                                    return;
                                }
                            });
                            if (any_dangle_matches) {
                                return;
                            }
                            var q_2_fs = immutable_1.List().asMutable();
                            var _iteratorNormalCompletion6 = true;
                            var _didIteratorError6 = false;
                            var _iteratorError6 = undefined;

                            try {
                                for (var _iterator6 = es[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
                                    var e = _step6.value;

                                    q_2_fs.push(e_2_q_2_f.get(e));
                                }
                            } catch (err) {
                                _didIteratorError6 = true;
                                _iteratorError6 = err;
                            } finally {
                                try {
                                    if (!_iteratorNormalCompletion6 && _iterator6.return) {
                                        _iterator6.return();
                                    }
                                } finally {
                                    if (_didIteratorError6) {
                                        throw _iteratorError6;
                                    }
                                }
                            }

                            q_2_fs = q_2_fs.asImmutable();
                            var fixed_fs = immutable_1.List().asMutable();
                            var dangle_fs = immutable_1.List().asMutable();
                            q_2_fs.forEach(function (q_2_f) {
                                q_2_f.entrySeq().forEach(function (_ref5) {
                                    var _ref6 = _slicedToArray(_ref5, 2),
                                        q = _ref6[0],
                                        f = _ref6[1];

                                    if (np.contains(q)) {
                                        dangle_fs = dangle_fs.push(f);
                                    } else {
                                        fixed_fs = fixed_fs.push(f);
                                    }
                                });
                            });
                            fixed_fs = fixed_fs.asImmutable();
                            dangle_fs = dangle_fs.asImmutable();
                            if (fixed_fs.toSet().size != 1 || dangle_fs.toSet().size != 1) {
                                return;
                            }
                            edge_dangles.push(new datatypes_1.Dangle(np, es, fixed_fs.get(0), dangle_fs.get(0)));
                        });
                    }
                };

                for (var _i3 = 0; _i3 < _arr3.length; _i3++) {
                    _loop5();
                }
                edge_dangles = edge_dangles.asImmutable();
                (_dangles = dangles).push.apply(_dangles, _toConsumableArray(edge_dangles.toArray()));
            });
            dangles = immutable_1.List(dangles.sortBy(function (x) {
                return x.partition.size;
            }));
            var final_dangles = immutable_1.List().asMutable();

            var _loop6 = function _loop6(i) {
                var p = dangles.get(i).partition;
                var any_supersets = false;
                dangles.skip(i + 1).forEach(function (d) {
                    if (p.isSubset(d.partition)) {
                        any_supersets = true;
                    }
                });
                if (!any_supersets) {
                    final_dangles.push(dangles.get(i));
                }
            };

            for (var i = 0; i < dangles.size; i++) {
                _loop6(i);
            }
            final_dangles = final_dangles.asImmutable();
            return final_dangles;
        }
    }, {
        key: "get_box_edges",
        value: function get_box_edges() {
            var edges = immutable_1.List();
            var t_b_edge_coords = [[[0, 0], [0, 1], [0, 2]], [[0, 0], [1, 0], [2, 0]], [[2, 0], [2, 1], [2, 2]], [[0, 2], [1, 2], [2, 2]]];
            var _arr4 = [datatypes_1.Face.t, datatypes_1.Face.b];
            for (var _i4 = 0; _i4 < _arr4.length; _i4++) {
                var f = _arr4[_i4];
                var m = this.face_meshes.get(f).vertices;
                var _iteratorNormalCompletion7 = true;
                var _didIteratorError7 = false;
                var _iteratorError7 = undefined;

                try {
                    for (var _iterator7 = t_b_edge_coords[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
                        var _step7$value = _slicedToArray(_step7.value, 3),
                            _step7$value$ = _slicedToArray(_step7$value[0], 2),
                            p1x = _step7$value$[0],
                            p1y = _step7$value$[1],
                            _step7$value$2 = _slicedToArray(_step7$value[1], 2),
                            p2x = _step7$value$2[0],
                            p2y = _step7$value$2[1],
                            _step7$value$3 = _slicedToArray(_step7$value[2], 2),
                            p3x = _step7$value$3[0],
                            p3y = _step7$value$3[1];

                        var v1 = m.get(p1x, p1y);
                        var v2 = m.get(p2x, p2y);
                        var v3 = m.get(p3x, p3y);
                        var e1 = new datatypes_1.Edge(v1, v2);
                        var e2 = new datatypes_1.Edge(v2, v3);
                        edges = edges.push([e1, e2]);
                    }
                } catch (err) {
                    _didIteratorError7 = true;
                    _iteratorError7 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion7 && _iterator7.return) {
                            _iterator7.return();
                        }
                    } finally {
                        if (_didIteratorError7) {
                            throw _iteratorError7;
                        }
                    }
                }
            }
            var _arr5 = [datatypes_1.Face.n, datatypes_1.Face.e, datatypes_1.Face.s, datatypes_1.Face.w];
            for (var _i5 = 0; _i5 < _arr5.length; _i5++) {
                var _f = _arr5[_i5];
                var _m = this.face_meshes.get(_f).vertices;
                var _v = _m.get(0, 0);
                var _v2 = _m.get(0, 1);
                var _v3 = _m.get(0, 2);
                var _e = new datatypes_1.Edge(_v, _v2);
                var _e2 = new datatypes_1.Edge(_v2, _v3);
                edges = edges.push([_e, _e2]);
            }
            return edges;
        }
    }, {
        key: "rotate_y",
        value: function rotate_y(degrees) {
            //validate degrees somehow
            if (degrees == 0 || degrees == 360) {
                return this;
            }
            var new_faces = rotate_y_faces(this.face_meshes, degrees);
            if (degrees = 180) {
                return this.update({ face_meshes: new_faces });
            } else {
                var _dimensions = _slicedToArray(this.dimensions, 3),
                    _x = _dimensions[0],
                    _y = _dimensions[1],
                    z = _dimensions[2];

                return this.update({ dimensions: [z, _y, _x], face_meshes: new_faces });
            }
        }
    }, {
        key: "roll",
        value: function roll(direction) {
            var _dimensions2 = _slicedToArray(this.dimensions, 3),
                x = _dimensions2[0],
                y = _dimensions2[1],
                z = _dimensions2[2];

            var new_x = void 0,
                new_y = void 0,
                new_z = void 0;
            if (direction == datatypes_1.Direction.n || direction == datatypes_1.Direction.s) {
                new_x = x;
                new_y = y;
                new_z = z;
            } else {
                new_x = y;
                new_y = x;
                new_z = z;
            }
            var new_faces = roll_faces(this.face_meshes, direction);
            return this.update({ dimensions: [new_x, new_y, new_z], face_meshes: new_faces });
        }
    }, {
        key: "description",
        value: function description() {
            var face_descr = immutable_1.Map([[datatypes_1.Face.t, 'top'], [datatypes_1.Face.b, 'bottom'], [datatypes_1.Face.n, 'back'], [datatypes_1.Face.e, 'right'], [datatypes_1.Face.s, 'front'], [datatypes_1.Face.w, 'left']]);

            var _dimensions3 = _slicedToArray(this.dimensions, 3),
                x = _dimensions3[0],
                y = _dimensions3[1],
                z = _dimensions3[2];

            var result = "The box's dimensions measure " + x + " by " + y + " by " + z;
            var rends = this.get_free_rends();
            var inner_this = this;
            rends.forEach(function (fr) {
                var face_membership = inner_this.get_partition_face_membership(fr);
                var faces_present = [];
                var _iteratorNormalCompletion8 = true;
                var _didIteratorError8 = false;
                var _iteratorError8 = undefined;

                try {
                    for (var _iterator8 = datatypes_1.faces[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
                        var f = _step8.value;

                        if (face_membership.get(f) > 0) {
                            faces_present.push(f);
                        }
                    }
                } catch (err) {
                    _didIteratorError8 = true;
                    _iteratorError8 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion8 && _iterator8.return) {
                            _iterator8.return();
                        }
                    } finally {
                        if (_didIteratorError8) {
                            throw _iteratorError8;
                        }
                    }
                }

                var faces_text = void 0;
                if (faces_present.length == 1) {
                    faces_text = face_descr.get(faces_present[0]) + ' face';
                } else {
                    faces_text = faces_present.slice(0, -1).map(function (f) {
                        return face_descr.get(f);
                    }).join(', ');
                    faces_text += " and " + face_descr.get(faces_present[faces_present.length - 1]) + " faces";
                }
                result += "\nA portion of the box's " + faces_text + " has been rended free; it lies on the floor off to the side.";
            });
            var dangles = this.get_dangles();
            dangles.forEach(function (d) {
                var face_membership = inner_this.get_partition_face_membership(d.partition);
                var faces_present = [];
                var _iteratorNormalCompletion9 = true;
                var _didIteratorError9 = false;
                var _iteratorError9 = undefined;

                try {
                    for (var _iterator9 = datatypes_1.faces[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
                        var f = _step9.value;

                        if (face_membership.get(f) > 0) {
                            faces_present.push(f);
                        }
                    }
                } catch (err) {
                    _didIteratorError9 = true;
                    _iteratorError9 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion9 && _iterator9.return) {
                            _iterator9.return();
                        }
                    } finally {
                        if (_didIteratorError9) {
                            throw _iteratorError9;
                        }
                    }
                }

                var faces_text = void 0;
                if (faces_present.length == 1) {
                    faces_text = face_descr.get(faces_present[0]) + ' face';
                } else {
                    faces_text = faces_present.slice(0, -1).map(function (f) {
                        return face_descr.get(f);
                    }).join(', ');
                    faces_text += " and " + face_descr.get(faces_present[faces_present.length - 1]) + " faces";
                }
                result += "\nA portion of the box's " + faces_text + " sits on a free hinge; from the " + face_descr.get(d.free_face) + " face it can be swung to the " + face_descr.get(d.fixed_face) + ".";
            });
            return result;
        }
    }]);

    return BoxMesh;
}();

exports.BoxMesh = BoxMesh;
function rotate_y_faces(fs, degrees) {
    if (degrees == 0 || degrees == 360) {
        return fs;
    }
    var shift = degrees / 90;
    var face_cycle = [datatypes_1.Face.n, datatypes_1.Face.w, datatypes_1.Face.s, datatypes_1.Face.e, datatypes_1.Face.n, datatypes_1.Face.w, datatypes_1.Face.s, datatypes_1.Face.e];
    var new_faces = immutable_1.Map();
    var _arr6 = [datatypes_1.Face.n, datatypes_1.Face.e, datatypes_1.Face.s, datatypes_1.Face.w];
    for (var _i6 = 0; _i6 < _arr6.length; _i6++) {
        var f = _arr6[_i6];
        var ind = face_cycle.indexOf(f);
        new_faces = new_faces.set(f, fs.get(face_cycle[ind + shift]));
    }
    var _arr7 = [datatypes_1.Face.t, datatypes_1.Face.b];
    for (var _i7 = 0; _i7 < _arr7.length; _i7++) {
        var _f2 = _arr7[_i7];
        new_faces = new_faces.set(_f2, fs.get(_f2).rotate(degrees));
    }
    return new_faces;
}
function roll_faces(fs, direction) {
    var new_faces = immutable_1.Map().asMutable();
    if (direction == datatypes_1.Direction.n) {
        new_faces.set(datatypes_1.Face.n, fs.get(datatypes_1.Face.t).rotate(180)).set(datatypes_1.Face.t, fs.get(datatypes_1.Face.s)).set(datatypes_1.Face.s, fs.get(datatypes_1.Face.b)).set(datatypes_1.Face.b, fs.get(datatypes_1.Face.n).rotate(180)).set(datatypes_1.Face.e, fs.get(datatypes_1.Face.e).rotate(90)).set(datatypes_1.Face.w, fs.get(datatypes_1.Face.w).rotate(270));
    } else if (direction == datatypes_1.Direction.s) {
        new_faces.set(datatypes_1.Face.s, fs.get(datatypes_1.Face.t)).set(datatypes_1.Face.t, fs.get(datatypes_1.Face.n).rotate(180)).set(datatypes_1.Face.n, fs.get(datatypes_1.Face.b)).set(datatypes_1.Face.b, fs.get(datatypes_1.Face.s).rotate(180)).set(datatypes_1.Face.e, fs.get(datatypes_1.Face.e).rotate(270)).set(datatypes_1.Face.w, fs.get(datatypes_1.Face.w).rotate(90));
    } else if (direction == datatypes_1.Direction.e) {
        new_faces.set(datatypes_1.Face.e, fs.get(datatypes_1.Face.t).rotate(90)).set(datatypes_1.Face.t, fs.get(datatypes_1.Face.w).rotate(90)).set(datatypes_1.Face.w, fs.get(datatypes_1.Face.b).rotate(270)).set(datatypes_1.Face.b, fs.get(datatypes_1.Face.e).rotate(270)).set(datatypes_1.Face.n, fs.get(datatypes_1.Face.n).rotate(270)).set(datatypes_1.Face.s, fs.get(datatypes_1.Face.s).rotate(90));
    } else if (direction == datatypes_1.Direction.w) {
        new_faces.set(datatypes_1.Face.w, fs.get(datatypes_1.Face.t).rotate(270)).set(datatypes_1.Face.t, fs.get(datatypes_1.Face.e).rotate(270)).set(datatypes_1.Face.e, fs.get(datatypes_1.Face.b).rotate(90)).set(datatypes_1.Face.b, fs.get(datatypes_1.Face.w).rotate(90)).set(datatypes_1.Face.n, fs.get(datatypes_1.Face.n).rotate(90)).set(datatypes_1.Face.s, fs.get(datatypes_1.Face.s).rotate(270));
    }
    return new_faces.asImmutable();
}
function test() {
    var bm = new BoxMesh({ dimensions: [2, 3, 4] });
    var bm2 = bm.cut(datatypes_1.Face.t, [0, 0], [1, 0]).cut(datatypes_1.Face.t, [1, 0], [1, 1]).cut(datatypes_1.Face.t, [1, 1], [0, 1]).cut(datatypes_1.Face.t, [0, 1], [0, 0]);
    var bm3 = bm2.cut(datatypes_1.Face.t, [0, 1], [0, 2]).cut(datatypes_1.Face.s, [0, 0], [0, 1]).cut(datatypes_1.Face.s, [0, 1], [1, 1]).cut(datatypes_1.Face.s, [1, 1], [1, 0]).cut(datatypes_1.Face.t, [1, 2], [1, 1]);
    var bm4 = bm.cut(datatypes_1.Face.t, [0, 0], [1, 0]).roll(datatypes_1.Direction.s).cut(datatypes_1.Face.t, [0, 2], [0, 1]).cut(datatypes_1.Face.t, [0, 1], [1, 1]).cut(datatypes_1.Face.t, [1, 1], [1, 2]);
    var bm5 = bm.cut(datatypes_1.Face.n, [0, 0], [1, 0]).cut(datatypes_1.Face.n, [1, 0], [2, 0]).cut(datatypes_1.Face.n, [2, 0], [2, 1]).cut(datatypes_1.Face.n, [2, 1], [1, 1]).cut(datatypes_1.Face.n, [1, 1], [0, 1]).cut(datatypes_1.Face.n, [1, 1], [1, 0]).cut(datatypes_1.Face.n, [0, 1], [0, 0]);
    var bm6 = bm.cut(datatypes_1.Face.t, [0, 0], [0, 1]).cut(datatypes_1.Face.t, [0, 1], [1, 1]).cut(datatypes_1.Face.t, [1, 1], [1, 0]);
    var bm7 = bm2.cut(datatypes_1.Face.t, [0, 1], [0, 2]).cut(datatypes_1.Face.t, [1, 1], [1, 2]);
    var bm8 = bm.cut(datatypes_1.Face.t, [0, 0], [1, 0]).cut(datatypes_1.Face.t, [1, 0], [2, 0]).cut(datatypes_1.Face.t, [2, 0], [2, 1]).cut(datatypes_1.Face.t, [2, 1], [2, 2]).cut(datatypes_1.Face.t, [0, 2], [0, 1]).cut(datatypes_1.Face.t, [0, 1], [1, 1]).cut(datatypes_1.Face.t, [1, 1], [1, 2]).cut(datatypes_1.Face.s, [1, 0], [1, 1]).cut(datatypes_1.Face.s, [1, 1], [0, 1]).cut(datatypes_1.Face.w, [0, 0], [0, 1]).cut(datatypes_1.Face.w, [0, 1], [1, 1]).cut(datatypes_1.Face.w, [1, 1], [2, 1]);
    var bms = [bm, bm2, bm3, bm4, bm5, bm6, bm7, bm8];
    for (var i = 0; i < bms.length; i++) {
        var b = bms[i];
        console.log('Box #', i + 1);
        console.log();
        console.log(b.description());
        console.log();
        console.log();
    }
}
exports.test = test;
test();
var _a;

},{"./datatypes":3,"immutable":1}],3:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

Object.defineProperty(exports, "__esModule", { value: true });
var immutable_1 = require("immutable");

var Edge = function () {
    function Edge(start, end) {
        _classCallCheck(this, Edge);

        if (end < start) {
            this.start = end;
            this.end = start;
        } else {
            this.start = start;
            this.end = end;
        }
    }

    _createClass(Edge, [{
        key: "equals",
        value: function equals(other) {
            return this.start == other.start && this.end == other.end;
        }
    }, {
        key: "hashCode",
        value: function hashCode() {
            return immutable_1.hash(immutable_1.hash(this.start) + immutable_1.hash(this.end));
            // fuck
            // return ( this.end << 16 ) ^ this.start;
        }
    }]);

    return Edge;
}();

exports.Edge = Edge;
var Face;
(function (Face) {
    Face[Face["n"] = 0] = "n";
    Face[Face["s"] = 1] = "s";
    Face[Face["e"] = 2] = "e";
    Face[Face["w"] = 3] = "w";
    Face[Face["t"] = 4] = "t";
    Face[Face["b"] = 5] = "b";
})(Face = exports.Face || (exports.Face = {}));
exports.faces = [Face.n, Face.s, Face.e, Face.w, Face.t, Face.b];
var Direction;
(function (Direction) {
    Direction[Direction["n"] = 0] = "n";
    Direction[Direction["s"] = 1] = "s";
    Direction[Direction["e"] = 2] = "e";
    Direction[Direction["w"] = 3] = "w";
})(Direction = exports.Direction || (exports.Direction = {}));
exports.directions = [Direction.n, Direction.s, Direction.e, Direction.w];

var Dangle = function () {
    function Dangle(partition, edges, fixed_face, free_face) {
        _classCallCheck(this, Dangle);

        this.partition = partition;
        this.edges = edges;
        this.fixed_face = fixed_face;
        this.free_face = free_face;
    }

    _createClass(Dangle, [{
        key: "equals",
        value: function equals(other) {
            return this.partition.equals(other.partition) && this.edges.equals(other.edges) && this.fixed_face === other.fixed_face && this.free_face === other.free_face;
        }
    }, {
        key: "hashCode",
        value: function hashCode() {
            return immutable_1.hash(immutable_1.hash(this.partition) + immutable_1.hash(this.edges) + immutable_1.hash(this.fixed_face) + immutable_1.hash(this.free_face));
            //let faces_hash = (this.fixed_face << 16) ^ this.free_face; //fuck!
            //return this.partition.hashCode() + this.edges.hashCode() + faces_hash;
        }
    }]);

    return Dangle;
}();

exports.Dangle = Dangle;
function make_matrix2(data_obj) {
    var dim_y = data_obj.length;
    var dim_x = data_obj[0].length;
    var data = new Int16Array(data_obj.reduce(function (x, y) {
        return x.concat(y);
    }));
    // TODO complain if the total length is wrong
    return new Matrix2(data, dim_x, dim_y);
}
exports.make_matrix2 = make_matrix2;

var Matrix2 = function () {
    function Matrix2(data, dim_x, dim_y) {
        _classCallCheck(this, Matrix2);

        this.data = data;
        this.dim_x = dim_x;
        this.dim_y = dim_y;
    }

    _createClass(Matrix2, [{
        key: "get",
        value: function get(x, y) {
            return this.data[y * this.dim_x + x];
        }
    }, {
        key: "set",
        value: function set(x, y, value) {
            this.data[y * this.dim_x + x] = value;
        }
    }, {
        key: "rotate",
        value: function rotate(degrees) {
            //validate input better
            if (degrees == 360 || degrees == 0) {
                return this;
            }
            var n_rotations = degrees / 90;
            var m = this;
            var dim_x = this.dim_x;
            var dim_y = this.dim_y;
            for (var i = 0; i < n_rotations; i++) {
                var new_data = new Int16Array(dim_x * dim_y);
                var new_mat2 = new Matrix2(new_data, dim_y, dim_x);
                for (var y = 0; y < dim_y; y++) {
                    for (var x = 0; x < dim_x; x++) {
                        new_mat2.set(dim_y - 1 - y, x, m.get(x, y));
                    }
                }
                m = new_mat2;
            }
            return m;
        }
    }, {
        key: "contains",
        value: function contains(value) {
            return this.data.indexOf(value) !== -1;
        }
    }]);

    return Matrix2;
}();

exports.Matrix2 = Matrix2;
var CardboardEdge;
(function (CardboardEdge) {
    CardboardEdge[CardboardEdge["intact"] = 0] = "intact";
    CardboardEdge[CardboardEdge["cut"] = 1] = "cut";
})(CardboardEdge = exports.CardboardEdge || (exports.CardboardEdge = {}));
var TapeEdge;
(function (TapeEdge) {
    TapeEdge[TapeEdge["untaped"] = 0] = "untaped";
    TapeEdge[TapeEdge["taped"] = 1] = "taped";
    TapeEdge[TapeEdge["cut"] = 2] = "cut";
})(TapeEdge = exports.TapeEdge || (exports.TapeEdge = {}));

var EdgeState = function () {
    function EdgeState(cardboard, tape) {
        _classCallCheck(this, EdgeState);

        this.cardboard = cardboard;
        this.tape = tape;
    }

    _createClass(EdgeState, [{
        key: "cut",
        value: function cut() {
            var new_tape = void 0;
            if (this.tape == TapeEdge.taped) {
                new_tape = TapeEdge.cut;
            } else {
                new_tape = this.tape;
            }
            return new EdgeState(CardboardEdge.cut, new_tape);
        }
    }, {
        key: "apply_tape",
        value: function apply_tape() {
            return new EdgeState(this.cardboard, TapeEdge.taped);
        }
    }]);

    return EdgeState;
}();

exports.EdgeState = EdgeState;
var EdgeOperation;
(function (EdgeOperation) {
    EdgeOperation[EdgeOperation["cut"] = 0] = "cut";
    EdgeOperation[EdgeOperation["tape"] = 1] = "tape";
})(EdgeOperation = exports.EdgeOperation || (exports.EdgeOperation = {}));
var RendState;
(function (RendState) {
    RendState[RendState["closed"] = 0] = "closed";
    RendState[RendState["open"] = 1] = "open";
})(RendState = exports.RendState || (exports.RendState = {}));
var RendOperation;
(function (RendOperation) {
    RendOperation[RendOperation["close"] = 0] = "close";
    RendOperation[RendOperation["open"] = 1] = "open";
})(RendOperation = exports.RendOperation || (exports.RendOperation = {}));
var SpillageLevel;
(function (SpillageLevel) {
    SpillageLevel[SpillageLevel["none"] = 0] = "none";
    SpillageLevel[SpillageLevel["light"] = 1] = "light";
    SpillageLevel[SpillageLevel["heavy"] = 2] = "heavy";
})(SpillageLevel = exports.SpillageLevel || (exports.SpillageLevel = {}));
var Weight;
(function (Weight) {
    Weight[Weight["empty"] = 0] = "empty";
    Weight[Weight["very_light"] = 1] = "very_light";
    Weight[Weight["light"] = 2] = "light";
    Weight[Weight["medium"] = 3] = "medium";
    Weight[Weight["heavy"] = 4] = "heavy";
    Weight[Weight["very_heavy"] = 5] = "very_heavy";
})(Weight = exports.Weight || (exports.Weight = {}));

var Item = function () {
    function Item() {
        _classCallCheck(this, Item);
    }

    _createClass(Item, [{
        key: "article",
        value: function article() {
            return 'a';
        }
    }]);

    return Item;
}();

exports.Item = Item;
function counter_add(counter, key, inc) {
    var cur_val = 0;
    if (counter.has(key)) {
        cur_val = counter.get(key);
    }
    return counter.set(key, cur_val + inc);
}
exports.counter_add = counter_add;
function counter_get(counter, key) {
    var cur_val = 0;
    if (counter.has(key)) {
        cur_val = counter.get(key);
    }
    return cur_val;
}
exports.counter_get = counter_get;
function counter_update(counter1, counter2) {
    var switch_to_immutable = immutable_1.isImmutable(counter1);
    var result = counter1.asMutable();
    counter2.forEach(function (v, k) {
        counter_add(result, k, v);
    });
    if (switch_to_immutable) {
        result = result.asImmutable();
    }
    return result;
}
exports.counter_update = counter_update;

var WreckError = function (_Error) {
    _inherits(WreckError, _Error);

    function WreckError() {
        _classCallCheck(this, WreckError);

        return _possibleConstructorReturn(this, (WreckError.__proto__ || Object.getPrototypeOf(WreckError)).apply(this, arguments));
    }

    return WreckError;
}(Error);

exports.WreckError = WreckError;
// used to signal errors caused by trying to update world state in a way that breaks the reality of the world
// so assumes that commands are already valid, the attempted update *could work* if the state were different

var WorldUpdateError = function (_WreckError) {
    _inherits(WorldUpdateError, _WreckError);

    function WorldUpdateError() {
        _classCallCheck(this, WorldUpdateError);

        return _possibleConstructorReturn(this, (WorldUpdateError.__proto__ || Object.getPrototypeOf(WorldUpdateError)).apply(this, arguments));
    }

    return WorldUpdateError;
}(WreckError);

exports.WorldUpdateError = WorldUpdateError;
// used to signal that a command/pseudo command is not specified legally
// the command cannot be executed because it *cannot be interpreted*

var CommandError = function (_WreckError2) {
    _inherits(CommandError, _WreckError2);

    function CommandError() {
        _classCallCheck(this, CommandError);

        return _possibleConstructorReturn(this, (CommandError.__proto__ || Object.getPrototypeOf(CommandError)).apply(this, arguments));
    }

    return CommandError;
}(WreckError);

exports.CommandError = CommandError;

},{"immutable":1}],4:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
var datatypes_1 = require("./datatypes");

var Codex = function (_datatypes_1$Item) {
    _inherits(Codex, _datatypes_1$Item);

    function Codex() {
        _classCallCheck(this, Codex);

        return _possibleConstructorReturn(this, (Codex.__proto__ || Object.getPrototypeOf(Codex)).apply(this, arguments));
    }

    _createClass(Codex, [{
        key: "weight",
        value: function weight() {
            return datatypes_1.Weight.medium;
        }
    }, {
        key: "name",
        value: function name() {
            return 'codex';
        }
    }, {
        key: "pre_gestalt",
        value: function pre_gestalt() {
            return 'something thick and aged';
        }
    }, {
        key: "post_gestalt",
        value: function post_gestalt() {
            return 'a thick, rotten codex with strange markings on the front';
        }
    }]);

    return Codex;
}(datatypes_1.Item);

exports.Codex = Codex;

var CityKey = function (_datatypes_1$Item2) {
    _inherits(CityKey, _datatypes_1$Item2);

    function CityKey() {
        _classCallCheck(this, CityKey);

        return _possibleConstructorReturn(this, (CityKey.__proto__ || Object.getPrototypeOf(CityKey)).apply(this, arguments));
    }

    _createClass(CityKey, [{
        key: "weight",
        value: function weight() {
            return datatypes_1.Weight.light;
        }
    }, {
        key: "name",
        value: function name() {
            return 'Key to the City';
        }
    }, {
        key: "pre_gestalt",
        value: function pre_gestalt() {
            return 'something glistening and golden';
        }
    }, {
        key: "post_gestalt",
        value: function post_gestalt() {
            return 'a large, heavy golden key';
        }
    }, {
        key: "article",
        value: function article() {
            return 'the';
        }
    }]);

    return CityKey;
}(datatypes_1.Item);

exports.CityKey = CityKey;

var Pinecone = function (_datatypes_1$Item3) {
    _inherits(Pinecone, _datatypes_1$Item3);

    function Pinecone() {
        _classCallCheck(this, Pinecone);

        return _possibleConstructorReturn(this, (Pinecone.__proto__ || Object.getPrototypeOf(Pinecone)).apply(this, arguments));
    }

    _createClass(Pinecone, [{
        key: "weight",
        value: function weight() {
            return datatypes_1.Weight.very_light;
        }
    }, {
        key: "name",
        value: function name() {
            return 'pinecone';
        }
    }, {
        key: "pre_gestalt",
        value: function pre_gestalt() {
            return 'something small, brown and flaky';
        }
    }, {
        key: "post_gestalt",
        value: function post_gestalt() {
            return 'a small, brown pinecone that smells of the outdoors';
        }
    }]);

    return Pinecone;
}(datatypes_1.Item);

exports.Pinecone = Pinecone;

},{"./datatypes":3}],5:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function uncapitalize(msg) {
    return msg[0].toLowerCase() + msg.slice(1);
}
exports.uncapitalize = uncapitalize;
function capitalize(msg) {
    return msg[0].toUpperCase() + msg.slice(1);
}
exports.capitalize = capitalize;

},{}],6:[function(require,module,exports){
"use strict";

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

Object.defineProperty(exports, "__esModule", { value: true });
var box_geometry_1 = require("./box_geometry");
var datatypes_1 = require("./datatypes");
var world_update_effects_1 = require("./world_update_effects");
var text_tools_1 = require("./text_tools");
var immutable_1 = require("immutable");

var Box = function () {
    function Box(_ref) {
        var box_mesh = _ref.box_mesh,
            rend_state = _ref.rend_state,
            dangle_state = _ref.dangle_state,
            edge_state = _ref.edge_state,
            contents = _ref.contents;

        _classCallCheck(this, Box);

        if (box_mesh === undefined) {
            box_mesh = new box_geometry_1.BoxMesh([2, 2, 2]);
        }
        this.box_mesh = box_mesh;
        if (rend_state === undefined) {
            rend_state = this.default_rend_state(this.box_mesh);
        }
        this.rend_state = rend_state;
        if (dangle_state === undefined) {
            dangle_state = this.default_dangle_state(this.box_mesh);
        }
        this.dangle_state = dangle_state;
        if (edge_state === undefined) {
            edge_state = immutable_1.Map();
        }
        this.edge_state = edge_state;
        if (contents === undefined) {
            contents = immutable_1.List();
        }
        this.contents = contents;
    }

    _createClass(Box, [{
        key: "update",
        value: function update(_ref2) {
            var box_mesh = _ref2.box_mesh,
                rend_state = _ref2.rend_state,
                dangle_state = _ref2.dangle_state,
                edge_state = _ref2.edge_state,
                contents = _ref2.contents;

            if (box_mesh === undefined) {
                box_mesh = this.box_mesh;
            }
            if (rend_state === undefined) {
                rend_state = this.rend_state;
            }
            if (dangle_state === undefined) {
                dangle_state = this.dangle_state;
            }
            if (edge_state === undefined) {
                edge_state = this.edge_state;
            }
            if (contents === undefined) {
                contents = this.contents;
            }
            return new Box({ box_mesh: box_mesh, rend_state: rend_state, dangle_state: dangle_state, edge_state: edge_state, contents: contents });
        }
    }, {
        key: "default_rend_state",
        value: function default_rend_state(box_mesh) {
            var rends = box_mesh.get_free_rends();
            var result = immutable_1.Map().asMutable();
            rends.forEach(function (r) {
                result.set(r, datatypes_1.RendState.closed);
            });
            return result.asImmutable();
        }
    }, {
        key: "default_dangle_state",
        value: function default_dangle_state(box_mesh) {
            var dangles = box_mesh.get_dangles();
            var result = immutable_1.Map().asMutable();
            dangles.forEach(function (d) {
                result.set(d, datatypes_1.RendState.closed);
            });
            return result.asImmutable();
        }
    }, {
        key: "open_or_close_rend",
        value: function open_or_close_rend(operation, rend) {
            var box_rends = this.box_mesh.get_rends();
            if (!box_rends.contains(rend)) {
                throw new datatypes_1.CommandError('rend does not exist on the box');
            }
            if (this.box_mesh.is_partition_fixed(rend)) {
                throw new datatypes_1.WorldUpdateError('cannot open or close a fixed rend');
            }
            var new_rend_state = this.rend_state;
            var intended_new_state = operation == datatypes_1.RendOperation.close ? datatypes_1.RendState.closed : datatypes_1.RendState.open;
            if (intended_new_state == new_rend_state.get(rend)) {
                throw new datatypes_1.WorldUpdateError("cannot " + operation + " a rend that is already " + intended_new_state);
            }
            new_rend_state = new_rend_state.set(rend, intended_new_state);
            var new_box = this.update({ rend_state: new_rend_state });
            if (new_box.is_collapsed()) {
                var _effects$collapse_spi;

                var effects = world_update_effects_1.world_update.effects;
                effects.box_collapsed = true;
                effects.collapse_spilled_items = (_effects$collapse_spi = effects.collapse_spilled_items).push.apply(_effects$collapse_spi, _toConsumableArray(new_box.contents.toArray()));
                var new_contents = immutable_1.List();
                new_box = new_box.update({ contents: new_contents });
            }
            return new_box;
        }
    }, {
        key: "open_or_close_dangle",
        value: function open_or_close_dangle(operation, dangle) {
            if (this.box_mesh.is_partition_fixed(dangle.partition)) {
                throw new datatypes_1.WorldUpdateError('cannot open or close a fixed dangle');
            }
            var box_dangles = this.box_mesh.get_dangles();
            if (box_dangles.some(function (d) {
                return dangle == d;
            })) {
                throw new datatypes_1.CommandError('dangle does not exist on the box');
            }
            var intended_new_state = operation == datatypes_1.RendOperation.close ? datatypes_1.RendState.closed : datatypes_1.RendState.open;
            if (this.dangle_state.get(dangle) == intended_new_state) {
                throw new datatypes_1.WorldUpdateError('cannot ${operation} a dangle that is already ${intended_new_state}');
            }
            var new_dangle_state = this.dangle_state.set(dangle, intended_new_state);
            var new_box = this.update({ dangle_state: new_dangle_state });
            if (new_box.is_collapsed()) {
                var _effects$collapse_spi2;

                var effects = world_update_effects_1.world_update.effects;
                effects.box_collapsed = true;
                effects.collapse_spilled_items = (_effects$collapse_spi2 = effects.collapse_spilled_items).push.apply(_effects$collapse_spi2, _toConsumableArray(new_box.contents.toArray()));
                var new_contents = immutable_1.List();
                new_box = new_box.update({ contents: new_contents });
            }
            return new_box;
        }
    }, {
        key: "rotate_y",
        value: function rotate_y(degrees) {
            var new_box_mesh = this.box_mesh.rotate_y(degrees);
            return this.update(new_box_mesh);
        }
    }, {
        key: "roll",
        value: function roll(direction) {
            if (this.dangle_state.some(function (state) {
                return state == datatypes_1.RendState.open;
            })) {
                throw new datatypes_1.WorldUpdateError('cannot roll a box with open dangles');
            }
            var new_box_mesh = this.box_mesh.roll(direction);
            var dir_face = datatypes_1.Face[datatypes_1.Direction[direction]];
            var new_contents = this.contents;
            var rend_state_updates = this.rend_state;
            var dangle_state_updates = this.dangle_state;
            var inner_this = this;
            var effects = world_update_effects_1.world_update.effects;
            if (new_contents.size > 0) {
                var dir_2_opposite = immutable_1.Map([[datatypes_1.Face.n, datatypes_1.Face.s], [datatypes_1.Face.s, datatypes_1.Face.n], [datatypes_1.Face.e, datatypes_1.Face.w], [datatypes_1.Face.w, datatypes_1.Face.e]]);
                var heavy_spill_faces = [[datatypes_1.Face[datatypes_1.Direction[direction]], datatypes_1.Face.b], [datatypes_1.Face.t, dir_face], [datatypes_1.Face.b, dir_2_opposite.get(dir_face)]];
                var light_spill_faces = [datatypes_1.Face.n, datatypes_1.Face.s, datatypes_1.Face.e, datatypes_1.Face.w].filter(function (d) {
                    return d !== dir_face && d !== dir_2_opposite.get(dir_face);
                });
                this.rend_state.forEach(function (state, r) {
                    var face_membership = inner_this.box_mesh.get_partition_face_membership(r);
                    var _iteratorNormalCompletion = true;
                    var _didIteratorError = false;
                    var _iteratorError = undefined;

                    try {
                        for (var _iterator = heavy_spill_faces[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                            var _step$value = _slicedToArray(_step.value, 2),
                                test_face = _step$value[0],
                                spill_face = _step$value[1];

                            if (face_membership.get(test_face) > 0) {
                                var _effects$spilled_item;

                                effects.spill_faces = effects.spill_faces.push(spill_face);
                                effects.spillage_level = datatypes_1.SpillageLevel.heavy;
                                effects.spilled_items = (_effects$spilled_item = effects.spilled_items).push.apply(_effects$spilled_item, _toConsumableArray(new_contents.toArray()));
                                new_contents = immutable_1.List();
                                if (state == datatypes_1.RendState.closed) {
                                    effects.spilled_rends == effects.spilled_rends.add(r);
                                    rend_state_updates = rend_state_updates.set(r, datatypes_1.RendState.open);
                                }
                            }
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return) {
                                _iterator.return();
                            }
                        } finally {
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }

                    var _iteratorNormalCompletion2 = true;
                    var _didIteratorError2 = false;
                    var _iteratorError2 = undefined;

                    try {
                        for (var _iterator2 = light_spill_faces[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                            var spill_face = _step2.value;

                            if (face_membership.get(spill_face) > 0) {
                                effects.spill_faces = effects.spill_faces.push(spill_face);
                                if (effects.spillage_level < datatypes_1.SpillageLevel.light) {
                                    effects.spillage_level = datatypes_1.SpillageLevel.light;
                                }
                                if (new_contents.size > 0) {
                                    effects.spilled_items = effects.spilled_items.push(new_contents.first());
                                    new_contents = new_contents.rest();
                                }
                            }
                        }
                    } catch (err) {
                        _didIteratorError2 = true;
                        _iteratorError2 = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion2 && _iterator2.return) {
                                _iterator2.return();
                            }
                        } finally {
                            if (_didIteratorError2) {
                                throw _iteratorError2;
                            }
                        }
                    }
                });
                this.box_mesh.get_dangles().forEach(function (d) {
                    var spillage_level = datatypes_1.SpillageLevel.none;
                    var spill_face = void 0;
                    if (d.free_face == datatypes_1.Face.t) {
                        spillage_level = datatypes_1.SpillageLevel.heavy;
                        spill_face = datatypes_1.Face[datatypes_1.Direction[direction]];
                    } else if (d.free_face == dir_face) {
                        spillage_level = datatypes_1.SpillageLevel.heavy;
                        spill_face = datatypes_1.Face.b;
                    } else if (light_spill_faces.indexOf(d.free_face) !== -1) {
                        spillage_level = datatypes_1.SpillageLevel.light;
                        spill_face = d.free_face;
                    }
                    if (spillage_level !== datatypes_1.SpillageLevel.none) {
                        if (spillage_level > effects.spillage_level) {
                            effects.spillage_level = spillage_level;
                        }
                        effects.spill_faces = effects.spill_faces.push(spill_face);
                        if (spillage_level == datatypes_1.SpillageLevel.light) {
                            if (new_contents.size > 0) {
                                effects.spilled_items = effects.spilled_items.push(new_contents.first());
                                new_contents = new_contents.rest();
                            }
                        } else if (spillage_level == datatypes_1.SpillageLevel.heavy) {
                            var _effects$spilled_item2;

                            effects.spilled_items = (_effects$spilled_item2 = effects.spilled_items).push.apply(_effects$spilled_item2, _toConsumableArray(new_contents.toArray()));
                            new_contents = immutable_1.List();
                        }
                        effects.spilled_dangles = effects.spilled_dangles.add(d);
                        dangle_state_updates = dangle_state_updates.set(d, datatypes_1.RendState.open);
                    }
                });
                new_box_mesh.get_dangles().forEach(function (d) {
                    if (d.free_face == dir_2_opposite.get(dir_face)) {
                        var _effects$spilled_item3;

                        effects.spillage_level = datatypes_1.SpillageLevel.heavy;
                        effects.spill_faces = effects.spill_faces.push(dir_2_opposite.get(dir_face));
                        effects.spilled_items = (_effects$spilled_item3 = effects.spilled_items).push.apply(_effects$spilled_item3, _toConsumableArray(new_contents.toArray()));
                        new_contents = immutable_1.List();
                        effects.spilled_dangles = effects.spilled_dangles.add(d);
                        dangle_state_updates = dangle_state_updates.set(d, datatypes_1.RendState.open);
                    }
                });
            }
            var new_box = this.update({
                box_mesh: new_box_mesh,
                rend_state: rend_state_updates,
                dangle_state: dangle_state_updates,
                contents: new_contents
            });
            if (new_box.is_collapsed()) {
                var _effects$collapse_spi3;

                effects.box_collapsed = true;
                effects.collapse_spilled_items = (_effects$collapse_spi3 = effects.collapse_spilled_items).push.apply(_effects$collapse_spi3, _toConsumableArray(new_contents.toArray()));
                new_contents = immutable_1.List();
                new_box = new_box.update({ contents: new_contents });
            }
            return new_box;
        }
    }, {
        key: "lift",
        value: function lift() {
            var effects = world_update_effects_1.world_update.effects;
            var inner_this = this;
            var new_contents = this.contents;
            var new_rend_state = this.rend_state;
            var new_dangle_state = this.dangle_state;
            if (new_contents.size > 0) {
                var test_box_mesh = this.box_mesh.roll(datatypes_1.Direction.s).roll(datatypes_1.Direction.s);
                test_box_mesh.get_free_rends().forEach(function (r) {
                    var face_membership = test_box_mesh.get_partition_face_membership(r);
                    var test_faces = [datatypes_1.Face.b, datatypes_1.Face.n, datatypes_1.Face.s, datatypes_1.Face.e, datatypes_1.Face.w];
                    var count = test_faces.map(face_membership.get).reduce(function (x, y) {
                        return x + y;
                    });
                    if (face_membership.get(datatypes_1.Face.t) > count) {
                        var _effects$spilled_item4;

                        effects.spillage_level = datatypes_1.SpillageLevel.heavy;
                        effects.spill_faces = effects.spill_faces.push(datatypes_1.Face.b);
                        effects.spilled_items = (_effects$spilled_item4 = effects.spilled_items).push.apply(_effects$spilled_item4, _toConsumableArray(new_contents.toArray()));
                        new_contents = immutable_1.List();
                        if (new_rend_state.get(r, datatypes_1.RendState.closed) == datatypes_1.RendState.closed) {
                            effects.spilled_rends = effects.spilled_rends.add(r);
                            new_rend_state = new_rend_state.set(r, datatypes_1.RendState.open);
                        }
                    }
                });
                test_box_mesh.get_dangles().forEach(function (d) {
                    if (d.free_face == datatypes_1.Face.t) {
                        var _effects$spilled_item5;

                        effects.spillage_level = datatypes_1.SpillageLevel.heavy;
                        effects.spill_faces = effects.spill_faces.push(datatypes_1.Face.b);
                        effects.spilled_items = (_effects$spilled_item5 = effects.spilled_items).push.apply(_effects$spilled_item5, _toConsumableArray(new_contents.toArray()));
                        new_contents = immutable_1.List();
                        effects.spilled_dangles = effects.spilled_dangles.add(d);
                        new_dangle_state = new_dangle_state.set(d, datatypes_1.RendState.open);
                    }
                });
                this.rend_state.forEach(function (state, r) {
                    var face_membership = inner_this.box_mesh.get_partition_face_membership(r);
                    var light_spill_faces = [datatypes_1.Face.n, datatypes_1.Face.s, datatypes_1.Face.e, datatypes_1.Face.w].filter(function (f) {
                        return face_membership.get(f) > 0;
                    });
                    if (light_spill_faces.length > 0) {
                        var _effects$spill_faces;

                        if (effects.spillage_level < datatypes_1.SpillageLevel.light) {
                            effects.spillage_level = datatypes_1.SpillageLevel.light;
                        }
                        (_effects$spill_faces = effects.spill_faces).push.apply(_effects$spill_faces, _toConsumableArray(light_spill_faces));
                        if (new_contents.size > 0) {
                            effects.spilled_items = effects.spilled_items.push(new_contents.first());
                            new_contents = new_contents.rest();
                        }
                        if (state == datatypes_1.RendState.closed) {
                            effects.spilled_rends.add(r);
                            new_rend_state = new_rend_state.set(r, datatypes_1.RendState.open);
                        }
                    }
                });
                this.dangle_state.forEach(function (state, d) {
                    if ([datatypes_1.Face.n, datatypes_1.Face.s, datatypes_1.Face.e, datatypes_1.Face.w].indexOf(d.free_face) !== -1) {
                        if (effects.spillage_level < datatypes_1.SpillageLevel.light) {
                            effects.spillage_level = datatypes_1.SpillageLevel.light;
                        }
                        effects.spill_faces.push(d.free_face);
                        if (new_contents.size > 0) {
                            effects.spilled_items = effects.spilled_items.push(new_contents.first());
                            new_contents = new_contents.rest();
                        }
                    }
                });
            }
            var new_box = this.update({ rend_state: new_rend_state, dangle_state: new_dangle_state, contents: new_contents });
            if (new_box.is_collapsed()) {
                var _effects$collapse_spi4;

                effects.box_collapsed = true;
                effects.collapse_spilled_items = (_effects$collapse_spi4 = effects.collapse_spilled_items).push.apply(_effects$collapse_spi4, _toConsumableArray(new_contents.toArray()));
                new_contents = immutable_1.List();
                new_box = new_box.update({ contents: new_contents });
            }
            return new_box;
        }
    }, {
        key: "cut",
        value: function cut(face, start, end) {
            return this.cut_or_tape(datatypes_1.EdgeOperation.cut, face, start, end);
        }
    }, {
        key: "tape",
        value: function tape(face, start, end) {
            return this.cut_or_tape(datatypes_1.EdgeOperation.tape, face, start, end);
        }
    }, {
        key: "cut_or_tape",
        value: function cut_or_tape(operation, face, start, end) {
            var effects = world_update_effects_1.world_update.effects;
            var inner_this = this;
            if (face !== datatypes_1.Face.s && face !== datatypes_1.Face.t) {
                throw new datatypes_1.WorldUpdateError('cannot cut or tape sides other than top or front');
            }

            var _start = _slicedToArray(start, 2),
                x1 = _start[0],
                y1 = _start[1];

            var _end = _slicedToArray(end, 2),
                x2 = _end[0],
                y2 = _end[1];

            var v1 = this.box_mesh.face_meshes.get(face).vertices.get(x1, y1);
            var v2 = this.box_mesh.face_meshes.get(face).vertices.get(x2, y2);
            var edge = new datatypes_1.Edge(v1, v2);
            var quadrants = box_geometry_1.edge_2_quadrants.get(edge);
            this.rend_state.forEach(function (state, r) {
                if (state == datatypes_1.RendState.open && quadrants.every(r.contains)) {
                    throw new datatypes_1.WorldUpdateError('cannot cut or tape on an open rend');
                }
            });
            this.dangle_state.forEach(function (state, d) {
                if (state == datatypes_1.RendState.open && quadrants.every(d.partition.contains)) {
                    throw new datatypes_1.WorldUpdateError('cannot cut or tape on an open dangle');
                }
            });
            var new_box_mesh = void 0;
            if (operation == datatypes_1.EdgeOperation.cut) {
                new_box_mesh = this.box_mesh.cut(face, start, end);
            } else {
                new_box_mesh = this.box_mesh.tape(face, start, end);
            }
            var new_rend_state = this.default_rend_state(new_box_mesh);
            this.rend_state.forEach(function (state, r) {
                if (new_rend_state.has(r)) {
                    new_rend_state = new_rend_state.set(r, state);
                } else {
                    effects.repaired_rends = effects.repaired_rends.push(r);
                }
            });
            new_rend_state.forEach(function (state, new_r) {
                if (!inner_this.rend_state.has(new_r)) {
                    effects.new_rends = effects.new_rends.push(new_r);
                }
            });
            var new_dangle_state = this.default_dangle_state(new_box_mesh);
            this.dangle_state.forEach(function (state, d) {
                if (new_dangle_state.has(d)) {
                    new_dangle_state = new_dangle_state.set(d, state);
                } else {
                    effects.repaired_dangles = effects.repaired_dangles.push(d);
                }
            });
            new_dangle_state.forEach(function (state, new_d) {
                if (!inner_this.dangle_state.has(new_d)) {
                    effects.new_dangles = effects.new_dangles.push(new_d);
                }
            });
            var new_edge_state = this.edge_state;
            if (operation == datatypes_1.EdgeOperation.cut) {
                new_edge_state = new_edge_state.set(edge, new_edge_state.get(edge).cut());
            } else {
                new_edge_state = new_edge_state.set(edge, new_edge_state.get(edge).apply_tape());
            }
            return this.update({ box_mesh: new_box_mesh, rend_state: new_rend_state, dangle_state: new_dangle_state });
        }
    }, {
        key: "take_next_item",
        value: function take_next_item() {
            var effects = world_update_effects_1.world_update.effects;
            if (this.contents.size == 0) {
                throw new datatypes_1.WorldUpdateError('cannot take an item from an empty box');
            }
            if (!self.appears_open()) {
                throw new datatypes_1.WorldUpdateError('cannot take an item from a box with no visible openings');
            }
            var new_contents = this.contents;
            effects.taken_items = effects.taken_items.push(new_contents.first());
            new_contents = new_contents.rest();
            return this.update({ contents: new_contents });
        }
    }, {
        key: "next_item",
        value: function next_item() {
            if (this.contents.size == 0) {
                return null;
            }
            return this.contents.first();
        }
    }, {
        key: "appears_open",
        value: function appears_open() {
            if (this.rend_state.some(function (state) {
                return state == datatypes_1.RendState.open;
            })) {
                return true;
            }
            if (this.dangle_state.some(function (state) {
                return state == datatypes_1.RendState.open;
            })) {
                return true;
            }
            return false;
        }
    }, {
        key: "appears_empty",
        value: function appears_empty() {
            return this.appears_open() && this.contents.size == 0;
        }
    }, {
        key: "is_collapsed",
        value: function is_collapsed() {
            var open_faces = immutable_1.Map().asMutable();
            var inner_this = this;
            this.rend_state.forEach(function (state, r) {
                if (state == datatypes_1.RendState.open) {
                    var face_membership = inner_this.box_mesh.get_partition_face_membership(r);
                    datatypes_1.counter_update(open_faces, face_membership);
                }
            });
            this.dangle_state.forEach(function (state, d) {
                if (state == datatypes_1.RendState.open) {
                    var face_membership = inner_this.box_mesh.get_partition_face_membership(d.partition);
                    datatypes_1.counter_update(open_faces, face_membership);
                }
            });
            var total_open_sides = 0;
            open_faces.forEach(function (count, face) {
                if (count > 0) {
                    total_open_sides += 1;
                }
            });
            return total_open_sides >= 3;
        }
    }]);

    return Box;
}();

var SingleBoxWorld = function () {
    function SingleBoxWorld(_ref3) {
        var box = _ref3.box,
            taken_items = _ref3.taken_items,
            spilled_items = _ref3.spilled_items;

        _classCallCheck(this, SingleBoxWorld);

        if (box === undefined) {
            box = new Box({});
        }
        this.box = box;
        if (taken_items === undefined) {
            taken_items = immutable_1.List();
        }
        this.taken_items = taken_items;
        if (spilled_items === undefined) {
            spilled_items = immutable_1.List();
        }
        this.spilled_items = spilled_items;
    }

    _createClass(SingleBoxWorld, [{
        key: "update",
        value: function update(_ref4) {
            var box = _ref4.box,
                taken_items = _ref4.taken_items,
                spilled_items = _ref4.spilled_items;

            if (box === undefined) {
                box = this.box;
            }
            if (taken_items === undefined) {
                taken_items = this.taken_items;
            }
            if (spilled_items === undefined) {
                spilled_items = this.spilled_items;
            }
            return new SingleBoxWorld({ box: box, taken_items: taken_items, spilled_items: spilled_items });
        }
    }, {
        key: "command_rotate_y_box",
        value: function command_rotate_y_box(dir) {
            var degrees = dir == 'right' ? 90 : 270;
            var new_box = this.box.rotate_y(degrees);
            var new_world = this.update({ box: new_box });
            var message = "You turn the box 90 degrees to the " + dir;
            return [new_world, message];
        }
    }, {
        key: "command_roll_box",
        value: function command_roll_box(cmd) {
            var inner_this = this;
            return world_update_effects_1.with_world_update(function (effects) {
                var cmd_2_direction = immutable_1.Map([['forward', datatypes_1.Direction.n], ['backward', datatypes_1.Direction.s], ['left', datatypes_1.Direction.w], ['right', datatypes_1.Direction.e]]);
                var direction = cmd_2_direction.get(cmd);
                var new_box = inner_this.box.roll(direction);
                var dir_msg = cmd == 'left' || cmd == 'right' ? "over to the " + cmd : cmd;
                var message = void 0;
                var new_world = void 0;
                if (effects.spillage_level == datatypes_1.SpillageLevel.none) {
                    message = "You roll the box " + dir_msg;
                    new_world = inner_this.update({ box: new_box });
                } else {
                    var spill_msg = text_tools_1.uncapitalize(inner_this.spill_message(new_box));
                    message = "As you roll the box " + dir_msg + ", " + spill_msg;
                    new_world = inner_this.update({ box: new_box, spilled_items: effects.spilled_items });
                }
                if (effects.box_collapsed) {
                    message += '\nThe added stress on the box causes it to collapse in on itself.';
                    if (effects.collapse_spilled_items.size > 0) {
                        message += ' ';
                        message += inner_this.item_spill_message(effects.collapse_spilled_items);
                    }
                }
                return [new_world, message];
            });
        }
    }, {
        key: "item_spill_message",
        value: function item_spill_message(spilled_items) {
            var si = spilled_items;
            var during_spill_msg = void 0;
            var after_spill_msg = void 0;
            if (si.size == 1) {
                var item_msg = si.get(0).pre_gestalt();
                during_spill_msg = text_tools_1.capitalize(item_msg) + " spills out before you.";
                after_spill_msg = "It's " + si.get(0).article() + " " + si.get(0).name() + " - " + si.get(0).post_gestalt() + ".";
            } else {}
        }
    }]);

    return SingleBoxWorld;
}();

},{"./box_geometry":2,"./datatypes":3,"./text_tools":5,"./world_update_effects":7,"immutable":1}],7:[function(require,module,exports){
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

Object.defineProperty(exports, "__esModule", { value: true });
var datatypes_1 = require("./datatypes");
var immutable_1 = require("immutable");

var WorldUpdateEffects = function WorldUpdateEffects() {
    _classCallCheck(this, WorldUpdateEffects);

    this.spill_faces = immutable_1.List();
    this.spilled_items = immutable_1.List();
    this.spilled_rends = immutable_1.Set();
    this.spilled_dangles = immutable_1.Set();
    this.spillage_level = datatypes_1.SpillageLevel.none;
    this.taken_items = immutable_1.List();
    this.new_rends = immutable_1.List();
    this.new_dangles = immutable_1.List();
    this.repaired_rends = immutable_1.List();
    this.repaired_dangles = immutable_1.List();
    this.box_collapsed = false;
    this.collapse_spilled_items = immutable_1.List();
};

exports.WorldUpdateEffects = WorldUpdateEffects;
exports.world_update = {};
function with_world_update(f) {
    //TODO validate: error if world_update.effects isn't null/undefined
    exports.world_update.effects = new WorldUpdateEffects();
    var result = f(exports.world_update.effects);
    exports.world_update.effects = undefined;
    return result;
}
exports.with_world_update = with_world_update;
//TODO define world update exceptions

},{"./datatypes":3,"immutable":1}]},{},[2,3,4,6,7])

//# sourceMappingURL=bundle.js.map
